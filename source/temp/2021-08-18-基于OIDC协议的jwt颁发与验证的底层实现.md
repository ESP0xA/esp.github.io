---
title: 基于OIDC协议的jwt颁发与验证的底层实现
comments: true
date: 2021-08-18 09:15:08
tags:
    - Java
    - OIDC协议
categories:
    - [指尖飞舞, Java]
---
__摘要：__
第一次技术分享会。
<!-- more -->


## 什么是JWT



## jwt长什么样？

这是咱们嘉宾登录页面签发的JWT：
```java
eyJraWQiOiI2MGNjMWQ5Yi0wNTU2LTQxNjMtYTAwOS1mNTgxNmIwMzczZGMiLCJ0eXAiOiJKV1QiLCJhbGciOiJSUzI1NiJ9.eyJzdWIiOiJ6aGFuZ3lhbmciLCJhdWQiOiJmYjkxNzdhZC0xMTQ2LTQyYjgtODNhNy0yODNmNWVjMmE1YWUiLCJpc3MiOiJodHRwczpcL1wvbGluYW9uZWRldi5kaWdpdGFsZXhwby5jb20iLCJleHAiOjE2MjkxODk2MTQsIm5vbmNlIjoiMDQ4NTBGNzgxOTQwNDM5Nzg0Q0MzRDMzNkFFQ0I5QzUiLCJpYXQiOjE2MjkxODkzNTV9.XxT0haq4fOHO6QzPEHudd6Z4-F4oXkJLdut-xxUh7EGcKm5dLBvwHdvMci2IY6_LHIcUCKs4xQHRaj5GtgqDNvauGLF_Nb_BHjnuLwxLAasDhkzt3d4qEd_uz8Mb_6_AUm126tgYetxyMk7QlW2FC8M9Xm-2F60c73Hie_PyOdjA07o1ij2p4UvIKLfEvpKlKHBp9jCUj-tgQAG_rPqAC7NKF60z-idHJ5ekMnhV2MsdTLSRKWxOPM0l6TjA0YPSJFoE8PtGxD-D8Zk2GDRLTa530C9cKMnhuy9ydYF5_Io3LggOYdDqePtueNBl7FNHVgjFq0YP56uZ3uvLM0lBwA
```
简化版：
`xxxxx.yyyyy.zzzzz`

分为三个部分，中间用 `.` 隔开.

分别是：

+ Header
+ Payload
+ Signature

这三段都是经过Base64Url加密的字符串，它们紧凑而小巧，一旦登录的用户获得了服务端签发的jwt，那么它可以在随后的每次请求的时候将jwt放在header，url或者post body里面，用来高效验证登录信息，服务端只需要解密就可以得到用户信息，没必要反复查表，也避免了在内存中维护session。
__Header:__
分为类型和加密算法两个部分。比如：
```json
{
  "alg": "HS256",
  "typ": "JWT"
}
```

## 签发过程

Jwt的签发首先需要根据header和payload生成一个JWSObject，再调用JWSObject的sign方法进行签发。

### 使用RSA私钥生成一个JWSSigner对象
签发的实现过程会使用到这个key。
`RSAKey rsaKey = RSAKey.parse(OIDCConstants.RSA_PRIVATE_KEY);`
`JWSSigner signer = new RSASSASigner(rsaKey);`

### 配置Header
会将加密算法种类和生成对象的类型封装在header中。
因为在解密token的时候会先参考header从而选择正确的解密方法。
```Java
JWSHeader jwsHeader = new JWSHeader
        .Builder(JWSAlgorithm.RS256)
        .type(JOSEObjectType.JWT).keyID(keyId).build();
```

### 生成JWSObject(核心对象)
接下来根据OIDC协议将JWT所包含的信息封装在JWSObject对象中，OIDC协议中这部分的详细描述：
+ iss = Issuer Identifier：必须。提供认证信息者的唯一标识。一般是一个https的url（不包含querystring和fragment部分）。
+ sub = Subject Identifier：必须。iss提供的EU的标识，在iss范围内唯一。它会被RP用来标识唯一的用户。最长为255个ASCII个字符。
+ aud = Audience(s)：必须。标识ID Token的受众。必须包含OAuth2的client_id。
+ exp = Expiration time：必须。过期时间，超过此时间的ID Token会作废不再被验证通过。
+ iat = Issued At Time：必须。JWT的构建的时间。
+ auth_time = AuthenticationTime：EU完成认证的时间。如果RP发送AuthN请求的时候携带max_age的参数，则此Claim是必须的。
+ nonce：RP发送请求的时候提供的随机字符串，用来减缓重放攻击，也可以来关联ID Token和RP本身的Session信息。
+ acr = Authentication Context Class Reference：可选。表示一个认证上下文引用值，可以用来标识认证上下文类。
+ amr = Authentication Methods References：可选。表示一组认证方法。
+ azp = Authorized party：可选。结合aud使用。只有在被认证的一方和受众（aud）不一致时才使用此值，一般情况下很少使用。

具体的实现，是将上述参数封装在 `JWTClaimsSet` 这个静态类里面，`jwtClaimsSetBuilder` 是该静态类的内部类对象，用来设置封装这个过程。这些参数将会成为静态类的内部变量。
接着会将 `JWTClaimsSet` 转为一个JSON对象，`Payload` 相当于一个 `wapper` 包装器，这个 `new` 的过程底层基本上只是完成了一次 `this.json = json` 的过程。

```Java
    JWTClaimsSet jwtClaimsSet = jwtClaimsSetBuilder.issuer(jwtDomain.getIssuer())
            .subject(jwtDomain.getSubject())
            .audience(jwtDomain.getAudience())
            .expirationTime(jwtDomain.getExpirationTime())
            .issueTime(jwtDomain.getIssuedTime())
            .build();

    Payload payload = new Payload(jwtClaimsSet.toJSONObject());
    JWSObject jwsObject = new JWSObject(jwsHeader, payload);
```
接着会将header和payload封装成我们要的JWSObject类型。
我们重点关注一下JWSObject对象初始化的时候进行了哪些设置：
```Java
    public JWSObject(JWSHeader header, Payload payload) {
        if (header == null) {
            throw new IllegalArgumentException("The JWS header must not be null");
        } else {
            this.header = header;
            if (payload == null) {
                throw new IllegalArgumentException("The payload must not be null");
            } else {
                this.setPayload(payload);
                this.signingInputString = composeSigningInput(header.toBase64URL(), payload.toBase64URL());
                this.signature = null;
                this.state = JWSObject.State.UNSIGNED;
            }
        }
    }
```
> + 对header和payload判空，如果为空都会抛出异常。
> + 把header和payload初始化到对象内部。
> + 将header和payload用Base64URL进行编码再toString()。简单说就是将header和payload加密成一个字符串放在JWSObject内部。
> ```Java
public Base64URL toBase64URL() {
    return this.parsedBase64URL == null ? Base64URL.encode(this.toString()) : this.parsedBase64URL;
}
```
> + 将签发状态设置成`UNSIGNED`

下面重点关注sign()方法的底层实现。

### 签发`sign()` 方法的准备过程
在初始化JWSObject对象之后，会调用JWSObject对象的 `sign()` 方法来签发生成一个Json Web Token.
下面我们来一起看一下 `sign()` 方法的底层是怎么实现的。
```Java
    public synchronized void sign(JWSSigner signer) throws JOSEException {
        this.ensureUnsignedState();
        this.ensureJWSSignerSupport(signer);

        try {
            this.signature = signer.sign(this.getHeader(), this.getSigningInput());
        } catch (JOSEException var3) {
            throw var3;
        } catch (Exception var4) {
            throw new JOSEException(var4.getMessage(), var4);
        }

        this.state = JWSObject.State.SIGNED;
    }
```

> + 先确保“未签名”的状态，在初始化JWSObject对象的时候已经将状态初始化成了未签发状态。在签发之前，咱们必须确保状态是未签发的，否则抛出异常。
> ```Java
    private void ensureUnsignedState() {
        if (this.state != JWSObject.State.UNSIGNED) {
            throw new IllegalStateException("The JWS object must be in an unsigned state");
        }
    }
```
> + `signer` 这个对象是调用 `sign()` 方法时传入的，`signer.supportedJWSAlgorithms()`方法会返回所有支持的RSA加密算法类型，维护在一个哈希集合容器中。如果之前设置的算法加密类型不在该容器中的话，则抛出异常。
> ```Java
    private void ensureJWSSignerSupport(JWSSigner signer) throws JOSEException {
        if (!signer.supportedJWSAlgorithms().contains(this.getHeader().getAlgorithm())) {
            throw new JOSEException("The \"" + this.getHeader().getAlgorithm() + "\" algorithm is not allowed or supported by the JWS signer: Supported algorithms: " + signer.supportedJWSAlgorithms());
        }
    }
```
> + 在签发前的验证工作完成之后，最终调用 RSASSASigner 的sign()方法签发
> `this.signature = signer.sign(this.getHeader(), this.getSigningInput());`

好，在深入 `sign()` 底层之前，我们先梳理一下整套逻辑，关注一下方法到底做了什么。
`sign()` 方法会返回一个 `Base64URL` 对象并成为调用者对象（`JWSObject`）的一个内部对象。这是一个封装的过程。
也就是说，纵观整个签发过程，无非就是先生成一个 `JWSObject` 对象，封装了各种参数（用户信息，过期时间啥的），再将加密后的 `Base64URL` 再次封装。最后将 `JWSObject` 对象序列化成最终的 `JWT` 返回。

### RSASSASigner.signer()方法的底层实现（重点关注）
`RSASSASigner`（我称之为“签发器”）就是第一步用rsaKey生成的对象类型，回顾一下：
`JWSSigner signer = new RSASSASigner(rsaKey);`
显然 `JWSSigner` 是接口，而 `RSASSASigner` 是实现类。
```Java
    public Base64URL sign(JWSHeader header, byte[] signingInput) throws JOSEException {
        Signature signer = RSASSA.getSignerAndVerifier(header.getAlgorithm(), this.getJCAContext().getProvider());

        try {
            signer.initSign(this.privateKey);
            signer.update(signingInput);
            return Base64URL.encode(signer.sign());
        } catch (InvalidKeyException var5) {
            throw new JOSEException("Invalid private RSA key: " + var5.getMessage(), var5);
        } catch (SignatureException var6) {
            throw new JOSEException("RSA signature exception: " + var6.getMessage(), var6);
        }
    }
```
这三个方法是整个signer()的核心：
```Java
/*
Initialize this object for signing. If this method is called again with a different argument, it negates the effect of this call.
Params:
privateKey – the private key of the identity whose signature is going to be generated.
Throws:
InvalidKeyException – if the key is invalid.
*/
    public final void initSign(PrivateKey privateKey)
            throws InvalidKeyException {
        engineInitSign(privateKey);
        state = SIGN;

        if (!skipDebug && pdebug != null) {
            pdebug.println("Signature." + algorithm +
                " signing algorithm from: " + getProviderName());
        }
    }
```
```Java
/*
Updates the data to be signed or verified, using the specified array of bytes.
Params:
data – the byte array to use for the update.
Throws:
SignatureException – if this signature object is not initialized properly.
*/
    public final void update(byte[] data) throws SignatureException {
        update(data, 0, data.length);
    }
```
```Java
/*
Returns the signature bytes of all the data updated. The format of the signature depends on the underlying signature scheme.
A call to this method resets this signature object to the state it was in when previously initialized for signing via a call to initSign(PrivateKey). That is, the object is reset and available to generate another signature from the same signer, if desired, via new calls to update and sign.
Returns:
the signature bytes of the signing operation's result.
Throws:
SignatureException – if this signature object is not initialized properly or if this signature algorithm is unable to process the input data provided.
*/
    public final byte[] sign() throws SignatureException {
        if (state == SIGN) {
            return engineSign();
        }
        throw new SignatureException("object not initialized for " +
                                     "signing");
    }
```

```Java
    protected void engineInitSign(PrivateKey var1) throws InvalidKeyException {
        AsymmetricKeyParameter var2 = null;
        if (var1 instanceof BCDSTU4145PrivateKey) {
            var2 = ECUtil.generatePrivateKeyParameter(var1);
            this.digest = new GOST3411Digest(this.expandSbox(DSTU4145Params.getDefaultDKE()));
        } else if (var1 instanceof ECKey) {
            var2 = ECUtil.generatePrivateKeyParameter(var1);
            this.digest = new GOST3411Digest(this.expandSbox(DSTU4145Params.getDefaultDKE()));
        }

        if (this.appRandom != null) {
            this.signer.init(true, new ParametersWithRandom(var2, this.appRandom));
        } else {
            this.signer.init(true, var2);
        }

    }
```

```Java

```

重点关注engineSign()，这是签发的实现核心：
```Java
    protected byte[] engineSign() throws SignatureException {
        byte[] var1 = new byte[this.digest.getDigestSize()];
        this.digest.doFinal(var1, 0);

        try {
            BigInteger[] var2 = this.signer.generateSignature(var1);
            byte[] var3 = var2[0].toByteArray();
            byte[] var4 = var2[1].toByteArray();
            byte[] var5 = new byte[var3.length > var4.length ? var3.length * 2 : var4.length * 2];
            System.arraycopy(var4, 0, var5, var5.length / 2 - var4.length, var4.length);
            System.arraycopy(var3, 0, var5, var5.length - var3.length, var3.length);
            return (new DEROctetString(var5)).getEncoded();
        } catch (Exception var6) {
            throw new SignatureException(var6.toString());
        }
    }
```
```Java
    protected byte[] engineSign() throws SignatureException {
        if (this.privateKey == null) {
            throw new SignatureException("Missing private key");
        } else {
            byte[] var1 = this.getDigestValue();

            try {
                byte[] var2 = encodeSignature(this.digestOID, var1);
                byte[] var3 = this.padding.pad(var2);
                byte[] var4 = RSACore.rsa(var3, this.privateKey, true);
                return var4;
            } catch (GeneralSecurityException var5) {
                throw new SignatureException("Could not sign data", var5);
            } catch (IOException var6) {
                throw new SignatureException("Could not encode data", var6);
            }
        }
    }
```
```Java
    protected byte[] engineSign() throws SignatureException {
        byte[] var1 = new byte[this.digest.getDigestSize()];
        this.digest.doFinal(var1, 0);

        try {
            byte[] var2 = new byte[64];
            BigInteger[] var3 = this.signer.generateSignature(var1);
            byte[] var4 = var3[0].toByteArray();
            byte[] var5 = var3[1].toByteArray();
            if (var5[0] != 0) {
                System.arraycopy(var5, 0, var2, 32 - var5.length, var5.length);
            } else {
                System.arraycopy(var5, 1, var2, 32 - (var5.length - 1), var5.length - 1);
            }

            if (var4[0] != 0) {
                System.arraycopy(var4, 0, var2, 64 - var4.length, var4.length);
            } else {
                System.arraycopy(var4, 1, var2, 64 - (var4.length - 1), var4.length - 1);
            }

            return var2;
        } catch (Exception var6) {
            throw new SignatureException(var6.toString());
        }
    }
```

{% note primary %}
__原题链接：__ []()
{% endnote %}