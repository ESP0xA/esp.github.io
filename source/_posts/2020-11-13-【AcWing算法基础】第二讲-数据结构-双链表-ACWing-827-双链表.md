---
title: 【AcWing算法基础】第二讲-数据结构-双链表 ACWing 827. 双链表
comments: true
date: 2020-11-13 11:46:55
tags:
    - 算法
    - AcWing
    - 链表
    - 双链表
categories:
    - [指尖飞舞, 算法, AcWing, 算法基础课, 第二讲数据结构]
---
__摘要：__
数组模拟双链表模板题。
<!--more-->

### 题目
实现一个双链表，双链表初始为空，支持 $5$ 种操作：
1. 在最左侧插入一个数；
2. 在最右侧插入一个数；
3. 将第 $k$ 个插入的数删除；
4. 在第 $k$ 个插入的数左侧插入一个数；
5. 在第 $k$ 个插入的数右侧插入一个数
现在要对该链表进行 $M$ 次操作，进行完所有操作后，从左到右输出整个链表。

__注意：__ 题目中第 $k$ 个插入的数并不是指当前链表的第 $k$ 个数。例如操作过程中一共插入了 $n$ 个数，则按照插入的时间顺序，这 $n$ 个数依次为：第 $1$ 个插入的数，第 $2$ 个插入的数，…第 $n$ 个插入的数。

__输入格式__
第一行包含整数 $M$，表示操作次数。
接下来 $M$ 行，每行包含一个操作命令，操作命令可能为以下几种：
1. `L x`，表示在链表的最左端插入数 $x$。
2. `R x`，表示在链表的最右端插入数 $x$。
3. `D k`，表示将第 $k$ 个插入的数删除。
4. `IL k x`，表示在第 $k$ 个插入的数左侧插入一个数。
5. `IR k x`，表示在第 $k$个插入的数右侧插入一个数。

__输出格式__
共一行，将整个链表从左到右输出。

__数据范围__
+ $1≤M≤100000$
+ 所有操作保证合法。

__输入样例：__
> 10
> R 7
> D 1
> L 3
> IL 2 10
> D 3
> IL 2 7
> L 8
> R 9
> IL 4 7
> IR 2 2

__输出样例：__
> 8 7 7 3 2 9

___

### 数组模拟双链表的本质
双链表包含一个`head`结点一个`tail`结点（即使它是一个空链表，可以把`head`和`tail`看成是两个哨兵结点）。这两个结点可以看成是始终固定不动的。从双链表初始化起，到进行各种操作后形成最终链表，所有结点的增加和删除等操作均在`head`和`tail`中间进行。
对于双链表中的每个结点，我们用三个数组同一下标的元素表示。其中，包含一个结点值，一个前置指针（指向了结点前一个结点对应的数组下标），一个后置指针（指向了结点后一个结点对应的数组下标）。

### 思路
因为双链表的每个结点可以访问到其前后结点，所以对于这道题的每一个「插入」操作，都可以由一个方法实现。

### 代码
{% tabs g_tab0 %}
<!-- tab C++ -->
```C++
#include <bits/stdc++.h>

using namespace std;

constexpr int N = 100'007;
int e[N], l[N], r[N];
int idx;

// 在第k个点后面插一个x
inline void add(int k, int x)
{
    e[idx] = x;
    // 先确定新节点的左右节点
    l[idx] = k;     // 当前点的左节点为第k个节点
    r[idx] = r[k];  // 当前点（第idx个点）的右节点为第k个点的右节点
    
    // 再确定第k个节点右节点的左节点和第k个节点的右节点
    l[r[k]] = idx;  // 第k个节点右节点的左节点为当前点
    r[k] = idx;     // 第k个点的右节点为当前点
    ++idx;
}

// 删除第k个点
inline void remove(int k)
{
    r[l[k]] = r[k];
    l[r[k]] = l[k];
    // 其实到此为止，k的左右节点的左右节点各自修改了，但是k的左右节点没有修改。
    // 没必要修改，因为第k个点已经从head和tail中间脱离开了。它现在是一个离散的点。
}

int main()
{
    cin.tie(nullptr)->sync_with_stdio(false);
    
    r[0] = 1, l[1] = 0;
    idx = 2;
    
    int m;
    cin >> m;
    for (; m--;) {
        string op;
        cin >> op;
        int k, x;
        
        if (op == "L") {
            cin >> x;
            add(0, x);
        }
        else if (op == "R") {
            cin >> x;
            add(l[1], x);
        }
        else if (op == "D") {
            cin >> k;
            remove(k + 1);
        }
        else if (op == "IL") {
            cin >> k >> x;
            add(l[k + 1], x);
        }
        else {
            cin >> k >> x;
            add(k + 1, x);
        }
    }
    for (int iter = r[0]; iter != 1; iter = r[iter]) {
        cout << e[iter] << " ";
    }
    cout << endl;
    return 0;
}
```
<!-- endtab -->
{% endtabs %}

数组模拟链表使用第 `idx` 次插入唯一确定一个节点。所有的操作都基于 `idx`。`idx` 从 `0` 开始，是数组下标。
注意题目的第 `k` 次操作是从 `1` 开始，而我们实现的 `remove` 和 `add` 方法的 `k` 都是对应的数组下标，他们不完全一样。所以所有涉及到 `k` 的操作都要加一。
链表的初始化默认 `0` 为头结点值，`1` 为尾结点值。第 `0` 次操作指定头结点的右指针指向尾结点 `1`，第 `1` 次操作指定尾结点的左指针指向头结点 `0`。接下来的所有操作均在头尾节点之间进行。
注意双链表的遍历从数组第 `0` 个数开始不断访问第 `i` 个节点的右指针，直到访问到尾结点的右指针指向 `1` 为止。


{% note primary%}
__原题链接：__ [ACWing 827. 双链表](https://www.acwing.com/problem/content/829/)
{% endnote%}