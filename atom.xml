<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Dirac Sea</title>
  
  <subtitle>where the water tastes like wine</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://accepted.org.cn/"/>
  <updated>2021-08-10T11:19:09.842Z</updated>
  <id>https://accepted.org.cn/</id>
  
  <author>
    <name>etoa</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>经验：把hexo博客环境从Windows迁移到Mac</title>
    <link href="https://accepted.org.cn/2021/08/10/%E7%BB%8F%E9%AA%8C%EF%BC%9A%E6%8A%8Ahexo%E5%8D%9A%E5%AE%A2%E7%8E%AF%E5%A2%83%E4%BB%8EWindows%E8%BF%81%E7%A7%BB%E5%88%B0Mac/"/>
    <id>https://accepted.org.cn/2021/08/10/%E7%BB%8F%E9%AA%8C%EF%BC%9A%E6%8A%8Ahexo%E5%8D%9A%E5%AE%A2%E7%8E%AF%E5%A2%83%E4%BB%8EWindows%E8%BF%81%E7%A7%BB%E5%88%B0Mac/</id>
    <published>2021-08-10T11:10:05.000Z</published>
    <updated>2021-08-10T11:19:09.842Z</updated>
    
    <content type="html"><![CDATA[<p><strong>摘要：</strong><br>记录一下自己把hexo博客环境从Windows迁移到Mac的过程。</p><a id="more"></a><h3 id="Implements"><a href="#Implements" class="headerlink" title="Implements"></a>Implements</h3><ol><li>第一步，准备一碟花生米。</li><li>在Windows环境中，压缩hexo文件夹，拷贝到Mac电脑中。</li><li>此外</li></ol><div class="note primary">            <p><strong>原题链接：</strong> <a href=""></a></p>          </div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;摘要：&lt;/strong&gt;&lt;br&gt;记录一下自己把hexo博客环境从Windows迁移到Mac的过程。&lt;/p&gt;
    
    </summary>
    
    
      <category term="不亦乐乎" scheme="https://accepted.org.cn/categories/%E4%B8%8D%E4%BA%A6%E4%B9%90%E4%B9%8E/"/>
    
      <category term="博客" scheme="https://accepted.org.cn/categories/%E4%B8%8D%E4%BA%A6%E4%B9%90%E4%B9%8E/%E5%8D%9A%E5%AE%A2/"/>
    
    
      <category term="博客" scheme="https://accepted.org.cn/tags/%E5%8D%9A%E5%AE%A2/"/>
    
      <category term="Hexo" scheme="https://accepted.org.cn/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 611. 有效三角形的个数</title>
    <link href="https://accepted.org.cn/2021/08/04/LeetCode-611-%E6%9C%89%E6%95%88%E4%B8%89%E8%A7%92%E5%BD%A2%E7%9A%84%E4%B8%AA%E6%95%B0/"/>
    <id>https://accepted.org.cn/2021/08/04/LeetCode-611-%E6%9C%89%E6%95%88%E4%B8%89%E8%A7%92%E5%BD%A2%E7%9A%84%E4%B8%AA%E6%95%B0/</id>
    <published>2021-08-04T14:32:11.000Z</published>
    <updated>2021-08-04T14:45:28.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>摘要：</strong><br>一道双指针题目。</p><a id="more"></a><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给定一个包含非负整数的数组，你的任务是统计其中可以组成三角形三条边的三元组个数。</p><p><strong>示例 1:</strong></p><blockquote><p>输入: [2,2,3,4]<br>输出: 3<br>解释:<br>有效的组合是:<br>2,3,4 (使用第一个 2)<br>2,3,4 (使用第二个 2)<br>2,2,3</p></blockquote><p><strong>注意:</strong></p><ol><li>数组长度不超过 $1000$。</li><li>数组里整数的范围为 $[0, 1000]$。</li></ol><h3 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h3><p>构成三角形的条件是：三条边中，任意两条边之和大于第三条边。<br>我们可以将原数组排序，依次枚举最长边、次长边和最短边。其中，最长边从小到大枚举即可，次长边和最短边用两个指针维护。两个指针分别初始化为最长边左边第一个数下标和0. 次长边指针从右向左枚举，对于每一个次长边，将最短边指针从左到右枚举，直到找到最小的满足条件的最短边。因为数组是递增的，从最小的满足条件的最短边到次长边都是满足条件的。这样可以实现优化。</p><div class="tabs" id="g_tab0"><ul class="nav-tabs"><li class="tab active"><a href="#g_tab0-1">C++</a></li><li class="tab"><a href="#g_tab0-2">Java</a></li></ul><div class="tab-content"><div class="tab-pane active" id="g_tab0-1"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">triangleNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        sort(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;       <span class="comment">// 枚举最大数</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i - <span class="number">1</span>, k = <span class="number">0</span>; j &gt; <span class="number">0</span> &amp;&amp; k &lt; j; --j) &#123;   <span class="comment">// 枚举次大数</span></span><br><span class="line">                <span class="keyword">for</span> (; k &lt; j &amp;&amp; nums[k] + nums[j] &lt;= nums[i]; ++k);</span><br><span class="line">                res += j - k;</span><br><span class="line">            &#125;   </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="g_tab0-2"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">triangleNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;   <span class="comment">// 枚举所有最长边   </span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i - <span class="number">1</span>, k = <span class="number">0</span>; k &lt; j &amp;&amp; j &gt; <span class="number">0</span>; --j) &#123;   <span class="comment">// 枚举所有次长边   </span></span><br><span class="line">                <span class="keyword">for</span> (; k &lt; j &amp;&amp; nums[k] + nums[j] &lt;= nums[i]; ++k); <span class="comment">// 排除所有不满足条件的最短边   </span></span><br><span class="line">                res += j - k;   <span class="comment">// 从 k 到 j - 1 这一段都是满足的</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div></div><p><strong>复杂度：</strong> 最坏情况下是 $n^2$，实际情况是每一个最长边，可能存在一段 $k$ 到 $j - 1$ 是满足条件的而不用遍历</p><div class="note primary">            <p><strong>原题链接：</strong> <a href="https://leetcode-cn.com/problems/valid-triangle-number/" target="_blank" rel="noopener">LeetCode 611. 有效三角形的个数</a></p>          </div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;摘要：&lt;/strong&gt;&lt;br&gt;一道双指针题目。&lt;/p&gt;
    
    </summary>
    
    
      <category term="指尖飞舞" scheme="https://accepted.org.cn/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/"/>
    
      <category term="算法" scheme="https://accepted.org.cn/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/%E7%AE%97%E6%B3%95/"/>
    
      <category term="LeetCode" scheme="https://accepted.org.cn/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/%E7%AE%97%E6%B3%95/LeetCode/"/>
    
    
      <category term="算法" scheme="https://accepted.org.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="LeetCode" scheme="https://accepted.org.cn/tags/LeetCode/"/>
    
      <category term="双指针" scheme="https://accepted.org.cn/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 14. 最长公共前缀</title>
    <link href="https://accepted.org.cn/2021/08/01/LeetCode-14-%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%89%8D%E7%BC%80/"/>
    <id>https://accepted.org.cn/2021/08/01/LeetCode-14-%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%89%8D%E7%BC%80/</id>
    <published>2021-08-01T13:56:54.000Z</published>
    <updated>2021-08-04T14:36:42.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>摘要：</strong><br>很简单的模拟题，如果换成公共子序列那就复杂了。 </p><a id="more"></a><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>编写一个函数来查找字符串数组中的最长公共前缀。</p><p>如果不存在公共前缀，返回空字符串 <code>&quot;&quot;</code>。</p><p><strong>示例 1：</strong></p><p>输入：strs = [“flower”,”flow”,”flight”]<br>输出：”fl”</p><p><strong>示例 2：</strong></p><p>输入：strs = [“dog”,”racecar”,”car”]<br>输出：””<br>解释：输入不存在公共前缀。</p><p><strong>提示：</strong></p><ul><li>$0 &lt;= strs.length &lt;= 200$</li><li>$0 &lt;= strs[i].length &lt;= 200$</li><li>$strs[i]$ 仅由小写英文字母组成</li></ul><h3 id="按列比较"><a href="#按列比较" class="headerlink" title="按列比较"></a>按列比较</h3><p>可以拿第一个字符串作为比较对象，维护一个单指针，当单指针超出第一个字符串的下标范围则可以认为第一个字符串就是所有字符串中最短的，且是公共前缀；<br>否则拿当前指针指向的第一个字符串的字符和所有字符串该位置的字符比较，一旦出现不匹配的情况那到此为指针前面的所有前缀串就是最长公共子串。</p><div class="tabs" id="g_tab0"><ul class="nav-tabs"><li class="tab active"><a href="#g_tab0-1">C++</a></li><li class="tab"><a href="#g_tab0-2">Java</a></li></ul><div class="tab-content"><div class="tab-pane active" id="g_tab0-1"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">longestCommonPrefix</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; ss)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = ss.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (!n) <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        <span class="built_in">string</span> res;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= ss[<span class="number">0</span>].<span class="built_in">size</span>()) &#123;</span><br><span class="line">                <span class="keyword">return</span> ss[<span class="number">0</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">char</span> c = ss[<span class="number">0</span>][i];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (ss[j][i] != c) &#123;</span><br><span class="line">                    <span class="keyword">return</span> res;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            res += c;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="g_tab0-2"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">longestCommonPrefix</span><span class="params">(String[] ss)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = ss.length;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        StringBuilder res = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= ss[<span class="number">0</span>].length()) <span class="keyword">return</span> ss[<span class="number">0</span>];    <span class="comment">// 第一个字符串在所有串中最短</span></span><br><span class="line">            <span class="keyword">char</span> c = ss[<span class="number">0</span>].charAt(i);</span><br><span class="line">            <span class="keyword">for</span> (String s : ss) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i &gt;= s.length() || s.charAt(i) != c) <span class="keyword">return</span> res.toString();</span><br><span class="line">            &#125;</span><br><span class="line">            res.append(c);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div></div><p>复杂度：最坏的情况下，需要将每一个字符枚举到，所以复杂度为所有字符的数量之和。</p><div class="note primary">            <p><strong>原题链接：</strong> <a href="https://leetcode-cn.com/problems/longest-common-prefix/" target="_blank" rel="noopener">LeetCode 14. 最长公共前缀</a></p>          </div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;摘要：&lt;/strong&gt;&lt;br&gt;很简单的模拟题，如果换成公共子序列那就复杂了。 &lt;/p&gt;
    
    </summary>
    
    
      <category term="指尖飞舞" scheme="https://accepted.org.cn/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/"/>
    
      <category term="算法" scheme="https://accepted.org.cn/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/%E7%AE%97%E6%B3%95/"/>
    
      <category term="LeetCode" scheme="https://accepted.org.cn/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/%E7%AE%97%E6%B3%95/LeetCode/"/>
    
    
      <category term="算法" scheme="https://accepted.org.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="LeetCode" scheme="https://accepted.org.cn/tags/LeetCode/"/>
    
      <category term="字符串" scheme="https://accepted.org.cn/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 274. H指数</title>
    <link href="https://accepted.org.cn/2021/07/11/LeetCode-274-H%E6%8C%87%E6%95%B0/"/>
    <id>https://accepted.org.cn/2021/07/11/LeetCode-274-H%E6%8C%87%E6%95%B0/</id>
    <published>2021-07-11T05:13:26.000Z</published>
    <updated>2021-07-11T05:38:54.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>摘要：</strong><br>题目有点绕，好在一遍A。</p><a id="more"></a><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给定一位研究者论文被引用次数的数组（被引用次数是非负整数）。编写一个方法，计算出研究者的 $h$ 指数。</p><p><strong>h 指数的定义：</strong> $h$ 代表“高引用次数”（high citations），一名科研人员的 $h$ 指数是指他（她）的 （N 篇论文中）<strong>总共</strong> 有 $h$ 篇论文分别被引用了<strong>至少</strong> $h$ 次。且其余的 $N - h$ 篇论文每篇被引用次数 <strong>不超过</strong> $h$ 次。</p><p>例如：某人的 $h$ 指数是 $20$，这表示他已发表的论文中，每篇被引用了至少 $20$ 次的论文总共有 $20$ 篇。</p><p><strong>示例：</strong></p><blockquote><p>输入：citations = [3,0,6,1,5]<br>输出：3<br>解释：给定数组表示研究者总共有 5 篇论文，每篇论文相应的被引用了 3, 0, 6, 1, 5 次。</p><p>由于研究者有 3 篇论文每篇 至少 被引用了 3 次，其余两篇论文每篇被引用 不多于 3 次，所以她的 h 指数是 3。</p></blockquote><p>提示：如果 $h$ 有多种可能的值，$h$ 指数是其中最大的那个。</p><h3 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h3><p>题目可以抽象成，在所有的论文当中有 $h$ 篇，其中每篇被引用至少 $h$ 次。</p><p>那么我们就开一个计数数组，对于数组第 $i$ 项，记录引用次数为 $i$ 的论文有多少篇。<br>比如对于示例1，计数数组为：<br>0-1<br>1-1<br>2-0<br>3-1<br>4-0<br>5-1<br>6-1<br>从数组末尾开始遍历，当引用次数对应的篇数不为零时，对应着有效的一项。<br>对于每一个有效项，累加总篇数，和当前下标（即引用次数）比较取最小值 $min$ 就表示当前有 $min$ 篇每篇引用至少 $min$ 次。也就是说每一项都会产生一个新的 $h$ 值，比较所有 $h$ 值取最大者即可。</p><p>Q: 为什么要从计数数组末尾开始遍历？<br>A: 只有从末尾开始遍历，对于每个计数数组中的有效项，累加的篇数和对应下标的引用次数取最小才可以表示成：<br>在当前累加篇数的论文中，每篇引用 <strong>至少</strong> 对应下标次数。从数组开头开始遍历没法表示 <strong>至少</strong>。</p><div class="tabs" id="g_tab0"><ul class="nav-tabs"><li class="tab active"><a href="#g_tab0-1">C++</a></li></ul><div class="tab-content"><div class="tab-pane active" id="g_tab0-1"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">hIndex</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; ci)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> mx = *max_element(ci.<span class="built_in">begin</span>(), ci.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">int</span> n = ci.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">cnt</span><span class="params">(mx + <span class="number">10</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            cnt[ci[i]]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//for (int i = 0; i &lt; mx + 10; ++i) cout &lt;&lt; i &lt;&lt; "-"  &lt;&lt; cnt[i] &lt;&lt; endl;</span></span><br><span class="line">        <span class="comment">//return 0;</span></span><br><span class="line">        <span class="keyword">int</span> paper_cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = mx + <span class="number">9</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cnt[i]) &#123;</span><br><span class="line">                paper_cnt += cnt[i];</span><br><span class="line">                <span class="keyword">int</span> tmp = <span class="built_in">min</span>(paper_cnt, i);</span><br><span class="line">                res = <span class="built_in">max</span>(res, tmp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div></div></div><div class="note primary">            <p><strong>原题链接：</strong> <a href="https://leetcode-cn.com/problems/h-index/" target="_blank" rel="noopener">LeetCode 274. H指数</a></p>          </div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;摘要：&lt;/strong&gt;&lt;br&gt;题目有点绕，好在一遍A。&lt;/p&gt;
    
    </summary>
    
    
      <category term="指尖飞舞" scheme="https://accepted.org.cn/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/"/>
    
      <category term="算法" scheme="https://accepted.org.cn/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/%E7%AE%97%E6%B3%95/"/>
    
      <category term="LeetCode" scheme="https://accepted.org.cn/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/%E7%AE%97%E6%B3%95/LeetCode/"/>
    
    
      <category term="算法" scheme="https://accepted.org.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="LeetCode" scheme="https://accepted.org.cn/tags/LeetCode/"/>
    
      <category term="计数排序" scheme="https://accepted.org.cn/tags/%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 930. 和相同的二元子数组</title>
    <link href="https://accepted.org.cn/2021/07/08/LeetCode-930-%E5%92%8C%E7%9B%B8%E5%90%8C%E7%9A%84%E4%BA%8C%E5%85%83%E5%AD%90%E6%95%B0%E7%BB%84/"/>
    <id>https://accepted.org.cn/2021/07/08/LeetCode-930-%E5%92%8C%E7%9B%B8%E5%90%8C%E7%9A%84%E4%BA%8C%E5%85%83%E5%AD%90%E6%95%B0%E7%BB%84/</id>
    <published>2021-07-08T03:12:48.000Z</published>
    <updated>2021-07-08T04:42:02.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>摘要：</strong><br>前缀和+TwoSum.</p><a id="more"></a><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给你一个二元数组 $nums$ ，和一个整数 $goal$ ，请你统计并返回有多少个和为 $goal$ 的 <strong>非空</strong> 子数组。</p><p><strong>子数组</strong> 是数组的一段连续部分。</p><p><strong>示例 1：</strong></p><blockquote><p>输入：nums = [1,0,1,0,1], goal = 2<br>输出：4<br>解释：<br>如下面黑体所示，有 4 个满足题目要求的子数组：<br>[<strong>1,0,1</strong> ,0,1]<br>[<strong>1,0,1,0</strong> ,1]<br>[1, <strong>0,1,0,1</strong>]<br>[1,0, <strong>1,0,1</strong>]</p></blockquote><p><strong>示例 2：</strong></p><blockquote><p>输入：nums = [0,0,0,0,0], goal = 0<br>输出：15</p></blockquote><p><strong>提示：</strong></p><ul><li>$1 &lt;= nums.length &lt;= 3 * 10^4$</li><li>$nums[i]$ 不是 $0$ 就是 $1$</li><li>$0 &lt;= goal &lt;= nums.length$</li></ul><hr><h3 id="前缀和"><a href="#前缀和" class="headerlink" title="前缀和"></a>前缀和</h3><p>因为要求出所有和为特定值的子数组个数，子数组是连续的，所以必然联想到前缀和。</p><p>如果预处理出前缀和数组，再暴力枚举所有子数组，复杂度为 $O(N^2)$，还是会超时。</p><p>考虑到以下标为 $i$ 的数开始，以下标为 $j$ 的数结尾的子数组的和为 $presum[j] - presum[i - 1]$，如果这个数和 $goal$ 相等，那么 $[i, j]$ 的子数组就是满足要求的。</p><p>问题就等价于求出原数组中对于每个下标 $j$，有多少小于等于 $j$ 的下标 $i$，满足:</p><p>$presum[i - 1] + goal = presum[j]$.</p><p>显然这是一个TwoSum问题。<br>我们可以维护一个哈希表，存放所有 $prsum[j]$ 的数量。在之后的遍历中，如果出现当前下标的前缀和减去 $goal$ 已经存在，那么 $j$ 一定和当前下标构成一个满足条件的子数组。</p><div class="tabs" id="g_tab0"><ul class="nav-tabs"><li class="tab active"><a href="#g_tab0-1">C++</a></li></ul><div class="tab-content"><div class="tab-pane active" id="g_tab0-1"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numSubarraysWithSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> goal)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">presum</span><span class="params">(n + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) presum[i] = presum[i - <span class="number">1</span>] + nums[i - <span class="number">1</span>];</span><br><span class="line">        <span class="comment">//for (int i = 0; i &lt; n + 1; i++) cout &lt;&lt; presum[i] &lt;&lt; ' ';</span></span><br><span class="line">        <span class="comment">//cout &lt;&lt; endl;</span></span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; hash;</span><br><span class="line">        hash[<span class="number">0</span>]++;  <span class="comment">// 第0项左边的虚拟的和为0，和第零项对应，如果第零项恰好等于goal，那么正好和第零项左边的和匹配</span></span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            res += hash[presum[i] - goal];</span><br><span class="line">            hash[presum[i]]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div></div></div><p>注意每遍历到一个下标，都是先判断当前前缀和减去 $goal$ 是否已存在吗，如果存在就加上存在的数量。那么思考一下数组第 $1$ 个数的情况。</p><p>判断数组第 $1$ 个数对应前缀和减去 $goal$ 是否已存在，它对应的是未出现任何元素之前所有“元素”的和，显然 $0$ 的数量为 $1$，所以 $hash[0]$ 初始化为 $1$.</p><p>这道题和 <a href="https://eetoa.github.io/2021/07/03/【LeetCode周赛247】C-LeetCode-1915-最美子字符串的数目/" target="_blank" rel="noopener">【LeetCode周赛247】C LeetCode 1915. 最美子字符串的数目</a> 非常类似。</p><div class="note primary">            <p><strong>原题链接：</strong> <a href="https://leetcode-cn.com/problems/binary-subarrays-with-sum/" target="_blank" rel="noopener">LeetCode 930. 和相同的二元子数组</a></p>          </div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;摘要：&lt;/strong&gt;&lt;br&gt;前缀和+TwoSum.&lt;/p&gt;
    
    </summary>
    
    
      <category term="指尖飞舞" scheme="https://accepted.org.cn/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/"/>
    
      <category term="算法" scheme="https://accepted.org.cn/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/%E7%AE%97%E6%B3%95/"/>
    
      <category term="LeetCode" scheme="https://accepted.org.cn/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/%E7%AE%97%E6%B3%95/LeetCode/"/>
    
    
      <category term="算法" scheme="https://accepted.org.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="LeetCode" scheme="https://accepted.org.cn/tags/LeetCode/"/>
    
      <category term="哈希表" scheme="https://accepted.org.cn/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    
      <category term="前缀和" scheme="https://accepted.org.cn/tags/%E5%89%8D%E7%BC%80%E5%92%8C/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 1711. 大餐计数</title>
    <link href="https://accepted.org.cn/2021/07/07/LeetCode-1711-%E5%A4%A7%E9%A4%90%E8%AE%A1%E6%95%B0/"/>
    <id>https://accepted.org.cn/2021/07/07/LeetCode-1711-%E5%A4%A7%E9%A4%90%E8%AE%A1%E6%95%B0/</id>
    <published>2021-07-07T04:55:26.000Z</published>
    <updated>2021-07-07T05:15:40.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>摘要：</strong><br>TwoSum升级版。</p><a id="more"></a><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p><strong>大餐</strong> 是指 <strong>恰好包含两道不同餐品</strong> 的一餐，其美味程度之和等于 $2$ 的幂。</p><p>你可以搭配 <strong>任意</strong> 两道餐品做一顿大餐。</p><p>给你一个整数数组 $deliciousness$ ，其中 $deliciousness[i]$ 是第 $i$​​​​​​​​​​​​​​ 道餐品的美味程度，返回你可以用数组中的餐品做出的不同 <strong>大餐</strong> 的数量。结果需要对 $10^9 + 7$ 取余。</p><p>注意，只要餐品下标不同，就可以认为是不同的餐品，即便它们的美味程度相同。</p><p><strong>示例 1：</strong></p><blockquote><p>输入：deliciousness = [1,3,5,7,9]<br>输出：4<br>解释：大餐的美味程度组合为 (1,3) 、(1,7) 、(3,5) 和 (7,9) 。<br>它们各自的美味程度之和分别为 4 、8 、8 和 16 ，都是 2 的幂。</p></blockquote><p><strong>示例 2：</strong></p><blockquote><p>输入：deliciousness = [1,1,1,3,3,3,7]<br>输出：15<br>解释：大餐的美味程度组合为 3 种 (1,1) ，9 种 (1,3) ，和 3 种 (1,7) 。</p></blockquote><p><strong>提示：</strong></p><ul><li>$1 &lt;= deliciousness.length &lt;= 10^5$</li><li>$0 &lt;= deliciousness[i] &lt;= 2^{20}$</li></ul><hr><h3 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h3><p>对于数组中的每个元素，从 $2^0$ 到 $2^{21}$ 依次计算目标值，将目标值放入哈希表计数加一。<br>那么，对于每一个元素需要先从哈希表里面找自己是不是之前某数的目标值，如果是，则结果加上目标值的计数。<br>值得注意的是，$0 &lt;= deliciousness[i] &lt;= 2^{20}$，所以当数组存在多个最大范围的值时，目标值最高可取到  $2^20 + 2^{20}$ 也就是 $2^{21}$.</p><p>我们可以先求出原数组中的最大值，那么对于每个数循环 $[2^0,2^{21}]$ 时，目标值可能的范围在 $0 &lt;= deliciousness[i] &lt;= 2^{20}$，超出可以不考虑，因为数组元素在这个范围，不可能遇到超出范围的。</p><div class="tabs" id="g_tab0"><ul class="nav-tabs"><li class="tab active"><a href="#g_tab0-1">C++</a></li><li class="tab"><a href="#g_tab0-2">C++</a></li></ul><div class="tab-content"><div class="tab-pane active" id="g_tab0-1"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 2021-7-7 13:15:21</span></span><br><span class="line"><span class="comment"> * author: etoa</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">auto</span> <span class="built_in">shutdown</span> = []()&#123;</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>)-&gt;sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;();</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">int</span> MOD = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="title">ksm</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> res = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (; b; a = a * a, b &gt;&gt;= <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (b &amp; <span class="number">1</span>) res = res * a;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countPairs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; d)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = d.<span class="built_in">size</span>();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt; target;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">21</span>; i++) &#123;</span><br><span class="line">            target.push_back(ksm(<span class="number">2</span>, i));</span><br><span class="line">        &#125;   </span><br><span class="line">        <span class="keyword">int</span> mx = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) </span><br><span class="line">            mx = <span class="built_in">max</span>(mx, d[i]);</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>, <span class="keyword">int</span>&gt; hash; <span class="comment">// expected - cnt</span></span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (hash.count(d[i])) &#123;</span><br><span class="line">                res += hash[d[i]];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//cout &lt;&lt; d[i] &lt;&lt; "---" &lt;&lt; endl;</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= <span class="number">21</span>; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (target[j] - d[i] &gt; mx) <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">if</span> (target[j] - d[i] &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    hash[target[j] - d[i]]++;</span><br><span class="line">                    <span class="comment">//cout &lt;&lt; target[j] - d[i] &lt;&lt; '-' &lt;&lt; hash[target[j] - d[i]] &lt;&lt; endl;</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">return</span> res % MOD;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="g_tab0-2"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 优化：快速幂可以用位运算代替；</span></span><br><span class="line"><span class="comment"> * 求数组最值可以使用max_element;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">auto</span> <span class="built_in">shutdown</span> = []()&#123;</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>)-&gt;sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;();</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">int</span> MOD = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countPairs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; d)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = d.<span class="built_in">size</span>();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt; target;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">21</span>; i++) &#123;</span><br><span class="line">            target.push_back(<span class="number">1</span> &lt;&lt; i);</span><br><span class="line">        &#125;   </span><br><span class="line">        <span class="keyword">int</span> mx = *max_element(d.<span class="built_in">begin</span>(), d.<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>, <span class="keyword">int</span>&gt; hash; <span class="comment">// expected - cnt</span></span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (hash.count(d[i])) &#123;</span><br><span class="line">                res += hash[d[i]];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//cout &lt;&lt; d[i] &lt;&lt; "---" &lt;&lt; endl;</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= <span class="number">21</span>; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (target[j] - d[i] &gt; mx) <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">if</span> (target[j] - d[i] &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    hash[target[j] - d[i]]++;</span><br><span class="line">                    <span class="comment">//cout &lt;&lt; target[j] - d[i] &lt;&lt; '-' &lt;&lt; hash[target[j] - d[i]] &lt;&lt; endl;</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">return</span> res % MOD;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div></div></div><div class="note primary">            <p><strong>原题链接：</strong> <a href="https://leetcode-cn.com/problems/count-good-meals/" target="_blank" rel="noopener">LeetCode 1711. 大餐计数</a></p>          </div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;摘要：&lt;/strong&gt;&lt;br&gt;TwoSum升级版。&lt;/p&gt;
    
    </summary>
    
    
      <category term="指尖飞舞" scheme="https://accepted.org.cn/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/"/>
    
      <category term="算法" scheme="https://accepted.org.cn/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/%E7%AE%97%E6%B3%95/"/>
    
      <category term="LeetCode" scheme="https://accepted.org.cn/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/%E7%AE%97%E6%B3%95/LeetCode/"/>
    
    
      <category term="算法" scheme="https://accepted.org.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="LeetCode" scheme="https://accepted.org.cn/tags/LeetCode/"/>
    
      <category term="哈希表" scheme="https://accepted.org.cn/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 1418. 点菜展示表</title>
    <link href="https://accepted.org.cn/2021/07/06/LeetCode-1418-%E7%82%B9%E8%8F%9C%E5%B1%95%E7%A4%BA%E8%A1%A8/"/>
    <id>https://accepted.org.cn/2021/07/06/LeetCode-1418-%E7%82%B9%E8%8F%9C%E5%B1%95%E7%A4%BA%E8%A1%A8/</id>
    <published>2021-07-06T05:54:21.000Z</published>
    <updated>2021-07-07T05:18:28.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>摘要：</strong><br>使用有序集合和有序map简化代码。</p><a id="more"></a><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给你一个数组 $orders$，表示客户在餐厅中完成的订单。</p><p>确切地说， $orders[i]=[customerNamei,tableNumberi,foodItemi]$ ，其中 $customerNamei$ 是客户的姓名，$tableNumberi$ 是客户所在餐桌的桌号，而 $foodItemi$ 是客户点的餐品名称。</p><p>请你返回该餐厅的 <strong>点菜展示表</strong> 。在这张表中，表中第一行为标题，其第一列为餐桌桌号 “Table” ，后面每一列都是按字母顺序排列的餐品名称。接下来每一行中的项则表示每张餐桌订购的相应餐品数量，第一列应当填对应的桌号，后面依次填写下单的餐品数量。</p><p>注意：客户姓名不是点菜展示表的一部分。此外，表中的数据行应该按餐桌桌号升序排列。</p><p><strong>示例 1：</strong></p><blockquote><p>输入：orders = [[“David”,”3”,”Ceviche”],[“Corina”,”10”,”Beef Burrito”],[“David”,”3”,”Fried Chicken”],[“Carla”,”5”,”Water”],[“Carla”,”5”,”Ceviche”],[“Rous”,”3”,”Ceviche”]]<br>输出：[[“Table”,”Beef Burrito”,”Ceviche”,”Fried Chicken”,”Water”],[“3”,”0”,”2”,”1”,”0”],[“5”,”0”,”1”,”0”,”1”],[“10”,”1”,”0”,”0”,”0”]]<br>解释：<br>点菜展示表如下所示：</p><table><thead><tr><th align="left">Table</th><th align="left">Beef Burrito</th><th align="left">Ceviche</th><th align="left">Fried Chicken</th><th align="left">Water</th></tr></thead><tbody><tr><td align="left">3</td><td align="left">0</td><td align="left">2</td><td align="left">1</td><td align="left">0</td></tr><tr><td align="left">5</td><td align="left">0</td><td align="left">1</td><td align="left">0</td><td align="left">1</td></tr><tr><td align="left">10</td><td align="left">1</td><td align="left">0</td><td align="left">0</td><td align="left">0</td></tr></tbody></table><p>对于餐桌 3：David 点了 “Ceviche” 和 “Fried Chicken”，而 Rous 点了 “Ceviche”<br>而餐桌 5：Carla 点了 “Water” 和 “Ceviche”<br>餐桌 10：Corina 点了 “Beef Burrito” </p></blockquote><p><strong>示例 2：</strong></p><blockquote><p>输入：orders = [[“James”,”12”,”Fried Chicken”],[“Ratesh”,”12”,”Fried Chicken”],[“Amadeus”,”12”,”Fried Chicken”],[“Adam”,”1”,”Canadian Waffles”],[“Brianna”,”1”,”Canadian Waffles”]]<br>输出：[[“Table”,”Canadian Waffles”,”Fried Chicken”],[“1”,”2”,”0”],[“12”,”0”,”3”]]<br>解释：<br>对于餐桌 1：Adam 和 Brianna 都点了 “Canadian Waffles”<br>而餐桌 12：James, Ratesh 和 Amadeus 都点了 “Fried Chicken”</p></blockquote><p><strong>示例 3：</strong></p><blockquote><p>输入：orders = [[“Laura”,”2”,”Bean Burrito”],[“Jhon”,”2”,”Beef Burrito”],[“Melissa”,”2”,”Soda”]]<br>输出：[[“Table”,”Bean Burrito”,”Beef Burrito”,”Soda”],[“2”,”1”,”1”,”1”]]</p></blockquote><p><strong>提示：</strong></p><ul><li>$1 &lt;= orders.length &lt;= 5 \times 10^4$</li><li>$orders[i].length = 3$</li><li>$1 &lt;= customerNamei.length, foodItemi.length &lt;= 20$</li><li>$customerNamei$ 和 $foodItemi$ 由大小写英文字母及空格字符 <code>&#39; &#39;</code> 组成。</li><li>$tableNumberi$ 是 $1$ 到 $500$ 范围内的整数。</li></ul><hr><h3 id="模拟"><a href="#模拟" class="headerlink" title="模拟"></a>模拟</h3><p>构建一个桌号数组，数组中放入有序哈希表。遍历 $orders$ 数组，将桌号对应的菜品放入到对应的哈希表中。</p><div class="tabs" id="g_tab0"><ul class="nav-tabs"><li class="tab active"><a href="#g_tab0-1">C++</a></li></ul><div class="tab-content"><div class="tab-pane active" id="g_tab0-1"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 2021-7-6 14:11:00</span></span><br><span class="line"><span class="comment"> * author: etoa</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">int</span> N = <span class="number">507</span>;</span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; table[N];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; <span class="title">displayTable</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt;&amp; orders)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">set</span>&lt;<span class="built_in">string</span>&gt; fooditem;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;e : orders) &#123;</span><br><span class="line">            fooditem.insert(e[<span class="number">2</span>]);</span><br><span class="line">            table[stoi(e[<span class="number">1</span>])][e[<span class="number">2</span>]]++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; res;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; intro;</span><br><span class="line">        intro.push_back(<span class="string">"Table"</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;e : fooditem) intro.push_back(e);</span><br><span class="line">        res.push_back(intro);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!table[i].empty()) &#123;</span><br><span class="line">                <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; each_table;</span><br><span class="line">                each_table.push_back(to_string(i));</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;e : fooditem) &#123;</span><br><span class="line">                    each_table.push_back(to_string(table[i][e]));</span><br><span class="line">                &#125;</span><br><span class="line">                res.push_back(each_table);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div></div></div><div class="note primary">            <p><strong>原题链接：</strong> <a href="https://leetcode-cn.com/problems/display-table-of-food-orders-in-a-restaurant/" target="_blank" rel="noopener">LeetCode 1418. 点菜展示表</a></p>          </div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;摘要：&lt;/strong&gt;&lt;br&gt;使用有序集合和有序map简化代码。&lt;/p&gt;
    
    </summary>
    
    
      <category term="指尖飞舞" scheme="https://accepted.org.cn/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/"/>
    
      <category term="算法" scheme="https://accepted.org.cn/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/%E7%AE%97%E6%B3%95/"/>
    
      <category term="LeetCode" scheme="https://accepted.org.cn/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/%E7%AE%97%E6%B3%95/LeetCode/"/>
    
    
      <category term="算法" scheme="https://accepted.org.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="LeetCode" scheme="https://accepted.org.cn/tags/LeetCode/"/>
    
      <category term="哈希表" scheme="https://accepted.org.cn/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    
      <category term="集合" scheme="https://accepted.org.cn/tags/%E9%9B%86%E5%90%88/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 726. 原子的数量</title>
    <link href="https://accepted.org.cn/2021/07/06/LeetCode-726-%E5%8E%9F%E5%AD%90%E7%9A%84%E6%95%B0%E9%87%8F/"/>
    <id>https://accepted.org.cn/2021/07/06/LeetCode-726-%E5%8E%9F%E5%AD%90%E7%9A%84%E6%95%B0%E9%87%8F/</id>
    <published>2021-07-05T16:34:58.000Z</published>
    <updated>2021-07-05T16:44:56.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>摘要：</strong><br>很容易想到使用DFS解决问题。</p><a id="more"></a><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给定一个化学式 $formula$（作为字符串），返回每种原子的数量。</p><p>原子总是以一个大写字母开始，接着跟随 $0$ 个或任意个小写字母，表示原子的名字。</p><p>如果数量大于 $1$，原子后会跟着数字表示原子的数量。如果数量等于 $1$ 则不会跟数字。例如，$H2O$ 和 $H2O2$ 是可行的，但 $H1O2$ 这个表达是不可行的。</p><p>两个化学式连在一起是新的化学式。例如 $H2O2He3Mg4$ 也是化学式。</p><p>一个括号中的化学式和数字（可选择性添加）也是化学式。例如 $(H2O2)$ 和 $(H2O2)3$ 是化学式。</p><p>给定一个化学式 $formula$ ，返回所有原子的数量。格式为：第一个（按字典序）原子的名字，跟着它的数量（如果数量大于 $1$），然后是第二个原子的名字（按字典序），跟着它的数量（如果数量大于 $1$），以此类推。</p><p><strong>示例 1：</strong></p><blockquote><p>输入：formula = “H2O”<br>输出：”H2O”<br>解释：<br>原子的数量是 {‘H’: 2, ‘O’: 1}。</p></blockquote><p><strong>示例 2：</strong></p><blockquote><p>输入：formula = “Mg(OH)2”<br>输出：”H2MgO2”<br>解释：<br>原子的数量是 {‘H’: 2, ‘Mg’: 1, ‘O’: 2}。</p></blockquote><p><strong>示例 3：</strong></p><blockquote><p>输入：formula = “K4(ON(SO3)2)2”<br>输出：”K4N2O14S4”<br>解释：<br>原子的数量是 {‘K’: 4, ‘N’: 2, ‘O’: 14, ‘S’: 4}。</p></blockquote><p><strong>示例 4：</strong></p><blockquote><p>输入：formula = “Be32”<br>输出：”Be32”</p></blockquote><p><strong>提示：</strong></p><ul><li>$1 &lt;= formula.length &lt;= 1000$</li><li>$formula$ 由小写英文字母、数字 <code>(</code> 和 <code>)</code> 组成。</li><li>$formula$ 是有效的化学式。</li></ul><hr><h3 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h3><p>本题会遇到嵌套的括号，可以使用递归解决问题。<br>每遇到左括号就进入递归，并计算括号内的原子数量，保存在 <code>map</code> 中。<br>遇到右括号递归终止，返回。<br>回溯阶段判断右括号外的倍数问题，将返回的 <code>map</code> 中原子数目全部乘倍数。<br>因为题目要求使用字典序输出内容，故不使用 <code>unordered_map</code> 而使用 <code>map</code>.</p><div class="tabs" id="g_tab0"><ul class="nav-tabs"><li class="tab active"><a href="#g_tab0-1">C++</a></li><li class="tab"><a href="#g_tab0-2">C++</a></li></ul><div class="tab-content"><div class="tab-pane active" id="g_tab0-1"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 2021-7-6 00:43:56</span></span><br><span class="line"><span class="comment"> * author: etoa</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">countOfAtoms</span><span class="params">(<span class="built_in">string</span> formula)</span> </span>&#123;</span><br><span class="line">        n = formula.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> u = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">auto</span> ordereded_map = dfs(formula, u);</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">string</span> res;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;[atom, cnt] : ordereded_map) &#123;</span><br><span class="line">            res += atom;</span><br><span class="line">            <span class="keyword">if</span> (cnt &gt; <span class="number">1</span>) res += to_string(cnt);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    map&lt;string, int&gt; dfs(string &amp;formula, int &amp;u) &#123;</span><br><span class="line">        <span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; tres;</span><br><span class="line">        <span class="keyword">for</span> (; u &lt; n;) &#123;</span><br><span class="line">            <span class="keyword">if</span> (formula[u] == <span class="string">'('</span>) &#123;</span><br><span class="line">                ++u;</span><br><span class="line">                <span class="keyword">auto</span> tmap = dfs(formula, u);</span><br><span class="line">                <span class="comment">// checks if current is digits</span></span><br><span class="line">                <span class="keyword">int</span> mul = <span class="number">0</span>, k = u;</span><br><span class="line">                <span class="keyword">for</span> (; k &lt; n &amp;&amp; <span class="built_in">isdigit</span>(formula[k]); ++k) &#123;</span><br><span class="line">                    mul = mul * <span class="number">10</span> + formula[k] - <span class="string">'0'</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (!mul) ++mul;</span><br><span class="line">                u = k;</span><br><span class="line">                <span class="comment">// merge</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;[atom, cnt] : tmap) &#123;</span><br><span class="line">                    tres[atom] += cnt * mul;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (formula[u] == <span class="string">')'</span>) &#123;    <span class="comment">// endof dfs</span></span><br><span class="line">                ++u;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123; </span><br><span class="line">                <span class="keyword">int</span> k = u + <span class="number">1</span>;  <span class="comment">// 从字母的下一位开始</span></span><br><span class="line">                <span class="built_in">string</span> atom;</span><br><span class="line">                <span class="keyword">for</span> (; k &lt; n &amp;&amp; <span class="built_in">islower</span>(formula[k]); ++k);</span><br><span class="line">                <span class="keyword">int</span> atomlen = k - u;</span><br><span class="line">                atom = formula.substr(u, atomlen);</span><br><span class="line">                <span class="comment">//cout &lt;&lt; atom &lt;&lt; endl;</span></span><br><span class="line">                </span><br><span class="line">                <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span> (; k &lt; n &amp;&amp; <span class="built_in">isdigit</span>(formula[k]); k++) &#123;</span><br><span class="line">                    cnt = cnt * <span class="number">10</span> + formula[k] - <span class="string">'0'</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (!cnt) ++cnt;</span><br><span class="line">                <span class="comment">//cout &lt;&lt; cnt &lt;&lt; endl;</span></span><br><span class="line">                tres[atom] += cnt;</span><br><span class="line">                u = k;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> tres;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="g_tab0-2"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * author: yxc@acwing</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; MPSI;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">MPSI <span class="title">dfs</span><span class="params">(<span class="built_in">string</span>&amp; str, <span class="keyword">int</span>&amp; u)</span> </span>&#123;</span><br><span class="line">        MPSI res;</span><br><span class="line">        <span class="keyword">while</span> (u &lt; str.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (str[u] == <span class="string">'('</span>) &#123;</span><br><span class="line">                u ++ ;</span><br><span class="line">                <span class="keyword">auto</span> t = dfs(str, u);</span><br><span class="line">                u ++ ;</span><br><span class="line">                <span class="keyword">int</span> cnt = <span class="number">1</span>, k = u;</span><br><span class="line">                <span class="keyword">while</span> (k &lt; str.<span class="built_in">size</span>() &amp;&amp; <span class="built_in">isdigit</span>(str[k])) k ++ ;</span><br><span class="line">                <span class="keyword">if</span> (k &gt; u) &#123;</span><br><span class="line">                    cnt = stoi(str.substr(u, k - u));</span><br><span class="line">                    u = k;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; [x, y]: t) res[x] += y * cnt;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (str[u] == <span class="string">')'</span>) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> k = u + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">while</span> (k &lt; str.<span class="built_in">size</span>() &amp;&amp; str[k] &gt;= <span class="string">'a'</span> &amp;&amp; str[k] &lt;= <span class="string">'z'</span>) k ++ ;</span><br><span class="line">                <span class="keyword">auto</span> key = str.substr(u, k - u);</span><br><span class="line">                u = k;</span><br><span class="line">                <span class="keyword">int</span> cnt = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">while</span> (k &lt; str.<span class="built_in">size</span>() &amp;&amp; <span class="built_in">isdigit</span>(str[k])) k ++ ;</span><br><span class="line">                <span class="keyword">if</span> (k &gt; u) &#123;</span><br><span class="line">                    cnt = stoi(str.substr(u, k - u));</span><br><span class="line">                    u = k;</span><br><span class="line">                &#125;</span><br><span class="line">                res[key] += cnt;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">countOfAtoms</span><span class="params">(<span class="built_in">string</span> formula)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">auto</span> t = dfs(formula, k);</span><br><span class="line">        <span class="built_in">string</span> res;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; [x, y]: t) &#123;</span><br><span class="line">            res += x;</span><br><span class="line">            <span class="keyword">if</span> (y &gt; <span class="number">1</span>) res += to_string(y);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div></div></div><div class="note primary">            <p><strong>原题链接：</strong> <a href="https://leetcode-cn.com/problems/number-of-atoms/" target="_blank" rel="noopener">LeetCode 726. 原子的数量</a></p>          </div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;摘要：&lt;/strong&gt;&lt;br&gt;很容易想到使用DFS解决问题。&lt;/p&gt;
    
    </summary>
    
    
      <category term="指尖飞舞" scheme="https://accepted.org.cn/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/"/>
    
      <category term="算法" scheme="https://accepted.org.cn/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/%E7%AE%97%E6%B3%95/"/>
    
      <category term="LeetCode" scheme="https://accepted.org.cn/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/%E7%AE%97%E6%B3%95/LeetCode/"/>
    
    
      <category term="算法" scheme="https://accepted.org.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="LeetCode" scheme="https://accepted.org.cn/tags/LeetCode/"/>
    
      <category term="DFS" scheme="https://accepted.org.cn/tags/DFS/"/>
    
      <category term="字符串" scheme="https://accepted.org.cn/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
      <category term="回溯" scheme="https://accepted.org.cn/tags/%E5%9B%9E%E6%BA%AF/"/>
    
  </entry>
  
  <entry>
    <title>【LeetCode周赛248】C LeetCode 5802. 统计好数字的数目</title>
    <link href="https://accepted.org.cn/2021/07/05/%E3%80%90LeetCode%E5%91%A8%E8%B5%9B248%E3%80%91C-LeetCode-5802-%E7%BB%9F%E8%AE%A1%E5%A5%BD%E6%95%B0%E5%AD%97%E7%9A%84%E6%95%B0%E7%9B%AE/"/>
    <id>https://accepted.org.cn/2021/07/05/%E3%80%90LeetCode%E5%91%A8%E8%B5%9B248%E3%80%91C-LeetCode-5802-%E7%BB%9F%E8%AE%A1%E5%A5%BD%E6%95%B0%E5%AD%97%E7%9A%84%E6%95%B0%E7%9B%AE/</id>
    <published>2021-07-04T17:14:16.000Z</published>
    <updated>2021-07-05T03:45:28.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>摘要：</strong><br>经典模意义下快速幂应用。</p><a id="more"></a><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>我们称一个数字字符串是 <strong>好数字</strong> 当它满足（下标从 $0$ 开始）<strong>偶数</strong> 下标处的数字为 <strong>偶数</strong> 且 <strong>奇数</strong> 下标处的数字为 <strong>质数</strong> （$2$，$3$，$5$ 或 $7$）。</p><ul><li>比方说，$2582$ 是好数字，因为偶数下标处的数字（$2$ 和 $8$）是偶数且奇数下标处的数字（$5$ 和 $2$）为质数。但 $3245$ <strong>不是</strong> 好数字，因为 $3$ 在偶数下标处但不是偶数。</li></ul><p>给你一个整数 $n$ ，请你返回长度为 $n$ 且为好数字的数字字符串 <strong>总数</strong> 。由于答案可能会很大，请你将它对 $10^9 + 7$ <strong>取余后返回</strong> 。</p><p>一个 <strong>数字字符串</strong> 是每一位都由 $0$ 到 $9$ 组成的字符串，且可能包含前导 $0$ 。</p><p><strong>示例 1：</strong></p><blockquote><p>输入：n = 1<br>输出：5<br>解释：长度为 1 的好数字包括 “0”，”2”，”4”，”6”，”8” 。</p></blockquote><p><strong>示例 2：</strong></p><blockquote><p>输入：n = 4<br>输出：400</p></blockquote><p><strong>示例 3：</strong></p><blockquote><p>输入：n = 50<br>输出：564908303</p></blockquote><p><strong>提示：</strong></p><ul><li>$1 &lt;= n &lt;= 10^{15}$</li></ul><hr><h3 id="快速幂"><a href="#快速幂" class="headerlink" title="快速幂"></a>快速幂</h3><p>对于长度为 $n$ 的数字，偶数位对应着 $0, 2, 4, 6, 8$ 共 $5$ 种选择；奇数位对应着 $2, 3, 5, 7$ 共 $4$ 种选择。</p><p>偶数位共有 $\lceil n / 2 \rceil$ 个，奇数位共有 $\lfloor n / 2 \rfloor$ 个。</p><p>那么答案应该是 $5^{\lceil n / 2 \rceil} \times 4^{\lfloor n / 2 \rfloor} \bmod (10^9 + 7)$.</p><p>使用模意义下的快速幂可以在 $O(log(\lceil n / 2 \rceil + \lfloor n / 2 \rfloor))$ 复杂度内算出。</p><div class="tabs" id="g_tab0"><ul class="nav-tabs"><li class="tab active"><a href="#g_tab0-1">C++</a></li></ul><div class="tab-content"><div class="tab-pane active" id="g_tab0-1"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> MOD = <span class="number">1'000'000'007</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> LL <span class="title">ksm</span><span class="params">(LL a, LL b, LL MOD)</span> </span>&#123;</span><br><span class="line">        LL res = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (b) &#123;</span><br><span class="line">            <span class="keyword">if</span> (b &amp; <span class="number">1</span>) res = res * a % MOD;</span><br><span class="line">            a = a * a % MOD;</span><br><span class="line">            b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countGoodNumbers</span><span class="params">(LL n)</span> </span>&#123;</span><br><span class="line">        LL even = n + <span class="number">1</span> &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        LL odd = n &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> (ksm(<span class="number">5</span>, even, MOD) * ksm(<span class="number">4</span>, odd, MOD)) % MOD;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div></div></div><div class="note primary">            <p><strong>原题链接：</strong> <a href="https://leetcode-cn.com/problems/count-good-numbers/" target="_blank" rel="noopener">LeetCode 5802. 统计好数字的数目</a></p>          </div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;摘要：&lt;/strong&gt;&lt;br&gt;经典模意义下快速幂应用。&lt;/p&gt;
    
    </summary>
    
    
      <category term="指尖飞舞" scheme="https://accepted.org.cn/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/"/>
    
      <category term="算法" scheme="https://accepted.org.cn/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/%E7%AE%97%E6%B3%95/"/>
    
      <category term="LeetCode" scheme="https://accepted.org.cn/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/%E7%AE%97%E6%B3%95/LeetCode/"/>
    
      <category term="竞赛" scheme="https://accepted.org.cn/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/%E7%AE%97%E6%B3%95/%E7%AB%9E%E8%B5%9B/"/>
    
      <category term="LeetCode周赛" scheme="https://accepted.org.cn/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/%E7%AE%97%E6%B3%95/%E7%AB%9E%E8%B5%9B/LeetCode%E5%91%A8%E8%B5%9B/"/>
    
      <category term="248" scheme="https://accepted.org.cn/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/%E7%AE%97%E6%B3%95/%E7%AB%9E%E8%B5%9B/LeetCode%E5%91%A8%E8%B5%9B/248/"/>
    
    
      <category term="算法" scheme="https://accepted.org.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="LeetCode" scheme="https://accepted.org.cn/tags/LeetCode/"/>
    
      <category term="数学" scheme="https://accepted.org.cn/tags/%E6%95%B0%E5%AD%A6/"/>
    
      <category term="竞赛" scheme="https://accepted.org.cn/tags/%E7%AB%9E%E8%B5%9B/"/>
    
      <category term="数论" scheme="https://accepted.org.cn/tags/%E6%95%B0%E8%AE%BA/"/>
    
      <category term="快速幂" scheme="https://accepted.org.cn/tags/%E5%BF%AB%E9%80%9F%E5%B9%82/"/>
    
  </entry>
  
  <entry>
    <title>【AcWing算法基础】第四讲-数学知识-快速幂 AcWing 875. 快速幂</title>
    <link href="https://accepted.org.cn/2021/07/04/%E3%80%90AcWing%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E3%80%91%E7%AC%AC%E5%9B%9B%E8%AE%B2-%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86-%E5%BF%AB%E9%80%9F%E5%B9%82-AcWing-875-%E5%BF%AB%E9%80%9F%E5%B9%82/"/>
    <id>https://accepted.org.cn/2021/07/04/%E3%80%90AcWing%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E3%80%91%E7%AC%AC%E5%9B%9B%E8%AE%B2-%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86-%E5%BF%AB%E9%80%9F%E5%B9%82-AcWing-875-%E5%BF%AB%E9%80%9F%E5%B9%82/</id>
    <published>2021-07-04T15:46:47.000Z</published>
    <updated>2021-07-04T17:00:26.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>摘要：</strong><br>经典快速求幂的算法。</p><a id="more"></a><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给定 $n$ 组 $a_i$, $b_i$, $p_i$，对于每组数据，求出 $a_i^{b_i} \bmod p_i$ 的值。</p><p><strong>输入格式</strong></p><p>第一行包含整数 $n$。</p><p>接下来 $n$ 行，每行包含三个整数 $a_i$, $b_i$, $p_i$。</p><p><strong>输出格式</strong></p><p>对于每组数据，输出一个结果，表示 $a_i^{b_i} \bmod p_i$ 的值。</p><p>每个结果占一行。</p><p><strong>数据范围</strong></p><ul><li>$1≤n≤100000$,</li><li>$1≤a_i, b_i, p_i≤2×10^9$</li></ul><p><strong>输入样例：</strong></p><blockquote><p>2<br>3 2 5<br>4 3 9</p></blockquote><p><strong>输出样例：</strong></p><blockquote><p>4<br>1</p></blockquote><hr><h3 id="二进制反复平方"><a href="#二进制反复平方" class="headerlink" title="二进制反复平方"></a>二进制反复平方</h3><p>本题是模意义下取幂，我们知道取模运算不会干涉乘法运算。所以我们核心关注如何求 $a^b$.</p><p>如果我们可以将 $b$ 拆分成 $2^{x_1} + 2^{x_2} + … + 2^{x_i}$，那么</p><p>$a^b = a^{2^{x_1} + 2^{x_2} + … + 2^{x_i}}$ (即$a^b = a^{2^{x_1}} \times a^{2^{x_2}} \times … \times a^{2^{x_i}}$).</p><p>显然这是将 $b$ 转化为 $2$ 进制后进行 $10$ 进制展开的结果，很轻松可以做到。</p><p>那么现在考虑如何快速获得 $a^{2^{x_1}} \times a^{2^{x_2}} \times … \times a^{2^{x_i}}$ 的值。</p><p>我们可以很方便地预处理出来 $a^{2^0}, a^{2^1}, a^{2^2} … a^{2^{log_2b}}$ 的序列。其中最后一项 $a^{2^{log_2b}}$ 需要刚好小于等于 $a^{b}$.</p><p>有了这样一个序列，我们就可以从中选择需要的数字相乘即可得到最终答案。显然，当 $b$ 的二进制位为1的时候就是对应需要的值（如果二进制位为 $0$，则 $10$ 进制展开的时候是 $0 \times 2^{x_i}$，相加的时候被忽略）。</p><p>在预处理过程中，每一项都是由前一项平方得到，那么整个算法的时间复杂度为 $O(logb)$.</p><div class="tabs" id="g_tab0"><ul class="nav-tabs"><li class="tab active"><a href="#g_tab0-1">C++</a></li></ul><div class="tab-content"><div class="tab-pane active" id="g_tab0-1"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">ksm</span><span class="params">(<span class="keyword">int</span> &amp;a, <span class="keyword">int</span> &amp;b, <span class="keyword">int</span> &amp;p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LL res = <span class="number">1</span>; <span class="comment">// 2的零次幂</span></span><br><span class="line">    <span class="keyword">while</span> (b) &#123;</span><br><span class="line">        <span class="comment">// 如果b的最后一位是1，那么将b拆成2进制表示再分解成若干个2的xi次幂因式的时候，某一个因式对应着该位</span></span><br><span class="line">        <span class="keyword">if</span> (b &amp; <span class="number">1</span>) res = res * a % p;  <span class="comment">// a,b &gt;= 1，所以至少需要算一下第一次a的2的0次幂(等于a)，所以res初始化为1. 随后的计算, a被更新成对应a的2的若干次幂</span></span><br><span class="line">        <span class="comment">// 不管b最后一位是否是1，都需要反复求a的平方，直到a的2的x次幂 &gt; a的b次幂，此时一共计算了log_2b次</span></span><br><span class="line">        a = (LL)a * a % p;  <span class="comment">// 下一次a更新成本次a的平方，其中a = a的2的xi次幂</span></span><br><span class="line">        b &gt;&gt;= <span class="number">1</span>;    <span class="comment">// b右移一位，直到为0退出循环</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>)-&gt;sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">int</span> a, b, p;</span><br><span class="line">    <span class="keyword">while</span> (n--) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b &gt;&gt; p;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; ksm(a, b, p) &lt;&lt; <span class="built_in">endl</span>;    </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div></div><p>现在证明模意义下取幂的正确性：<br>根据模运算性质可知，<br>$x \times y \bmod p = x \bmod p \times y \bmod p$.</p><p>那么，$a^b \bmod p = (a^{2^{x_1}} \times a^{2^{x_2}} \times … \times a^{2^{x_i}}) \bmod p$.</p><p>即$a^b \bmod p = (a^{2^{x_1}} \bmod p \times a^{2^{x_2}} \bmod p \times … \times a^{2^{x_i}} \bmod p) \bmod p$.</p><p>那么每次 $a$ 的迭代 $\bmod p$ 一次，对应上式中每一项 $\bmod p$，每次 $res$ 计算的时候 $\bmod p$ 一次对应上式中最后面的 $\bmod p$.</p><p>取模运算不会干涉乘法运算。</p><div class="note primary">            <p><strong>原题链接：</strong> <a href="https://www.acwing.com/problem/content/description/877/" target="_blank" rel="noopener">AcWing 875. 快速幂</a></p>          </div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;摘要：&lt;/strong&gt;&lt;br&gt;经典快速求幂的算法。&lt;/p&gt;
    
    </summary>
    
    
      <category term="指尖飞舞" scheme="https://accepted.org.cn/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/"/>
    
      <category term="算法" scheme="https://accepted.org.cn/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/%E7%AE%97%E6%B3%95/"/>
    
      <category term="AcWing" scheme="https://accepted.org.cn/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/%E7%AE%97%E6%B3%95/AcWing/"/>
    
      <category term="算法基础课" scheme="https://accepted.org.cn/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/%E7%AE%97%E6%B3%95/AcWing/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BE/"/>
    
      <category term="第四讲数学知识" scheme="https://accepted.org.cn/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/%E7%AE%97%E6%B3%95/AcWing/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BE/%E7%AC%AC%E5%9B%9B%E8%AE%B2%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="算法" scheme="https://accepted.org.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="数学" scheme="https://accepted.org.cn/tags/%E6%95%B0%E5%AD%A6/"/>
    
      <category term="位运算" scheme="https://accepted.org.cn/tags/%E4%BD%8D%E8%BF%90%E7%AE%97/"/>
    
      <category term="AcWing" scheme="https://accepted.org.cn/tags/AcWing/"/>
    
      <category term="数论" scheme="https://accepted.org.cn/tags/%E6%95%B0%E8%AE%BA/"/>
    
      <category term="快速幂" scheme="https://accepted.org.cn/tags/%E5%BF%AB%E9%80%9F%E5%B9%82/"/>
    
  </entry>
  
  <entry>
    <title>【LeetCode周赛248】B LeetCode 5801. 消灭怪物的最大数量</title>
    <link href="https://accepted.org.cn/2021/07/04/%E3%80%90LeetCode%E5%91%A8%E8%B5%9B248%E3%80%91B-LeetCode-5801-%E6%B6%88%E7%81%AD%E6%80%AA%E7%89%A9%E7%9A%84%E6%9C%80%E5%A4%A7%E6%95%B0%E9%87%8F/"/>
    <id>https://accepted.org.cn/2021/07/04/%E3%80%90LeetCode%E5%91%A8%E8%B5%9B248%E3%80%91B-LeetCode-5801-%E6%B6%88%E7%81%AD%E6%80%AA%E7%89%A9%E7%9A%84%E6%9C%80%E5%A4%A7%E6%95%B0%E9%87%8F/</id>
    <published>2021-07-04T14:22:06.000Z</published>
    <updated>2021-07-04T14:36:06.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>摘要：</strong><br>很明显的贪心题，植物大战僵尸。</p><a id="more"></a><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>你正在玩一款电子游戏，在游戏中你需要保护城市免受怪物侵袭。给你一个 <strong>下标从 $0$ 开始</strong> 且长度为 $n$ 的整数数组 $dist$ ，其中 $dist[i]$ 是第 $i$ 个怪物与城市的 <strong>初始距离</strong>（单位：米）。</p><p>怪物以 <strong>恒定</strong> 的速度走向城市。给你一个长度为 $n$ 的整数数组 $speed$ 表示每个怪物的速度，其中 $speed[i]$ 是第 $i$ 个怪物的速度（单位：米/分）。</p><p>怪物从 <strong>第 $0$ 分钟</strong> 时开始移动。你有一把武器，并可以 <strong>选择</strong> 在每一分钟的开始时使用，包括第 0 分钟。但是你无法在一分钟的中间使用武器。这种武器威力惊人，一次可以消灭任一还活着的怪物。</p><p>一旦任一怪物到达城市，你就输掉了这场游戏。如果某个怪物 <strong>恰</strong> 在某一分钟开始时到达城市，这会被视为 <strong>输掉</strong> 游戏，在你可以使用武器之前，游戏就会结束。</p><p>返回在你输掉游戏前可以消灭的怪物的 <strong>最大</strong> 数量。如果你可以在所有怪物到达城市前将它们全部消灭，返回  $n$ 。</p><p><strong>示例 1：</strong></p><blockquote><p>输入：dist = [1,3,4], speed = [1,1,1]<br>输出：3<br>解释：<br>第 0 分钟开始时，怪物的距离是 [1,3,4]，你消灭了第一个怪物。<br>第 1 分钟开始时，怪物的距离是 [X,2,3]，你没有消灭任何怪物。<br>第 2 分钟开始时，怪物的距离是 [X,1,2]，你消灭了第二个怪物。<br>第 3 分钟开始时，怪物的距离是 [X,X,1]，你消灭了第三个怪物。<br>所有 3 个怪物都可以被消灭。</p></blockquote><p><strong>示例 2：</strong></p><blockquote><p>输入：dist = [1,1,2,3], speed = [1,1,1,1]<br>输出：1<br>解释：<br>第 0 分钟开始时，怪物的距离是 [1,1,2,3]，你消灭了第一个怪物。<br>第 1 分钟开始时，怪物的距离是 [X,0,1,2]，你输掉了游戏。<br>你只能消灭 1 个怪物。</p></blockquote><p><strong>示例 3：</strong></p><blockquote><p>输入：dist = [3,2,4], speed = [5,3,2]<br>输出：1<br>解释：<br>第 0 分钟开始时，怪物的距离是 [3,2,4]，你消灭了第一个怪物。<br>第 1 分钟开始时，怪物的距离是 [X,0,2]，你输掉了游戏。<br>你只能消灭 1 个怪物。</p></blockquote><p><strong>提示：</strong></p><ul><li>$n = dist.length = speed.length$</li><li>$1 &lt;= n &lt;= 10^5$</li><li>$1 &lt;= dist[i], speed[i] &lt;= 10^5$</li></ul><hr><h3 id="贪心"><a href="#贪心" class="headerlink" title="贪心"></a>贪心</h3><p>不能根据距离判断优先击杀的对象，因为速度不同，所以要根据预计到达时间来判断。<br>因为每次击杀之后都需要获得最近到达的对象，所以考虑将所有对象的预计到达时间计算出来，从小到大排序。</p><div class="tabs" id="g_tab0"><ul class="nav-tabs"><li class="tab active"><a href="#g_tab0-1">C++</a></li></ul><div class="tab-content"><div class="tab-pane active" id="g_tab0-1"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">eliminateMaximum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; dist, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; speed)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = dist.<span class="built_in">size</span>();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; time;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            time.push_back((<span class="keyword">double</span>)dist[i] / speed[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        sort(time.<span class="built_in">begin</span>(), time.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (res &gt;= time[i]) <span class="keyword">return</span> res;</span><br><span class="line">            ++res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div></div></div><div class="note primary">            <p><strong>原题链接：</strong> <a href="https://leetcode-cn.com/problems/eliminate-maximum-number-of-monsters/" target="_blank" rel="noopener">LeetCode 5801. 消灭怪物的最大数量</a></p>          </div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;摘要：&lt;/strong&gt;&lt;br&gt;很明显的贪心题，植物大战僵尸。&lt;/p&gt;
    
    </summary>
    
    
      <category term="指尖飞舞" scheme="https://accepted.org.cn/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/"/>
    
      <category term="算法" scheme="https://accepted.org.cn/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/%E7%AE%97%E6%B3%95/"/>
    
      <category term="LeetCode" scheme="https://accepted.org.cn/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/%E7%AE%97%E6%B3%95/LeetCode/"/>
    
      <category term="竞赛" scheme="https://accepted.org.cn/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/%E7%AE%97%E6%B3%95/%E7%AB%9E%E8%B5%9B/"/>
    
      <category term="LeetCode周赛" scheme="https://accepted.org.cn/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/%E7%AE%97%E6%B3%95/%E7%AB%9E%E8%B5%9B/LeetCode%E5%91%A8%E8%B5%9B/"/>
    
      <category term="248" scheme="https://accepted.org.cn/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/%E7%AE%97%E6%B3%95/%E7%AB%9E%E8%B5%9B/LeetCode%E5%91%A8%E8%B5%9B/248/"/>
    
    
      <category term="算法" scheme="https://accepted.org.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="LeetCode" scheme="https://accepted.org.cn/tags/LeetCode/"/>
    
      <category term="竞赛" scheme="https://accepted.org.cn/tags/%E7%AB%9E%E8%B5%9B/"/>
    
      <category term="贪心" scheme="https://accepted.org.cn/tags/%E8%B4%AA%E5%BF%83/"/>
    
  </entry>
  
  <entry>
    <title>【LeetCode周赛247】C LeetCode 1915. 最美子字符串的数目</title>
    <link href="https://accepted.org.cn/2021/07/03/%E3%80%90LeetCode%E5%91%A8%E8%B5%9B247%E3%80%91C-LeetCode-1915-%E6%9C%80%E7%BE%8E%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%95%B0%E7%9B%AE/"/>
    <id>https://accepted.org.cn/2021/07/03/%E3%80%90LeetCode%E5%91%A8%E8%B5%9B247%E3%80%91C-LeetCode-1915-%E6%9C%80%E7%BE%8E%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%95%B0%E7%9B%AE/</id>
    <published>2021-07-03T15:51:04.000Z</published>
    <updated>2021-07-05T16:49:14.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>摘要：</strong><br>将奇偶性的状态压缩成一个二进制数字。</p><a id="more"></a><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>如果某个字符串中 至多一个 字母出现 <strong>奇数</strong> 次，则称其为 <strong>最美</strong> 字符串。</p><ul><li>例如，$ccjjc$ 和 $abab$ 都是最美字符串，但 $ab$ 不是。</li></ul><p>给你一个字符串 $word$ ，该字符串由前十个小写英文字母组成（$a$ 到 $j$）。请你返回 $word$ 中 <strong>最美非空子字符串</strong> 的数目。如果同样的子字符串在 $word$ 中出现多次，那么应当对 <strong>每次出现</strong> 分别计数。</p><p><strong>子字符串</strong> 是字符串中的一个连续字符序列。</p><p><strong>示例 1：</strong></p><blockquote><p>输入：word = “aba”<br>输出：4<br>解释：4 个最美子字符串如下所示：<br>– “aba” -&gt; “a”<br>– “aba” -&gt; “b”<br>– “aba” -&gt; “a”<br>– “aba” -&gt; “aba”</p></blockquote><p><strong>示例 2：</strong></p><blockquote><p>输入：word = “aabb”<br>输出：9<br>解释：9 个最美子字符串如下所示：<br>– “aabb” -&gt; “a”<br>– “aabb” -&gt; “aa”<br>– “aabb” -&gt; “aab”<br>– “aabb” -&gt; “aabb”<br>– “aabb” -&gt; “a”<br>– “aabb” -&gt; “abb”<br>– “aabb” -&gt; “b”<br>– “aabb” -&gt; “bb”<br>– “aabb” -&gt; “b”</p></blockquote><p><strong>示例 3：</strong></p><blockquote><p>输入：word = “he”<br>输出：2<br>解释：2 个最美子字符串如下所示：<br>– “he” -&gt; “h”<br>– “he” -&gt; “e”</p></blockquote><p><strong>提示：</strong></p><ul><li>$1 &lt;= word.length &lt;= 10^5$</li><li>$word$ 由从 $a$ 到 $j$ 的小写英文字母组成</li></ul><hr><h3 id="前缀和"><a href="#前缀和" class="headerlink" title="前缀和"></a>前缀和</h3><p>根据题意，在某个最美子串中，所有的字母出现的的次数要么全为偶数次，要么有一位字母出现了奇数次。<br>很容易想到使用前缀和快速拿到出现次数。配合暴力枚举子串，复杂度为 $n \times (n + 1) / 2$，必然超时。</p><p>定义前缀和数组 $presum[N][j]$，其中 $1 &lt;= N &lt;= 10^5$, $j = 10$. $presum[i][j]$ 表示在原字符串中从第 $1$ 位开始到第 $i$ 位结尾的子串某个字母出现的次数。</p><p>那么一段下标为 $[a, b]$ 的子串，它的某个字母 $j$ 出现次数可表示为 $presum[b][j] - presum[a - 1][j]$。 根据数学知识，如果它是一个奇数，那么 $presum[b][j]$ 和 $presum[a - 1][j]$ 奇偶性不同，反之相同。</p><p>那么问题就变成了：在字符串所有子串中，每个字母对应的 $presum[b][j]$ 和 $presum[a - 1][j]$ 奇偶性不同的情况最多只能出现一次的子串一共多少。</p><p>现在对前缀和数组的某一项的每一位字母出现的奇偶性状态进行压缩。<br>对于某个子串，我们可以将出现奇数次的字母记为 $1$，将出现偶数次的字母记为 $0$.由于字母范围为字母表前 $10$ 个，那么一段子串的每一位字母出现次数的奇偶性状态可表示为一个 $10$ 位的二进制数。</p><p>$presum[b][j]$ 和 $presum[a - 1][j]$ 的各字母出现奇偶性的状态都可以表示成一个 $10$ 位二进制数。<br>对于以下标 $b$ 结尾的前缀子串的奇偶性状态，以下标 $a$ 结尾的子串共有 $11$ 种对应的状态可以满足奇偶性不同的情况最多一次的条件。其中，完全和该状态相同的状态表示奇偶性不同的情况出现 $0$ 次，即奇偶性完全相同；另外 $10$ 种对应着原状态的 $10$ 位奇偶状态的某一位不同。<br>比如一个状态为：<code>0001000110</code>. 满足条件的 $11$ 种状态如下：<br><code>0001000110</code><br><code>1001000110</code><br><code>0101000110</code><br><code>0011000110</code><br><code>0000000110</code><br><code>0001100110</code><br><code>0001010110</code><br><code>0001001110</code><br><code>0001000010</code><br><code>0001000100</code><br><code>0001000111</code><br>那么我们考虑遍历字符串，当遍历到第 $b$ 位时，枚举上述 $11$ 种状态，如果之前出现过其中一种或多种，那么以那一种或多种对应下标开始到 $b$ 结束的子串即满足要求。</p><p>所以我们需要一个计数数组，将从第 $1$ 个字符开始到遍历到的每一位字符结束的状态数量记录下来供后面使用。<br>考虑到二进制状态数字最高 $10$ 位，所以可以开一个数量为 $10000000000_2$（$1024_{10}$）的计数数组.</p><p>另外，思考一下计数数组的第 $0$ 位初始化为什么应该是 $1$.<br>在字符串第 $0$ 位之前，存在一个状态 <code>0000000000</code>，它表示每一位字母出现了 $0$ 次（均为偶数）。所以这种状态在遍历之前计数为 $1$.</p><p>举例：对于一个字符串 $a$ 来说，它的最美子串数目为 $1$. 我们初始化状态 <code>0000000000</code> 的数量为 $1$，这样，在遍历到字符串第 $0$ 个数的时候状态为 <code>1000000000</code>，$11$ 个期望的状态中共有一种符合与之构成最美子串的状态，即初始化的 <code>0000000000</code>. 这两个状态有一位字母的出现的奇偶性不同。对应子串为 $a$.</p><div class="tabs" id="g_tab0"><ul class="nav-tabs"><li class="tab active"><a href="#g_tab0-1">C++</a></li></ul><div class="tab-content"><div class="tab-pane active" id="g_tab0-1"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">int</span> N = <span class="number">1024</span>;</span><br><span class="line">    <span class="keyword">int</span> cnt[N];    </span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> res;</span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">wonderfulSubstrings</span><span class="params">(<span class="built_in">string</span> <span class="keyword">word</span>)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = <span class="keyword">word</span>.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">presum</span><span class="params">(len + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; (<span class="number">10</span>, <span class="number">0</span>))</span></span>;</span><br><span class="line">        <span class="built_in">memset</span>(cnt, <span class="number">0</span>, <span class="keyword">sizeof</span> cnt);</span><br><span class="line">        cnt[<span class="number">0</span>]++;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="keyword">char</span> c = <span class="keyword">word</span>[i];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">10</span>; j++) &#123;</span><br><span class="line">                presum[i + <span class="number">1</span>][j] = presum[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">            presum[i + <span class="number">1</span>][c - <span class="string">'a'</span>]++;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">            for (int j = 0; j &lt; 10; j++) &#123;</span></span><br><span class="line"><span class="comment">                cout &lt;&lt; presum[i + 1][j] &lt;&lt; ' ';</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">            cout &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            <span class="keyword">int</span> state = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">10</span>; j++)</span><br><span class="line">                state = state * <span class="number">2</span> + presum[i + <span class="number">1</span>][j] % <span class="number">2</span>;    <span class="comment">// 跟10进制一样的。一段十进制序列转换成十进制数：for (int j = 0; j &lt; len; j++) res = res * 10 + seq[j];</span></span><br><span class="line">            <span class="comment">// 对于当前以i结尾的字符串，根据当前状态枚举每一种可能的状态，通过cnt数组查看之前有没有出现过</span></span><br><span class="line">            <span class="comment">// 首先是完全一样的状态，如果在[0, i - 1]这一段出现过跟以i结尾的字符串完全一致的状态，那么它们构成的子串有0个字母出现了奇数次</span></span><br><span class="line">            res += cnt[state];</span><br><span class="line">            <span class="comment">// 其次是10种不同状态，每种有一位和当前状态不同</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">10</span>; j++) &#123;</span><br><span class="line">                res += cnt[state ^ (<span class="number">1</span> &lt;&lt; j)];</span><br><span class="line">            &#125;</span><br><span class="line">            cnt[state]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div></div></div><p>代码涉及到的两个额外知识，且都和位运算有关:</p><ol><li><p>将一段二进制序列转换成十进制数：<br>对于以下标b结束的前缀和字母计数序列，需要将它的各位奇偶性状态压缩成一个二进制数。代码是：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> state = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">10</span>; j++)</span><br><span class="line">    state = state * <span class="number">2</span> + presum[i + <span class="number">1</span>][j] % <span class="number">2</span>;</span><br></pre></td></tr></table></figure></li><li><p>一个二进制数 $x$，它的距离最低位 $k$ 个数字不同且其他位相同的二进制数为：<br><code>x ^ (1 &lt;&lt; k)</code></p></li></ol><div class="note primary">            <p><strong>原题链接：</strong> <a href="https://leetcode-cn.com/problems/number-of-wonderful-substrings/" target="_blank" rel="noopener">LeetCode 1915. 最美子字符串的数目</a></p>          </div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;摘要：&lt;/strong&gt;&lt;br&gt;将奇偶性的状态压缩成一个二进制数字。&lt;/p&gt;
    
    </summary>
    
    
      <category term="指尖飞舞" scheme="https://accepted.org.cn/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/"/>
    
      <category term="算法" scheme="https://accepted.org.cn/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/%E7%AE%97%E6%B3%95/"/>
    
      <category term="LeetCode" scheme="https://accepted.org.cn/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/%E7%AE%97%E6%B3%95/LeetCode/"/>
    
      <category term="竞赛" scheme="https://accepted.org.cn/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/%E7%AE%97%E6%B3%95/%E7%AB%9E%E8%B5%9B/"/>
    
      <category term="LeetCode周赛" scheme="https://accepted.org.cn/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/%E7%AE%97%E6%B3%95/%E7%AB%9E%E8%B5%9B/LeetCode%E5%91%A8%E8%B5%9B/"/>
    
      <category term="247" scheme="https://accepted.org.cn/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/%E7%AE%97%E6%B3%95/%E7%AB%9E%E8%B5%9B/LeetCode%E5%91%A8%E8%B5%9B/247/"/>
    
    
      <category term="算法" scheme="https://accepted.org.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="LeetCode" scheme="https://accepted.org.cn/tags/LeetCode/"/>
    
      <category term="前缀和" scheme="https://accepted.org.cn/tags/%E5%89%8D%E7%BC%80%E5%92%8C/"/>
    
      <category term="位运算" scheme="https://accepted.org.cn/tags/%E4%BD%8D%E8%BF%90%E7%AE%97/"/>
    
      <category term="竞赛" scheme="https://accepted.org.cn/tags/%E7%AB%9E%E8%B5%9B/"/>
    
  </entry>
  
  <entry>
    <title>【LeetCode双周赛55】C LeetCode 1911. 最大子序列交替和</title>
    <link href="https://accepted.org.cn/2021/07/03/%E3%80%90LeetCode%E5%8F%8C%E5%91%A8%E8%B5%9B55%E3%80%91C-LeetCode-1911-%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%88%97%E4%BA%A4%E6%9B%BF%E5%92%8C/"/>
    <id>https://accepted.org.cn/2021/07/03/%E3%80%90LeetCode%E5%8F%8C%E5%91%A8%E8%B5%9B55%E3%80%91C-LeetCode-1911-%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%88%97%E4%BA%A4%E6%9B%BF%E5%92%8C/</id>
    <published>2021-07-03T04:50:36.000Z</published>
    <updated>2021-07-05T16:49:28.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>摘要：</strong><br>经典的状态机类型的dp问题。</p><a id="more"></a><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>一个下标从 $0$ 开始的数组的 <strong>交替和</strong> 定义为 <strong>偶数</strong> 下标处元素之 <strong>和</strong> 减去 <strong>奇数</strong> 下标处元素之 <strong>和</strong> 。</p><ul><li>比方说，数组 $[4,2,5,3]$ 的交替和为 $(4 + 5) - (2 + 3) = 4$ 。</li></ul><p>给你一个数组 $nums$ ，请你返回 $nums$ 中任意子序列的 <strong>最大交替和</strong> （子序列的下标 <strong>重新</strong> 从 $0$ 开始编号）。</p><p>一个数组的 <strong>子序列</strong> 是从原数组中删除一些元素后（也可能一个也不删除）剩余元素不改变顺序组成的数组。比方说，$[2,7,4]$ 是 $[4,2,3,7,2,1,4]$ 的一个子序列（加粗元素），但是 $[2,4,2]$ 不是。</p><p><strong>示例 1：</strong></p><blockquote><p>输入：nums = [4,2,5,3]<br>输出：7<br>解释：最优子序列为 [4,2,5] ，交替和为 (4 + 5) - 2 = 7 。</p></blockquote><p><strong>示例 2：</strong></p><blockquote><p>输入：nums = [5,6,7,8]<br>输出：8<br>解释：最优子序列为 [8] ，交替和为 8 。</p></blockquote><p><strong>示例 3：</strong></p><p>输入：nums = [6,2,1,2,4,5]<br>输出：10<br>解释：最优子序列为 [6,1,5] ，交替和为 (6 + 5) - 1 = 10 。</p><p><strong>提示：</strong></p><ul><li>$1 &lt;= nums.length &lt;= 10^5$</li><li>$1 &lt;= nums[i] &lt;= 10^5$</li></ul><hr><h3 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h3><p><strong>状态集合：</strong> 前 $i$ 个数字，数字总数为偶数的子序列与前 $i$ 个数字，数字总数为奇数的子序列构成的集合。</p><p><strong>状态集合元素属性：</strong> 对于集合中的每个元素（子序列），定义子序列的交替和的最大值为元素属性。</p><p><strong>状态计算：</strong> 设 $f[i][0]$ 为前 $i$ 个数字，数字总数为偶数的子序列的最大交替和；设 $f[i][1]$ 为前 $i$ 个数字，数字总数为奇数的子序列的最大交替和；</p><p>对前 $i$ 个数字依次计算两种交替和：</p><ul><li><p>前 $i$ 个数字，子序列总数为偶数时，最后一个数字 $nums[i]$ 可取可不取。</p><ul><li><p>取第 $i$ 个数字时，对于整个构成的子序列而言，由原数组前 $i - 1$ 个数字构成的子序列前部分总数一定是奇数，那么问题就变成了，由原数组前 $i - 1$ 个数字构成的总数为奇数的子序列的最大交替和与第 $i$ 项数字共同构成的子序列的最大交替和是多少。因为子序列下标从 $0$ 开始计算，取最后一项后总数是偶数，那么最后一项在子序列中的下标一定是奇数。由交替和的定义可知：</p><p>$f[i][0] = f[i - 1][1] - nums[i]$</p></li><li><p>不取第 $i$ 个数字时，我们从前 $i - 1$ 项来考虑。我们现在假设由原数组前 $i - 1$ 项构成的子序列总数是偶数，现在有第 $i$ 项存在，但是我们不取，那么原数组前 $i$ 项构成的子序列总数依然是偶数，且有：</p><p>$f[i][0] = f[i - 1][0]$</p></li><li><p>将上述两种情况合并有：</p><p>$f[i][0] = max(f[i - 1][0], f[i - 1][1] - nums[i])$</p></li></ul></li><li><p>前i个数字，子序列总数为奇数时，最后一个数字 $nums[i]$ 也是可取可不取。</p><ul><li><p>取第 $i$ 个数字时，这里又分为两种情况：</p><ul><li><p>取了之后放弃子序列中所有前面的值，只留原数组第 $i$ 个数，总数依旧是奇数。<br>那么有：</p><p>$f[i][1] = 0 + nums[i]$</p></li><li><p>取了之后保留子序列中所有前面的值，对于整个构成的子序列而言，由原数组前 $i - 1$ 个数字构成的子序列前部分总数一定是偶数，那么问题就变成了，由原数组前 $i - 1$ 个数字构成的总数为偶数的子序列的最大交替和与第 $i$ 项数字共同构成的子序列的最大交替和是多少。因为子序列下标从 $0$ 开始计算，取最后一项后总数是奇数，那么最后一项在子序列中的下标一定是偶数。由交替和的定义可知：</p><p>$f[i][1] = f[i - 1][1] + nums[i]$</p></li><li><p>将这两种子情况合并有：</p><p>$f[i][1] = max(0 + f[i - 1][1]) + nums[i]$</p></li></ul></li><li><p>不取第 $i$ 个数字时，我们从前 $i - 1$ 项来考虑。我们现在假设由原数组前 $i - 1$ 项构成的子序列总数是奇数，现在有第 $i$ 项存在，但是我们不取，那么原数组前 $i$ 项构成的子序列总数依然是奇数，且有：</p><p>$f[i][1] = f[i - 1][1]$</p></li><li><p>将上述两种情况合并有：</p><p>$f[i][1] = max(f[i - 1][1], max(0 + f[i - 1][1]) + nums[i])$</p></li></ul></li></ul><div class="tabs" id="g_tab0"><ul class="nav-tabs"><li class="tab active"><a href="#g_tab0-1">C++</a></li></ul><div class="tab-content"><div class="tab-pane active" id="g_tab0-1"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">maxAlternatingSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="comment">// dp[i][0]: 前 i 个数，总数为偶数的子序列的最大交替和</span></span><br><span class="line">        <span class="comment">// dp[i][1]: 前 i 个数，总数为奇数的子序列的最大交替和</span></span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt;&gt; <span class="title">dp</span><span class="params">(n, <span class="built_in">vector</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt;(<span class="number">2</span>, <span class="number">0</span>))</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>, dp[<span class="number">0</span>][<span class="number">1</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="comment">// 考虑前i个数中子序列总数为偶数的情况</span></span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][<span class="number">0</span>], dp[i - <span class="number">1</span>][<span class="number">1</span>] - nums[i]);</span><br><span class="line">            <span class="comment">// 考虑前i个数中子序列总数为奇数的情况</span></span><br><span class="line">            dp[i][<span class="number">1</span>] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][<span class="number">1</span>], <span class="built_in">max</span>(<span class="number">0l</span>l, dp[i - <span class="number">1</span>][<span class="number">0</span>]) + nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(dp[n - <span class="number">1</span>][<span class="number">0</span>], dp[n - <span class="number">1</span>][<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div></div></div><p>仔细观察不难发现，dp数组每一项都是非负的（因为原数组每一项取值为$1 &lt;= nums[i] &lt;= 10^5$，且dp数组的初始项非负，且后序计算是不断地取最大值扩展的），那么 <code>max(0ll, dp[i - 1][0]) + nums[i]</code> 可以优化成 <code>dp[i - 1][0] + nums[i]</code>.</p><div class="note primary">            <p><strong>原题链接：</strong> <a href="https://leetcode-cn.com/problems/maximum-alternating-subsequence-sum/" target="_blank" rel="noopener">LeetCode 1911. 最大子序列交替和</a></p>          </div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;摘要：&lt;/strong&gt;&lt;br&gt;经典的状态机类型的dp问题。&lt;/p&gt;
    
    </summary>
    
    
      <category term="指尖飞舞" scheme="https://accepted.org.cn/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/"/>
    
      <category term="算法" scheme="https://accepted.org.cn/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/%E7%AE%97%E6%B3%95/"/>
    
      <category term="LeetCode" scheme="https://accepted.org.cn/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/%E7%AE%97%E6%B3%95/LeetCode/"/>
    
      <category term="竞赛" scheme="https://accepted.org.cn/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/%E7%AE%97%E6%B3%95/%E7%AB%9E%E8%B5%9B/"/>
    
      <category term="LeetCode双周赛" scheme="https://accepted.org.cn/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/%E7%AE%97%E6%B3%95/%E7%AB%9E%E8%B5%9B/LeetCode%E5%8F%8C%E5%91%A8%E8%B5%9B/"/>
    
      <category term="55" scheme="https://accepted.org.cn/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/%E7%AE%97%E6%B3%95/%E7%AB%9E%E8%B5%9B/LeetCode%E5%8F%8C%E5%91%A8%E8%B5%9B/55/"/>
    
    
      <category term="算法" scheme="https://accepted.org.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="LeetCode" scheme="https://accepted.org.cn/tags/LeetCode/"/>
    
      <category term="动态规划" scheme="https://accepted.org.cn/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
      <category term="竞赛" scheme="https://accepted.org.cn/tags/%E7%AB%9E%E8%B5%9B/"/>
    
      <category term="状态机" scheme="https://accepted.org.cn/tags/%E7%8A%B6%E6%80%81%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 451. 根据字符出现频率排序</title>
    <link href="https://accepted.org.cn/2021/07/03/LeetCode-451-%E6%A0%B9%E6%8D%AE%E5%AD%97%E7%AC%A6%E5%87%BA%E7%8E%B0%E9%A2%91%E7%8E%87%E6%8E%92%E5%BA%8F/"/>
    <id>https://accepted.org.cn/2021/07/03/LeetCode-451-%E6%A0%B9%E6%8D%AE%E5%AD%97%E7%AC%A6%E5%87%BA%E7%8E%B0%E9%A2%91%E7%8E%87%E6%8E%92%E5%BA%8F/</id>
    <published>2021-07-03T01:14:28.000Z</published>
    <updated>2021-07-03T01:27:44.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>摘要：</strong><br>STL sort() 配合Lambda表达式排序。</p><a id="more"></a><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给定一个字符串，请将字符串里的字符按照出现的频率降序排列。</p><p><strong>示例 1:</strong></p><p>输入:</p><blockquote><p>“tree”<br>输出:<br>“eert”<br>解释:<br>‘e’出现两次，’r’和’t’都只出现一次。<br>因此’e’必须出现在’r’和’t’之前。此外，”eetr”也是一个有效的答案。</p></blockquote><p><strong>示例 2:</strong></p><p>输入:</p><blockquote><p>“cccaaa”<br>输出:<br>“cccaaa”<br>解释:<br>‘c’和’a’都出现三次。此外，”aaaccc”也是有效的答案。<br>注意”cacaca”是不正确的，因为相同的字母必须放在一起。</p></blockquote><p><strong>示例 3:</strong></p><p>输入:</p><blockquote><p>“Aabb”<br>输出:<br>“bbAa”<br>解释:<br>此外，”bbaA”也是一个有效的答案，但”Aabb”是不正确的。<br>注意’A’和’a’被认为是两种不同的字符。</p></blockquote><hr><h3 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h3><p>先将字符计数，再根据计数来排序。<br>需要注意的地方是，当两个不同字符频率相同时，可能会出现顺序打乱的情况，比如说 $a$ 出现 $2$ 次，$b$ 出现 $2$ 次，那么输出可能是 $abab$。<br>为了避免这样的情况，我们需要在不同字符出现相同频率后再按照ascii码排序。</p><div class="tabs" id="g_tab0"><ul class="nav-tabs"><li class="tab active"><a href="#g_tab0-1">C++</a></li></ul><div class="tab-content"><div class="tab-pane active" id="g_tab0-1"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">frequencySort</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; cnt;</span><br><span class="line">        <span class="keyword">int</span> len = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">            cnt[s[i]]++;</span><br><span class="line">        sort(s.<span class="built_in">begin</span>(), s.<span class="built_in">end</span>(), [&amp;](<span class="keyword">char</span> a, <span class="keyword">char</span> b) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cnt[a] != cnt[b]) <span class="keyword">return</span> cnt[a] &gt;= cnt[b];</span><br><span class="line">            <span class="keyword">return</span> a &lt; b;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div></div></div><p>为什么要用Lambda呢，因为leetcode排序 <code>cmp</code> 如果写在类里面需要加 <code>static</code> (不加会隐式的加上this指针)，<code>cmp</code> 中需要用到 <code>cnt</code> 数组或者哈希表，这时候就需要将 <code>cnt</code> 数组或者哈希表放在类变量中或者类外面。如果放在类变量中，因为 <code>cmp</code> 函数时 <code>static</code> 的，那么 <code>cnt</code> 数组或者哈希表也需要是 <code>static</code> 的，就会出现一些很奇怪的问题。如果放在类外面，因为leetcode的问题也会出现一些很奇怪的问题比如执行测试用例可以过但是提交评测无法通过的情况。具体请看：<br><a href="https://eetoa.github.io/2021/06/06/在LeetCode刷题应尽量避免使用全局变量/" target="_blank" rel="noopener">在LeetCode刷题应尽量避免使用全局变量</a></p><div class="note primary">            <p><strong>原题链接：</strong> <a href="https://leetcode-cn.com/problems/sort-characters-by-frequency/" target="_blank" rel="noopener">LeetCode 451. 根据字符出现频率排序</a></p>          </div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;摘要：&lt;/strong&gt;&lt;br&gt;STL sort() 配合Lambda表达式排序。&lt;/p&gt;
    
    </summary>
    
    
      <category term="指尖飞舞" scheme="https://accepted.org.cn/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/"/>
    
      <category term="算法" scheme="https://accepted.org.cn/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/%E7%AE%97%E6%B3%95/"/>
    
      <category term="LeetCode" scheme="https://accepted.org.cn/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/%E7%AE%97%E6%B3%95/LeetCode/"/>
    
    
      <category term="算法" scheme="https://accepted.org.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="LeetCode" scheme="https://accepted.org.cn/tags/LeetCode/"/>
    
      <category term="排序" scheme="https://accepted.org.cn/tags/%E6%8E%92%E5%BA%8F/"/>
    
      <category term="字符串" scheme="https://accepted.org.cn/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
  </entry>
  
  <entry>
    <title>【LeetCode周赛247】B LeetCode 1914. 循环轮转矩阵</title>
    <link href="https://accepted.org.cn/2021/07/02/%E3%80%90LeetCode%E5%91%A8%E8%B5%9B247%E3%80%91B-LeetCode-1914-%E5%BE%AA%E7%8E%AF%E8%BD%AE%E8%BD%AC%E7%9F%A9%E9%98%B5/"/>
    <id>https://accepted.org.cn/2021/07/02/%E3%80%90LeetCode%E5%91%A8%E8%B5%9B247%E3%80%91B-LeetCode-1914-%E5%BE%AA%E7%8E%AF%E8%BD%AE%E8%BD%AC%E7%9F%A9%E9%98%B5/</id>
    <published>2021-07-02T14:12:30.000Z</published>
    <updated>2021-07-05T16:49:34.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>摘要：</strong><br>一道模拟过程的题目，不难，但是有点繁琐。</p><a id="more"></a><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给你一个大小为 $m \times n$ 的整数矩阵 $grid$​​​ ，其中 $m$ 和 $n$ 都是 <strong>偶数</strong> ；另给你一个整数 $k$ 。</p><p>矩阵由若干层组成，如下图所示，每种颜色代表一层：</p><p><img src="0.png" alt="0x0"></p><p>矩阵的循环轮转是通过分别循环轮转矩阵中的每一层完成的。在对某一层进行一次循环旋转操作时，层中的每一个元素将会取代其 <strong>逆时针</strong> 方向的相邻元素。轮转示例如下：</p><p><img src="1.jpg" alt="0x1"><br>返回执行 $k$ 次循环轮转操作后的矩阵。</p><p><strong>示例 1：</strong></p><p><img src="2.png" alt="0x2"></p><blockquote><p>输入：grid = [[40,10],[30,20]], k = 1<br>输出：[[10,20],[40,30]]<br>解释：上图展示了矩阵在执行循环轮转操作时每一步的状态。</p></blockquote><p><strong>示例 2：</strong></p><p><img src="3.png" alt="0x3"></p><p><img src="4.png" alt="0x3"></p><p><img src="5.png" alt="0x3"></p><blockquote><p>输入：grid = [[1,2,3,4],[5,6,7,8],[9,10,11,12],[13,14,15,16]], k = 2<br>输出：[[3,4,8,12],[2,11,10,16],[1,7,6,15],[5,9,13,14]]<br>解释：上图展示了矩阵在执行循环轮转操作时每一步的状态。</p></blockquote><hr><h3 id="模拟"><a href="#模拟" class="headerlink" title="模拟"></a>模拟</h3><p>将每一层放到一个队列中，再计算出每一层的每一位对应轮转 $k$ 次后在队列中的什么位置。<br>将每一层分为 $4$ 次分别处理入队，分别是上右下左，依次是行不变列增加；行增加列不变；行不变列减小；行减小列减小。<br>另外注意不能数组原地替换，因为前面被替换的数原本包含着最后的要替换的数的数。所以需要额外维护一个同样大小的数组。</p><div class="tabs" id="g_tab0"><ul class="nav-tabs"><li class="tab active"><a href="#g_tab0-1">C++</a></li></ul><div class="tab-content"><div class="tab-pane active" id="g_tab0-1"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">rotateGrid</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> R = grid.<span class="built_in">size</span>(), C = grid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">res</span><span class="params">(R, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(C, <span class="number">0</span>))</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> mxr = R, mxc = C, <span class="built_in">begin</span> = <span class="number">0</span>; mxr &gt; <span class="number">0</span> &amp;&amp; mxc &gt; <span class="number">0</span>; mxr -= <span class="number">2</span>, mxc -= <span class="number">2</span>, ++<span class="built_in">begin</span>) &#123; <span class="comment">// 逐层将坐标放入数组中</span></span><br><span class="line">            <span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; &gt; <span class="built_in">queue</span>;</span><br><span class="line">            <span class="keyword">int</span> r = <span class="built_in">begin</span>, c = <span class="built_in">begin</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; mxc - <span class="number">1</span>; i++) <span class="built_in">queue</span>.emplace_back(r, ++c);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; mxr - <span class="number">1</span>; i++) <span class="built_in">queue</span>.emplace_back(++r, c);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; mxc - <span class="number">1</span>; i++) <span class="built_in">queue</span>.emplace_back(r, --c);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; mxr - <span class="number">1</span>; i++) <span class="built_in">queue</span>.emplace_back(--r, c);</span><br><span class="line">            <span class="comment">//for (auto &amp;each : queue) cout &lt;&lt; grid[each.first][each.second] &lt;&lt; " ";</span></span><br><span class="line">            <span class="comment">//cout &lt;&lt; endl;</span></span><br><span class="line">            <span class="keyword">int</span> len = <span class="built_in">queue</span>.<span class="built_in">size</span>();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">                <span class="keyword">int</span> t = (i + k) % len;</span><br><span class="line">                res[<span class="built_in">queue</span>[i].first][<span class="built_in">queue</span>[i].second] = grid[<span class="built_in">queue</span>[t].first][<span class="built_in">queue</span>[t].second];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div></div></div><h3 id="模拟-DFS"><a href="#模拟-DFS" class="headerlink" title="模拟 + DFS"></a>模拟 + DFS</h3><p>我的思路是先确定一共需要进行多少层轮转，对于每一层的每一次轮转写进行一次深搜，一共 $k$ 次，注意 $k$ 需要对一层的总数取模。</p><p>核心在于如何对指定层进行一次轮转。</p><p>深搜从每一层的左上角开始，所以我们要确定每一层的第一个数坐标。<br>深搜过程中到达拐点处需要改变搜索方向，所以我们需要知道每一层的长和宽。<br>另外我们需要对搜索过的格子进行计数，以便判断递归终止。</p><div class="tabs" id="g_tab1"><ul class="nav-tabs"><li class="tab active"><a href="#g_tab1-1">C++</a></li></ul><div class="tab-content"><div class="tab-pane active" id="g_tab1-1"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">int</span> dr[<span class="number">4</span>] = &#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span>&#125;, dc[<span class="number">4</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> R, C;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">rotateGrid</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        R = grid.<span class="built_in">size</span>(), C = grid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> level = <span class="built_in">min</span>(R, C) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//cout &lt;&lt; level &lt;&lt; endl;</span></span><br><span class="line">        <span class="comment">//return res;</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, mod = <span class="number">0</span>; i &lt; level; i++) &#123;</span><br><span class="line">            mod = <span class="number">2</span> * (R - i * <span class="number">2</span>) + <span class="number">2</span> * (C - i * <span class="number">2</span>) - <span class="number">4</span>;</span><br><span class="line">            <span class="comment">//cout &lt;&lt; mod &lt;&lt; endl;</span></span><br><span class="line">            <span class="keyword">int</span> t = k % mod;</span><br><span class="line">            rotation(grid, i, t, mod, R - i * <span class="number">2</span>, C - i * <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> grid;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="keyword">inline</span> <span class="title">rotation</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; &amp;g, <span class="keyword">int</span> level, <span class="keyword">int</span> k, <span class="keyword">int</span> mod, <span class="keyword">int</span> mxr, <span class="keyword">int</span> mxc)</span> </span>&#123;</span><br><span class="line">        pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; start = &#123;<span class="number">0</span> + level * <span class="number">1</span>, <span class="number">0</span> + level * <span class="number">1</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> direction = <span class="number">0</span>; k--; direction = <span class="number">0</span>) &#123;</span><br><span class="line">            dfs(<span class="number">0</span>, g, start, start, <span class="number">0</span>, mod, mxr, mxc, direction);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;   </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> value, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; &amp;g, pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; &amp;start, pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; pos, <span class="keyword">int</span> cnt, <span class="keyword">int</span> &amp;mod, <span class="keyword">int</span> &amp;mxr, <span class="keyword">int</span> &amp;mxc, <span class="keyword">int</span> &amp;direction)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//cout &lt;&lt; pos.first &lt;&lt; ',' &lt;&lt; pos.second &lt;&lt; "," &lt;&lt; cnt &lt;&lt; ',' &lt;&lt; mod &lt;&lt;endl;</span></span><br><span class="line">        <span class="keyword">if</span> (cnt == mod) &#123;</span><br><span class="line">            g[pos.first][pos.second] = value;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> nevalue = g[pos.first][pos.second];</span><br><span class="line">        g[pos.first][pos.second] = value;</span><br><span class="line">        <span class="keyword">if</span> ((pos.first == start.first + mxr - <span class="number">1</span> &amp;&amp; pos.second == start.second) || (pos.first == start.first + mxr - <span class="number">1</span> &amp;&amp; pos.second == start.second + mxc - <span class="number">1</span>) || (pos.first == start.first &amp;&amp; pos.second == start.second + mxc - <span class="number">1</span>)) &#123;</span><br><span class="line">            direction++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ner = pos.first + dr[direction], nec = pos.second + dc[direction];</span><br><span class="line">        dfs(nevalue, g, start, &#123;ner, nec&#125;, cnt + <span class="number">1</span>, mod, mxr, mxc, direction);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div></div></div><div class="note primary">            <p><strong>原题链接：</strong> <a href="https://leetcode-cn.com/problems/cyclically-rotating-a-grid/submissions/" target="_blank" rel="noopener">LeetCode 1914. 循环轮转矩阵</a></p>          </div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;摘要：&lt;/strong&gt;&lt;br&gt;一道模拟过程的题目，不难，但是有点繁琐。&lt;/p&gt;
    
    </summary>
    
    
      <category term="指尖飞舞" scheme="https://accepted.org.cn/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/"/>
    
      <category term="算法" scheme="https://accepted.org.cn/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/%E7%AE%97%E6%B3%95/"/>
    
      <category term="LeetCode" scheme="https://accepted.org.cn/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/%E7%AE%97%E6%B3%95/LeetCode/"/>
    
      <category term="竞赛" scheme="https://accepted.org.cn/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/%E7%AE%97%E6%B3%95/%E7%AB%9E%E8%B5%9B/"/>
    
      <category term="LeetCode周赛" scheme="https://accepted.org.cn/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/%E7%AE%97%E6%B3%95/%E7%AB%9E%E8%B5%9B/LeetCode%E5%91%A8%E8%B5%9B/"/>
    
      <category term="247" scheme="https://accepted.org.cn/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/%E7%AE%97%E6%B3%95/%E7%AB%9E%E8%B5%9B/LeetCode%E5%91%A8%E8%B5%9B/247/"/>
    
    
      <category term="算法" scheme="https://accepted.org.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="LeetCode" scheme="https://accepted.org.cn/tags/LeetCode/"/>
    
      <category term="竞赛" scheme="https://accepted.org.cn/tags/%E7%AB%9E%E8%B5%9B/"/>
    
      <category term="模拟" scheme="https://accepted.org.cn/tags/%E6%A8%A1%E6%8B%9F/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 1833. 雪糕的最大数量</title>
    <link href="https://accepted.org.cn/2021/07/02/LeetCode-1833-%E9%9B%AA%E7%B3%95%E7%9A%84%E6%9C%80%E5%A4%A7%E6%95%B0%E9%87%8F/"/>
    <id>https://accepted.org.cn/2021/07/02/LeetCode-1833-%E9%9B%AA%E7%B3%95%E7%9A%84%E6%9C%80%E5%A4%A7%E6%95%B0%E9%87%8F/</id>
    <published>2021-07-02T00:41:56.000Z</published>
    <updated>2021-07-02T00:50:12.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>摘要：</strong><br>排序+贪心题。</p><a id="more"></a><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>夏日炎炎，小男孩 Tony 想买一些雪糕消消暑。</p><p>商店中新到 $n$ 支雪糕，用长度为 $n$ 的数组 $costs$ 表示雪糕的定价，其中 $costs[i]$ 表示第 $i$ 支雪糕的现金价格。Tony 一共有 $coins$ 现金可以用于消费，他想要买尽可能多的雪糕。</p><p>给你价格数组 $costs$ 和现金量 $coins$ ，请你计算并返回 Tony 用 $coins$ 现金能够买到的雪糕的 <strong>最大数量</strong> 。</p><p>注意：Tony 可以按任意顺序购买雪糕。</p><p><strong>示例 1：</strong></p><blockquote><p>输入：costs = [1,3,2,4,1], coins = 7<br>输出：4<br>解释：Tony 可以买下标为 0、1、2、4 的雪糕，总价为 1 + 3 + 2 + 1 = 7</p></blockquote><p><strong>示例 2：</strong></p><blockquote><p>输入：costs = [10,6,8,7,7,8], coins = 5<br>输出：0<br>解释：Tony 没有足够的钱买任何一支雪糕。</p></blockquote><p><strong>示例 3：</strong></p><blockquote><p>输入：costs = [1,6,3,1,2,5], coins = 20<br>输出：6<br>解释：Tony 可以买下所有的雪糕，总价为 1 + 6 + 3 + 1 + 2 + 5 = 18 。</p></blockquote><p><strong>提示：</strong></p><ul><li>$costs.length = n$</li><li>$1 &lt;= n &lt;= 10^5$</li><li>$1 &lt;= costs[i] &lt;= 10^5$</li><li>$1 &lt;= coins &lt;= 10^8$</li></ul><hr><h3 id="贪心-计数排序"><a href="#贪心-计数排序" class="headerlink" title="贪心+计数排序"></a>贪心+计数排序</h3><p>因为数组中数值存在一个范围，那么我们可以用计数排序的方法优化排序的复杂度为线性。</p><p>按照价格升序选择雪糕，最终个数一定是最多的。</p><div class="tabs" id="g_tab0"><ul class="nav-tabs"><li class="tab active"><a href="#g_tab0-1">C++</a></li></ul><div class="tab-content"><div class="tab-pane active" id="g_tab0-1"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span> cnt[N];</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxIceCream</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; costs, <span class="keyword">int</span> coins)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = costs.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            cnt[costs[i]]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N &amp;&amp; coins &gt;= i; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (; cnt[i]--;) &#123;</span><br><span class="line">                <span class="keyword">if</span> (coins &gt;= i) &#123;</span><br><span class="line">                    res ++;</span><br><span class="line">                    coins -= i;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div></div></div><div class="note primary">            <p><strong>原题链接：</strong> <a href="https://leetcode-cn.com/problems/maximum-ice-cream-bars/" target="_blank" rel="noopener">LeetCode 1833. 雪糕的最大数量</a></p>          </div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;摘要：&lt;/strong&gt;&lt;br&gt;排序+贪心题。&lt;/p&gt;
    
    </summary>
    
    
      <category term="指尖飞舞" scheme="https://accepted.org.cn/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/"/>
    
      <category term="算法" scheme="https://accepted.org.cn/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/%E7%AE%97%E6%B3%95/"/>
    
      <category term="LeetCode" scheme="https://accepted.org.cn/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/%E7%AE%97%E6%B3%95/LeetCode/"/>
    
    
      <category term="算法" scheme="https://accepted.org.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="LeetCode" scheme="https://accepted.org.cn/tags/LeetCode/"/>
    
      <category term="排序" scheme="https://accepted.org.cn/tags/%E6%8E%92%E5%BA%8F/"/>
    
      <category term="贪心" scheme="https://accepted.org.cn/tags/%E8%B4%AA%E5%BF%83/"/>
    
      <category term="计数排序" scheme="https://accepted.org.cn/tags/%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>LCP 07. 传递信息</title>
    <link href="https://accepted.org.cn/2021/07/01/LCP-07-%E4%BC%A0%E9%80%92%E4%BF%A1%E6%81%AF/"/>
    <id>https://accepted.org.cn/2021/07/01/LCP-07-%E4%BC%A0%E9%80%92%E4%BF%A1%E6%81%AF/</id>
    <published>2021-07-01T05:42:12.000Z</published>
    <updated>2021-07-01T05:51:00.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>摘要：</strong><br>简单深搜题。</p><a id="more"></a><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>小朋友 A 在和 ta 的小伙伴们玩传信息游戏，游戏规则如下：</p><ol><li>有 $n$ 名玩家，所有玩家编号分别为 $0$ ～ $n-1$，其中小朋友 A 的编号为 $0$</li><li>每个玩家都有固定的若干个可传信息的其他玩家（也可能没有）。传信息的关系是单向的（比如 A 可以向 B 传信息，但 B 不能向 A 传信息）。</li><li>每轮信息必须需要传递给另一个人，且信息可重复经过同一个人</li></ol><p>给定总玩家数 $n$，以及按 [玩家编号,对应可传递玩家编号] 关系组成的二维数组 $relation$。返回信息从小 A (编号 $0$ ) 经过 $k$ 轮传递到编号为 $n-1$ 的小伙伴处的方案数；若不能到达，返回 $0$。</p><p><strong>示例 1：</strong></p><blockquote><p>输入：n = 5, relation = [[0,2],[2,1],[3,4],[2,3],[1,4],[2,0],[0,4]], k = 3<br>输出：3<br>解释：信息从小 A 编号 0 处开始，经 3 轮传递，到达编号 4。共有 3 种方案，分别是 0-&gt;2-&gt;0-&gt;4， 0-&gt;2-&gt;1-&gt;4， 0-&gt;2-&gt;3-&gt;4。</p></blockquote><p><strong>示例 2：</strong></p><blockquote><p>输入：n = 3, relation = [[0,2],[2,1]], k = 2<br>输出：0<br>解释：信息不能从小 A 处经过 2 轮传递到编号 2</p></blockquote><p><strong>限制：</strong></p><ul><li>$2 &lt;= n &lt;= 10$</li><li>$1 &lt;= k &lt;= 5$</li><li>$1 &lt;= relation.length &lt;= 90$, 且 $relation[i].length == 2$</li><li>$0 &lt;= relation[i][0],relation[i][1] &lt; n$ 且 $relation[i][0] != relation[i][1]$</li></ul><hr><h3 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h3><div class="tabs" id="g_tab0"><ul class="nav-tabs"><li class="tab active"><a href="#g_tab0-1">C++</a></li></ul><div class="tab-content"><div class="tab-pane active" id="g_tab0-1"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 2021-7-1 13:49:27</span></span><br><span class="line"><span class="comment"> * author: etoa</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">int</span> N = <span class="number">97</span>;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; cnt[N];</span><br><span class="line">    <span class="keyword">int</span> res;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numWays</span><span class="params">(<span class="keyword">int</span> n, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; rela, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = rela.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; each = rela[i];</span><br><span class="line">            cnt[each[<span class="number">0</span>]].push_back(each[<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(n, k, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> &amp;n, <span class="keyword">int</span> &amp;k, <span class="keyword">int</span> u, <span class="keyword">int</span> node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (u == k) &#123;</span><br><span class="line">            <span class="keyword">if</span> (node == n - <span class="number">1</span>)</span><br><span class="line">                res++;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; path = cnt[node];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; path.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> nenode = path[i];</span><br><span class="line">            dfs(n, k, u + <span class="number">1</span>, nenode);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div></div></div><div class="note primary">            <p><strong>原题链接：</strong> <a href="https://leetcode-cn.com/problems/chuan-di-xin-xi/" target="_blank" rel="noopener">LCP 07. 传递信息</a></p>          </div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;摘要：&lt;/strong&gt;&lt;br&gt;简单深搜题。&lt;/p&gt;
    
    </summary>
    
    
      <category term="指尖飞舞" scheme="https://accepted.org.cn/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/"/>
    
      <category term="算法" scheme="https://accepted.org.cn/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/%E7%AE%97%E6%B3%95/"/>
    
      <category term="LeetCode" scheme="https://accepted.org.cn/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/%E7%AE%97%E6%B3%95/LeetCode/"/>
    
    
      <category term="算法" scheme="https://accepted.org.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="LeetCode" scheme="https://accepted.org.cn/tags/LeetCode/"/>
    
      <category term="DFS" scheme="https://accepted.org.cn/tags/DFS/"/>
    
  </entry>
  
  <entry>
    <title>【LeetCode双周赛55】B LeetCode 1910. 删除一个字符串中所有出现的给定子字符串</title>
    <link href="https://accepted.org.cn/2021/06/30/%E3%80%90LeetCode%E5%8F%8C%E5%91%A8%E8%B5%9B55%E3%80%91B-LeetCode-1910-%E5%88%A0%E9%99%A4%E4%B8%80%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E6%89%80%E6%9C%89%E5%87%BA%E7%8E%B0%E7%9A%84%E7%BB%99%E5%AE%9A%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    <id>https://accepted.org.cn/2021/06/30/%E3%80%90LeetCode%E5%8F%8C%E5%91%A8%E8%B5%9B55%E3%80%91B-LeetCode-1910-%E5%88%A0%E9%99%A4%E4%B8%80%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E6%89%80%E6%9C%89%E5%87%BA%E7%8E%B0%E7%9A%84%E7%BB%99%E5%AE%9A%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2/</id>
    <published>2021-06-30T15:23:56.000Z</published>
    <updated>2021-07-05T16:49:46.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>摘要：</strong><br>简单字符串替换。</p><a id="more"></a><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给你两个字符串 $s$ 和 $part$ ，请你对 $s$ 反复执行以下操作直到 <strong>所有</strong> 子字符串 $part$ 都被删除：</p><ul><li>找到 $s$ 中 <strong>最左边</strong> 的子字符串 $part$ ，并将它从 $s$ 中删除。</li></ul><p>请你返回从 $s$ 中删除所有 $part$ 子字符串以后得到的剩余字符串。</p><p>一个 <strong>子字符串</strong> 是一个字符串中连续的字符序列。</p><p><strong>示例 1：</strong></p><blockquote><p>输入：s = “daabcbaabcbc”, part = “abc”<br>输出：”dab”<br>解释：以下操作按顺序执行：</p></blockquote><ul><li>s = “daabcbaabcbc” ，删除下标从 2 开始的 “abc” ，得到 s = “dabaabcbc” 。</li><li>s = “dabaabcbc” ，删除下标从 4 开始的 “abc” ，得到 s = “dababc” 。</li><li>s = “dababc” ，删除下标从 3 开始的 “abc” ，得到 s = “dab” 。<br>此时 s 中不再含有子字符串 “abc” 。</li></ul><p><strong>示例 2：</strong></p><p>输入：s = “axxxxyyyyb”, part = “xy”<br>输出：”ab”<br>解释：以下操作按顺序执行：</p><ul><li>s = “axxxxyyyyb” ，删除下标从 4 开始的 “xy” ，得到 s = “axxxyyyb” 。</li><li>s = “axxxyyyb” ，删除下标从 3 开始的 “xy” ，得到 s = “axxyyb” 。</li><li>s = “axxyyb” ，删除下标从 2 开始的 “xy” ，得到 s = “axyb” 。</li><li>s = “axyb” ，删除下标从 1 开始的 “xy” ，得到 s = “ab” 。<br>此时 s 中不再含有子字符串 “xy” 。</li></ul><p><strong>提示：</strong></p><ul><li>$1 &lt;= s.length &lt;= 1000$</li><li>$1 &lt;= part.length &lt;= 1000$</li><li>$s$​​​​​​ 和 $part$ 只包小写英文字母。</li></ul><hr><h3 id="字符串查找替换"><a href="#字符串查找替换" class="headerlink" title="字符串查找替换"></a>字符串查找替换</h3><div class="tabs" id="g_tab0"><ul class="nav-tabs"><li class="tab active"><a href="#g_tab0-1">C++</a></li></ul><div class="tab-content"><div class="tab-pane active" id="g_tab0-1"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">removeOccurrences</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len1 = s.<span class="built_in">size</span>(), len2 = p.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">int</span> idx = s.<span class="built_in">find</span>(p);</span><br><span class="line">            <span class="keyword">if</span> (idx == <span class="number">-1</span>) <span class="keyword">break</span>;</span><br><span class="line">            <span class="built_in">string</span> s1 = s.substr(<span class="number">0</span>, idx), s2 = s.substr(idx + len2);</span><br><span class="line">            s = s1 + s2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div></div></div><div class="note primary">            <p><strong>原题链接：</strong> <a href="https://leetcode-cn.com/problems/remove-all-occurrences-of-a-substring/" target="_blank" rel="noopener">LeetCode 1910. 删除一个字符串中所有出现的给定子字符串</a></p>          </div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;摘要：&lt;/strong&gt;&lt;br&gt;简单字符串替换。&lt;/p&gt;
    
    </summary>
    
    
      <category term="指尖飞舞" scheme="https://accepted.org.cn/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/"/>
    
      <category term="算法" scheme="https://accepted.org.cn/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/%E7%AE%97%E6%B3%95/"/>
    
      <category term="LeetCode" scheme="https://accepted.org.cn/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/%E7%AE%97%E6%B3%95/LeetCode/"/>
    
      <category term="竞赛" scheme="https://accepted.org.cn/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/%E7%AE%97%E6%B3%95/%E7%AB%9E%E8%B5%9B/"/>
    
      <category term="LeetCode双周赛" scheme="https://accepted.org.cn/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/%E7%AE%97%E6%B3%95/%E7%AB%9E%E8%B5%9B/LeetCode%E5%8F%8C%E5%91%A8%E8%B5%9B/"/>
    
      <category term="55" scheme="https://accepted.org.cn/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/%E7%AE%97%E6%B3%95/%E7%AB%9E%E8%B5%9B/LeetCode%E5%8F%8C%E5%91%A8%E8%B5%9B/55/"/>
    
    
      <category term="算法" scheme="https://accepted.org.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="LeetCode" scheme="https://accepted.org.cn/tags/LeetCode/"/>
    
      <category term="字符串" scheme="https://accepted.org.cn/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
      <category term="竞赛" scheme="https://accepted.org.cn/tags/%E7%AB%9E%E8%B5%9B/"/>
    
  </entry>
  
  <entry>
    <title>【LeetCode双周赛55】A LeetCode 1909. 删除一个元素使数组严格递增</title>
    <link href="https://accepted.org.cn/2021/06/30/%E3%80%90LeetCode%E5%8F%8C%E5%91%A8%E8%B5%9B55%E3%80%91A-LeetCode-1909-%E5%88%A0%E9%99%A4%E4%B8%80%E4%B8%AA%E5%85%83%E7%B4%A0%E4%BD%BF%E6%95%B0%E7%BB%84%E4%B8%A5%E6%A0%BC%E9%80%92%E5%A2%9E/"/>
    <id>https://accepted.org.cn/2021/06/30/%E3%80%90LeetCode%E5%8F%8C%E5%91%A8%E8%B5%9B55%E3%80%91A-LeetCode-1909-%E5%88%A0%E9%99%A4%E4%B8%80%E4%B8%AA%E5%85%83%E7%B4%A0%E4%BD%BF%E6%95%B0%E7%BB%84%E4%B8%A5%E6%A0%BC%E9%80%92%E5%A2%9E/</id>
    <published>2021-06-30T14:43:09.000Z</published>
    <updated>2021-07-05T16:49:56.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>摘要：</strong><br>签到题，但是又不那么水，题目质量挺好。</p><a id="more"></a><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给你一个下标从 $0$ 开始的整数数组 $nums$ ，如果 <strong>恰好</strong> 删除 <strong>一个</strong> 元素后，数组 <strong>严格递增</strong> ，那么请你返回 $true$ ，否则返回 $false$ 。如果数组本身已经是严格递增的，请你也返回 $true$ 。</p><p>数组 $nums$ 是 <strong>严格递增</strong> 的定义为：对于任意下标的 $1 &lt;= i &lt; nums.length$ 都满足 $nums[i - 1] &lt; nums[i]$ 。</p><p><strong>示例 1：</strong></p><blockquote><p>输入：nums = [1,2,10,5,7]<br>输出：true<br>解释：从 nums 中删除下标 2 处的 10 ，得到 [1,2,5,7] 。<br>[1,2,5,7] 是严格递增的，所以返回 true 。</p></blockquote><p><strong>示例 2：</strong></p><blockquote><p>输入：nums = [2,3,1,2]<br>输出：false<br>解释：<br>[3,1,2] 是删除下标 0 处元素后得到的结果。<br>[2,1,2] 是删除下标 1 处元素后得到的结果。<br>[2,3,2] 是删除下标 2 处元素后得到的结果。<br>[2,3,1] 是删除下标 3 处元素后得到的结果。<br>没有任何结果数组是严格递增的，所以返回 false 。</p></blockquote><p><strong>示例 3：</strong></p><blockquote><p>输入：nums = [1,1,1]<br>输出：false<br>解释：删除任意元素后的结果都是 [1,1] 。<br>[1,1] 不是严格递增的，所以返回 false 。</p></blockquote><p><strong>示例 4：</strong></p><p>输入：nums = [1,2,3]<br>输出：true<br>解释：[1,2,3] 已经是严格递增的，所以返回 true 。</p><p><strong>提示：</strong></p><ul><li>$2 &lt;= nums.length &lt;= 1000$</li><li>$1 &lt;= nums[i] &lt;= 1000$</li></ul><hr><h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><p>枚举每一位数，剔除后判断剩余数组是否严格单调递增。复杂度 $O(N^2)$, 数组长度最高 $1000$，复杂度是$1000000$ ，可以过掉。</p><div class="tabs" id="g_tab0"><ul class="nav-tabs"><li class="tab active"><a href="#g_tab0-1">C++</a></li></ul><div class="tab-content"><div class="tab-pane active" id="g_tab0-1"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canBeIncreasing</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">-1</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> last = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">bool</span> isgood = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; len; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (j == i) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span> (nums[j] &lt;= last) &#123;</span><br><span class="line">                    isgood = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                last = nums[j];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (isgood) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div></div></div><p>从 <code>-1</code> 开始枚举需要删除的数，<code>-1</code> 表示不删除任何数，判断原数组是否为严格单调递增，太妙了。<br>注意 <code>nums.size()</code> 返回的是一个 <code>unsigned int</code> 类型，需要强转成 <code>int</code> 类型，配合 <code>-1</code>，不然有bug。</p><div class="note primary">            <p><strong>原题链接：</strong> <a href="https://leetcode-cn.com/problems/remove-one-element-to-make-the-array-strictly-increasing/" target="_blank" rel="noopener">LeetCode 1909. 删除一个元素使数组严格递增</a></p>          </div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;摘要：&lt;/strong&gt;&lt;br&gt;签到题，但是又不那么水，题目质量挺好。&lt;/p&gt;
    
    </summary>
    
    
      <category term="指尖飞舞" scheme="https://accepted.org.cn/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/"/>
    
      <category term="算法" scheme="https://accepted.org.cn/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/%E7%AE%97%E6%B3%95/"/>
    
      <category term="LeetCode" scheme="https://accepted.org.cn/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/%E7%AE%97%E6%B3%95/LeetCode/"/>
    
      <category term="竞赛" scheme="https://accepted.org.cn/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/%E7%AE%97%E6%B3%95/%E7%AB%9E%E8%B5%9B/"/>
    
      <category term="LeetCode双周赛" scheme="https://accepted.org.cn/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/%E7%AE%97%E6%B3%95/%E7%AB%9E%E8%B5%9B/LeetCode%E5%8F%8C%E5%91%A8%E8%B5%9B/"/>
    
      <category term="55" scheme="https://accepted.org.cn/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/%E7%AE%97%E6%B3%95/%E7%AB%9E%E8%B5%9B/LeetCode%E5%8F%8C%E5%91%A8%E8%B5%9B/55/"/>
    
    
      <category term="算法" scheme="https://accepted.org.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="LeetCode" scheme="https://accepted.org.cn/tags/LeetCode/"/>
    
      <category term="竞赛" scheme="https://accepted.org.cn/tags/%E7%AB%9E%E8%B5%9B/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 297. 二叉树的序列化与反序列化</title>
    <link href="https://accepted.org.cn/2021/06/30/LeetCode-297-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8E%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"/>
    <id>https://accepted.org.cn/2021/06/30/LeetCode-297-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8E%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/</id>
    <published>2021-06-30T03:18:11.000Z</published>
    <updated>2021-06-30T03:32:42.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>摘要：</strong><br>根据遍历来序列化和反序列化二叉树。</p><a id="more"></a><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>序列化是将一个数据结构或者对象转换为连续的比特位的操作，进而可以将转换后的数据存储在一个文件或者内存中，同时也可以通过网络传输到另一个计算机环境，采取相反方式重构得到原数据。</p><p>请设计一个算法来实现二叉树的序列化与反序列化。这里不限定你的序列 / 反序列化算法执行逻辑，你只需要保证一个二叉树可以被序列化为一个字符串并且将这个字符串反序列化为原始的树结构。</p><p>提示: 输入输出格式与 LeetCode 目前使用的方式一致，详情请参阅 LeetCode 序列化二叉树的格式。你并非必须采取这种方式，你也可以采用其他的方法解决这个问题。</p><p><strong>示例1：</strong></p><p><img src="0.jpg" alt="0x0"></p><blockquote><p>输入：root = [1,2,3,null,null,4,5]<br>输出：[1,2,3,null,null,4,5]</p></blockquote><p><strong>示例 2：</strong></p><blockquote><p>输入：root = []<br>输出：[]</p></blockquote><p><strong>示例 3：</strong></p><blockquote><p>输入：root = [1]<br>输出：[1]</p></blockquote><p><strong>示例 4：</strong></p><blockquote><p>输入：root = [1,2]<br>输出：[1,2]</p></blockquote><p><strong>提示：</strong></p><ul><li>树中结点数在范围 $[0, 104]$ 内</li><li>$-1000 &lt;= Node.val &lt;= 1000$</li></ul><p><strong>树的定义和方法的调用：</strong></p><div class="tabs" id="g_tab0"><ul class="nav-tabs"><li class="tab active"><a href="#g_tab0-1">C++</a></li><li class="tab"><a href="#g_tab0-2">Java</a></li></ul><div class="tab-content"><div class="tab-pane active" id="g_tab0-1"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Your Codec object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment">// Codec codec;</span></span><br><span class="line"><span class="comment">// codec.deserialize(codec.serialize(root));</span></span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="g_tab0-2"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Your Codec object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment">// Codec codec = new Codec();</span></span><br><span class="line"><span class="comment">// codec.deserialize(codec.serialize(root));</span></span><br></pre></td></tr></table></figure></div></div></div><h3 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h3><p>在看这道题前，请回顾一下 <a href="https://eetoa.github.io/2021/02/23/剑指Offer-07-重建二叉树/" target="_blank" rel="noopener">剑指Offer 07. 重建二叉树</a>.<br>在上面这道题中，为了反序列化一颗二叉树，我们需要前序遍历序列和中序遍历序列，当这两个序列不包含原树的空节点。<br>如果给定一个包含原树空节点的前序遍历序列，我们就可以直接反序列化这颗二叉树。</p><p>另外这道题注意节点值的负数情况。</p><div class="tabs" id="g_tab1"><ul class="nav-tabs"><li class="tab active"><a href="#g_tab1-1">C++</a></li></ul><div class="tab-content"><div class="tab-pane active" id="g_tab1-1"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Codec</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">string</span> path;</span><br><span class="line">    <span class="comment">// Encodes a tree to a single string.</span></span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">serialize</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        dfs_s(root);</span><br><span class="line">        <span class="keyword">return</span> path;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs_s</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) path += <span class="string">"#,"</span>;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            path += to_string(root-&gt;val) + <span class="string">','</span>;</span><br><span class="line">            dfs_s(root-&gt;left);</span><br><span class="line">            dfs_s(root-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Decodes your encoded data to tree.</span></span><br><span class="line">    <span class="function">TreeNode* <span class="title">deserialize</span><span class="params">(<span class="built_in">string</span> data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> u = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> dfs_d(data, u);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">TreeNode* <span class="title">dfs_d</span><span class="params">(<span class="built_in">string</span>&amp; data, <span class="keyword">int</span>&amp; u)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (data[u] == <span class="string">'#'</span>) &#123;</span><br><span class="line">            u += <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> k = u;</span><br><span class="line">            <span class="keyword">while</span> (data[u] != <span class="string">','</span>) u ++ ;</span><br><span class="line">            <span class="keyword">auto</span> root = <span class="keyword">new</span> TreeNode(stoi(data.substr(k, u - k)));</span><br><span class="line">            u ++ ;</span><br><span class="line">            root-&gt;left = dfs_d(data, u);</span><br><span class="line">            root-&gt;right = dfs_d(data, u);</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div></div></div><div class="note primary">            <p><strong>原题链接：</strong> <a href="https://leetcode-cn.com/problems/serialize-and-deserialize-binary-tree/submissions/" target="_blank" rel="noopener">LeetCode 297. 二叉树的序列化与反序列化</a></p>          </div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;摘要：&lt;/strong&gt;&lt;br&gt;根据遍历来序列化和反序列化二叉树。&lt;/p&gt;
    
    </summary>
    
    
      <category term="指尖飞舞" scheme="https://accepted.org.cn/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/"/>
    
      <category term="算法" scheme="https://accepted.org.cn/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/%E7%AE%97%E6%B3%95/"/>
    
      <category term="LeetCode" scheme="https://accepted.org.cn/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/%E7%AE%97%E6%B3%95/LeetCode/"/>
    
    
      <category term="算法" scheme="https://accepted.org.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="LeetCode" scheme="https://accepted.org.cn/tags/LeetCode/"/>
    
      <category term="DFS" scheme="https://accepted.org.cn/tags/DFS/"/>
    
      <category term="树" scheme="https://accepted.org.cn/tags/%E6%A0%91/"/>
    
      <category term="二叉树" scheme="https://accepted.org.cn/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
</feed>
