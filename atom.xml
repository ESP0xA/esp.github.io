<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Dirac Sea</title>
  
  <subtitle>where the water tastes like wine</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://accepted.org.cn/"/>
  <updated>2021-08-01T14:05:40.559Z</updated>
  <id>https://accepted.org.cn/</id>
  
  <author>
    <name>etoa</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>LeetCode 14. 最长公共前缀</title>
    <link href="https://accepted.org.cn/2021/08/01/LeetCode-14-%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%89%8D%E7%BC%80/"/>
    <id>https://accepted.org.cn/2021/08/01/LeetCode-14-%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%89%8D%E7%BC%80/</id>
    <published>2021-08-01T13:56:54.000Z</published>
    <updated>2021-08-01T14:05:40.559Z</updated>
    
    <content type="html"><![CDATA[<p><strong>摘要：</strong><br>很简单的模拟题，如果换成公共子序列那就复杂了。 </p><a id="more"></a><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>编写一个函数来查找字符串数组中的最长公共前缀。</p><p>如果不存在公共前缀，返回空字符串 <code>&quot;&quot;</code>。</p><p><strong>示例 1：</strong></p><p>输入：strs = [“flower”,”flow”,”flight”]<br>输出：”fl”</p><p><strong>示例 2：</strong></p><p>输入：strs = [“dog”,”racecar”,”car”]<br>输出：””<br>解释：输入不存在公共前缀。</p><p><strong>提示：</strong></p><ul><li>$0 &lt;= strs.length &lt;= 200$</li><li>$0 &lt;= strs[i].length &lt;= 200$</li><li>$strs[i]$ 仅由小写英文字母组成</li></ul><h3 id="按列比较"><a href="#按列比较" class="headerlink" title="按列比较"></a>按列比较</h3><p>可以拿第一个字符串作为比较对象，维护一个单指针，当单指针超出第一个字符串的下标范围则可以认为第一个字符串就是所有字符串中最短的，且是公共前缀；<br>否则拿当前指针指向的第一个字符串的字符和所有字符串该位置的字符比较，一旦出现不匹配的情况那到此为指针前面的所有前缀串就是最长公共子串。</p><div class="tabs" id="g_tab0"><ul class="nav-tabs"><li class="tab active"><a href="#g_tab0-1">C++</a></li><li class="tab"><a href="#g_tab0-2">Java</a></li></ul><div class="tab-content"><div class="tab-pane active" id="g_tab0-1"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">longestCommonPrefix</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; ss)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = ss.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (!n) <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        <span class="built_in">string</span> res;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= ss[<span class="number">0</span>].<span class="built_in">size</span>()) &#123;</span><br><span class="line">                <span class="keyword">return</span> ss[<span class="number">0</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">char</span> c = ss[<span class="number">0</span>][i];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (ss[j][i] != c) &#123;</span><br><span class="line">                    <span class="keyword">return</span> res;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            res += c;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="g_tab0-2"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">longestCommonPrefix</span><span class="params">(String[] ss)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = ss.length;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        StringBuilder res = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= ss[<span class="number">0</span>].length()) <span class="keyword">return</span> ss[<span class="number">0</span>];    <span class="comment">// 第一个字符串在所有串中最短</span></span><br><span class="line">            <span class="keyword">char</span> c = ss[<span class="number">0</span>].charAt(i);</span><br><span class="line">            <span class="keyword">for</span> (String s : ss) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i &gt;= s.length() || s.charAt(i) != c) <span class="keyword">return</span> res.toString();</span><br><span class="line">            &#125;</span><br><span class="line">            res.append(c);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div></div><div class="note primary">            <p><strong>原题链接：</strong> <a href="https://leetcode-cn.com/problems/longest-common-prefix/" target="_blank" rel="noopener">LeetCode 14. 最长公共前缀</a></p>          </div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;摘要：&lt;/strong&gt;&lt;br&gt;很简单的模拟题，如果换成公共子序列那就复杂了。 &lt;/p&gt;
    
    </summary>
    
    
      <category term="指尖飞舞" scheme="https://accepted.org.cn/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/"/>
    
      <category term="算法" scheme="https://accepted.org.cn/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/%E7%AE%97%E6%B3%95/"/>
    
      <category term="LeetCode" scheme="https://accepted.org.cn/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/%E7%AE%97%E6%B3%95/LeetCode/"/>
    
    
      <category term="算法" scheme="https://accepted.org.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="LeetCode" scheme="https://accepted.org.cn/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>b-1面试题总结-Java基础</title>
    <link href="https://accepted.org.cn/2021/08/01/b-1%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93-Java%E5%9F%BA%E7%A1%80/"/>
    <id>https://accepted.org.cn/2021/08/01/b-1%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93-Java%E5%9F%BA%E7%A1%80/</id>
    <published>2021-08-01T13:14:51.098Z</published>
    <updated>2021-04-22T13:26:14.353Z</updated>
    
    <content type="html"><![CDATA[<hr><p><strong>摘要：</strong><br>在原作基础上添加学习笔记。</p><a id="more"></a><h1 id="二-Java-基础-集合-多线程-JVM"><a href="#二-Java-基础-集合-多线程-JVM" class="headerlink" title="二 Java 基础+集合+多线程+JVM"></a>二 Java 基础+集合+多线程+JVM</h1><blockquote><p>作者：Guide 哥。</p><p><strong>介绍:</strong> Github 90k Star 项目 <strong><a href="https://github.com/Snailclimb/JavaGuide" target="_blank" rel="noopener">JavaGuide</a></strong>（公众号同名） 作者。每周都会在公众号更新一些自己原创干货。公众号后台回复“1”领取 Java 工程师必备学习资料+面试突击 pdf。</p></blockquote><h2 id="2-1-Java-基础"><a href="#2-1-Java-基础" class="headerlink" title="2.1. Java 基础"></a>2.1. Java 基础</h2><h3 id="2-1-1-面向对象和面向过程的区别"><a href="#2-1-1-面向对象和面向过程的区别" class="headerlink" title="2.1.1. 面向对象和面向过程的区别"></a>2.1.1. 面向对象和面向过程的区别</h3><ul><li><strong>面向过程</strong> ：<strong>面向过程性能比面向对象高。</strong> 因为类调用时需要实例化，开销比较大，比较消耗资源，所以当性能是最重要的考量因素的时候，比如单片机、嵌入式开发、Linux/Unix 等一般采用面向过程开发。但是，<strong>面向过程没有面向对象易维护、易复用、易扩展。</strong></li><li><strong>面向对象</strong> ：<strong>面向对象易维护、易复用、易扩展。</strong> 因为面向对象有封装、继承、多态性的特性，所以可以设计出低耦合的系统，使系统更加灵活、更加易于维护。但是，<strong>面向对象性能比面向过程低</strong>。</li></ul><p>参见 issue : <a href="https://github.com/Snailclimb/JavaGuide/issues/431" target="_blank" rel="noopener">面向过程 ：面向过程性能比面向对象高？？</a></p><blockquote><p>这个并不是根本原因，面向过程也需要分配内存，计算内存偏移量，Java 性能差的主要原因并不是因为它是面向对象语言，而是 Java 是半编译语言，最终的执行代码并不是可以直接被 CPU 执行的二进制机械码。</p><p>而面向过程语言大多都是直接编译成机械码在电脑上执行，并且其它一些面向过程的脚本语言性能也并不一定比 Java 好。</p></blockquote><h3 id="2-1-2-Java-语言有哪些特点"><a href="#2-1-2-Java-语言有哪些特点" class="headerlink" title="2.1.2. Java 语言有哪些特点?"></a>2.1.2. Java 语言有哪些特点?</h3><ol><li>简单易学；</li><li>面向对象（封装，继承，多态）；</li><li>平台无关性（ Java 虚拟机实现平台无关性）；</li><li>可靠性；</li><li>安全性；</li><li>支持多线程（ C++ 语言没有内置的多线程机制，因此必须调用操作系统的多线程功能来进行多线程程序设计，而 Java 语言却提供了多线程支持）；</li><li>支持网络编程并且很方便（ Java 语言诞生本身就是为简化网络编程设计的，因此 Java 语言不仅支持网络编程而且很方便）；</li><li>编译与解释并存；</li></ol><blockquote><p>修正（参见： <a href="https://github.com/Snailclimb/JavaGuide/issues/544" target="_blank" rel="noopener">issue#544</a>）：C++11 开始（2011 年的时候）,C++就引入了多线程库，在 windows、linux、macos 都可以使用<code>std::thread</code>和<code>std::async</code>来创建线程。参考链接：<a href="http://www.cplusplus.com/reference/thread/thread/?kw=thread" target="_blank" rel="noopener">http://www.cplusplus.com/reference/thread/thread/?kw=thread</a></p></blockquote><h3 id="2-1-3-关于-JVM-JDK-和-JRE-最详细通俗的解答"><a href="#2-1-3-关于-JVM-JDK-和-JRE-最详细通俗的解答" class="headerlink" title="2.1.3. 关于 JVM JDK 和 JRE 最详细通俗的解答"></a>2.1.3. 关于 JVM JDK 和 JRE 最详细通俗的解答</h3><h4 id="2-1-3-1-JVM"><a href="#2-1-3-1-JVM" class="headerlink" title="2.1.3.1. JVM"></a>2.1.3.1. JVM</h4><p>Java 虚拟机（JVM）是运行 Java 字节码的虚拟机。JVM 有针对不同系统的特定实现（Windows，Linux，macOS），目的是使用相同的字节码，它们都会给出相同的结果。</p><p><strong>什么是字节码?采用字节码的好处是什么?</strong></p><blockquote><p>在 Java 中，JVM 可以理解的代码就叫做<code>字节码</code>（即扩展名为 <code>.class</code> 的文件），它不面向任何特定的处理器，只面向虚拟机。Java 语言通过字节码的方式，在一定程度上解决了传统解释型语言执行效率低的问题，同时又保留了解释型语言可移植的特点。所以 Java 程序运行时比较高效，而且，由于字节码并不针对一种特定的机器，因此，Java 程序无须重新编译便可在多种不同操作系统的计算机上运行。</p></blockquote><p><strong>Java 程序从源代码到运行一般有下面 3 步：</strong></p><p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/Java%20%E7%A8%8B%E5%BA%8F%E8%BF%90%E8%A1%8C%E8%BF%87%E7%A8%8B.png" alt="Java程序运行过程"></p><p>我们需要格外注意的是 .class-&gt;机器码 这一步。在这一步 JVM 类加载器首先加载字节码文件，然后通过解释器逐行解释执行，这种方式的执行速度会相对比较慢。而且，有些方法和代码块是经常需要被调用的(也就是所谓的热点代码)，所以后面引进了 JIT 编译器，而 JIT 属于运行时编译。<u>当 JIT 编译器完成第一次编译后，其会将字节码对应的机器码保存下来，下次可以直接使用。而我们知道，机器码的运行效率肯定是高于 Java 解释器的。这也解释了我们为什么经常会说 Java 是 <strong>编译与解释共存</strong> 的语言。</u></p><blockquote><p>Q: 编译什么？解释什么？</p></blockquote><blockquote><p>HotSpot 采用了惰性评估(Lazy Evaluation)的做法，根据二八定律，消耗大部分系统资源的只有那一小部分的代码（热点代码），而这也就是 JIT 所需要编译的部分。JVM 会根据代码每次被执行的情况收集信息并相应地做出一些优化，因此执行的次数越多，它的速度就越快。JDK 9 引入了一种新的编译模式 AOT(Ahead of Time Compilation)，它是直接将字节码编译成机器码，这样就避免了 JIT 预热等各方面的开销。JDK 支持分层编译和 AOT 协作使用。但是 ，AOT 编译器的编译质量是肯定比不上 JIT 编译器的。</p></blockquote><p><strong>总结：</strong></p><p>Java 虚拟机（JVM）是运行 Java 字节码的虚拟机。JVM 有针对不同系统的特定实现（Windows，Linux，macOS），目的是使用相同的字节码，它们都会给出相同的结果。字节码和不同系统的 JVM 实现是 Java 语言“一次编译，随处可以运行”的关键所在。</p><h4 id="2-1-3-2-JDK-和-JRE"><a href="#2-1-3-2-JDK-和-JRE" class="headerlink" title="2.1.3.2. JDK 和 JRE"></a>2.1.3.2. JDK 和 JRE</h4><p>JDK 是 Java Development Kit，它是功能齐全的 Java SDK。它拥有 JRE 所拥有的一切，还有编译器（javac）和工具（如 javadoc 和 jdb）。它能够创建和编译程序。</p><p>JRE 是 Java 运行时环境。它是运行已编译 Java 程序所需的所有内容的集合，包括 Java 虚拟机（JVM），Java 类库，java 命令和其他的一些基础构件。但是，它不能用于创建新程序。</p><p>如果你只是为了运行一下 Java 程序的话，那么你只需要安装 JRE 就可以了。如果你需要进行一些 Java 编程方面的工作，那么你就需要安装 JDK 了。但是，这不是绝对的。有时，即使您不打算在计算机上进行任何 Java 开发，仍然需要安装 JDK。例如，如果要使用 JSP 部署 Web 应用程序，那么从技术上讲，您只是在应用程序服务器中运行 Java 程序。那你为什么需要 JDK 呢？因为应用程序服务器会将 JSP 转换为 Java servlet，并且需要使用 JDK 来编译 servlet。</p><h3 id="2-1-4-Oracle-JDK-和-OpenJDK-的对比"><a href="#2-1-4-Oracle-JDK-和-OpenJDK-的对比" class="headerlink" title="2.1.4. Oracle JDK 和 OpenJDK 的对比"></a>2.1.4. Oracle JDK 和 OpenJDK 的对比</h3><p>可能在看这个问题之前很多人和我一样并没有接触和使用过 OpenJDK 。那么 Oracle 和 OpenJDK 之间是否存在重大差异？下面我通过收集到的一些资料，为你解答这个被很多人忽视的问题。</p><p>对于 Java 7，没什么关键的地方。OpenJDK 项目主要基于 Sun 捐赠的 HotSpot 源代码。此外，OpenJDK 被选为 Java 7 的参考实现，由 Oracle 工程师维护。关于 JVM，JDK，JRE 和 OpenJDK 之间的区别，Oracle 博客帖子在 2012 年有一个更详细的答案：</p><blockquote><p>问：OpenJDK 存储库中的源代码与用于构建 Oracle JDK 的代码之间有什么区别？</p><p>答：非常接近 - 我们的 Oracle JDK 版本构建过程基于 OpenJDK 7 构建，只添加了几个部分，例如部署代码，其中包括 Oracle 的 Java 插件和 Java WebStart 的实现，以及一些封闭的源代码派对组件，如图形光栅化器，一些开源的第三方组件，如 Rhino，以及一些零碎的东西，如附加文档或第三方字体。展望未来，我们的目的是开源 Oracle JDK 的所有部分，除了我们考虑商业功能的部分。</p></blockquote><p><strong>总结：</strong></p><ol><li>Oracle JDK 大概每 6 个月发一次主要版本，而 OpenJDK 版本大概每三个月发布一次。但这不是固定的，我觉得了解这个没啥用处。详情参见：<a href="https://blogs.oracle.com/java-platform-group/update-and-faq-on-the-java-se-release-cadence。" target="_blank" rel="noopener">https://blogs.oracle.com/java-platform-group/update-and-faq-on-the-java-se-release-cadence。</a></li><li>OpenJDK 是一个参考模型并且是完全开源的，而 Oracle JDK 是 OpenJDK 的一个实现，并不是完全开源的；</li><li>Oracle JDK 比 OpenJDK 更稳定。OpenJDK 和 Oracle JDK 的代码几乎相同，但 Oracle JDK 有更多的类和一些错误修复。因此，如果您想开发企业/商业软件，我建议您选择 Oracle JDK，因为它经过了彻底的测试和稳定。某些情况下，有些人提到在使用 OpenJDK 可能会遇到了许多应用程序崩溃的问题，但是，只需切换到 Oracle JDK 就可以解决问题；</li><li>在响应性和 JVM 性能方面，Oracle JDK 与 OpenJDK 相比提供了更好的性能；</li><li>Oracle JDK 不会为即将发布的版本提供长期支持，用户每次都必须通过更新到最新版本获得支持来获取最新版本；</li><li>Oracle JDK 根据二进制代码许可协议获得许可，而 OpenJDK 根据 GPL v2 许可获得许可。</li></ol><h3 id="2-1-5-Java-和-C-的区别"><a href="#2-1-5-Java-和-C-的区别" class="headerlink" title="2.1.5. Java 和 C++的区别?"></a>2.1.5. Java 和 C++的区别?</h3><p>我知道很多人没学过 C++，但是面试官就是没事喜欢拿咱们 Java 和 C++ 比呀！没办法！！！就算没学过 C++，也要记下来！</p><ul><li>都是面向对象的语言，都支持封装、继承和多态</li><li>Java 不提供指针来直接访问内存，程序内存更加安全</li><li>Java 的类是单继承的，C++ 支持多重继承；虽然 Java 的类不可以多继承，但是接口可以多继承。</li><li>Java 有自动内存管理机制，不需要程序员手动释放无用内存</li><li><strong>在 C 语言中，字符串或字符数组最后都会有一个额外的字符‘\0’来表示结束。但是，Java 语言中没有结束符这一概念。</strong> 这是一个值得深度思考的问题，具体原因推荐看这篇文章： <a href="https://blog.csdn.net/sszgg2006/article/details/49148189" target="_blank" rel="noopener">https://blog.csdn.net/sszgg2006/article/details/49148189</a><blockquote><p>Q: 为什么Java语言中字符串末尾不需要结束符？</p></blockquote></li></ul><h3 id="2-1-6-字符型常量和字符串常量的区别"><a href="#2-1-6-字符型常量和字符串常量的区别" class="headerlink" title="2.1.6. 字符型常量和字符串常量的区别?"></a>2.1.6. 字符型常量和字符串常量的区别?</h3><ol><li>形式上: 字符常量是单引号引起的一个字符; 字符串常量是双引号引起的若干个字符</li><li>含义上: 字符常量相当于一个整型值( ASCII 值),可以参加表达式运算; 字符串常量代表一个地址值(该字符串在内存中存放位置)</li><li>占内存大小 字符常量只占 2 个字节; 字符串常量占若干个字节 (<strong>注意： char 在 Java 中占两个字节</strong>)</li></ol><blockquote><p>java 编程思想第四版：2.2.2 节<br><img src="http://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-9-15/86735519.jpg" alt=""></p></blockquote><h3 id="2-1-7-构造器-Constructor-是否可被-override"><a href="#2-1-7-构造器-Constructor-是否可被-override" class="headerlink" title="2.1.7. 构造器 Constructor 是否可被 override?"></a>2.1.7. 构造器 Constructor 是否可被 override?</h3><p>Constructor 不能被 override（重写）,但是可以 overload（重载）,所以你可以看到一个类中有多个构造函数的情况。</p><h3 id="2-1-8-重载和重写的区别"><a href="#2-1-8-重载和重写的区别" class="headerlink" title="2.1.8. 重载和重写的区别"></a>2.1.8. 重载和重写的区别</h3><blockquote><p>重载就是同样的一个方法能够根据输入数据的不同，做出不同的处理</p><p>重写就是当子类继承自父类的相同方法，输入数据一样，但要做出有别于父类的响应时，你就要覆盖父类方法</p></blockquote><p><strong>重载：</strong></p><p>发生在同一个类中，方法名必须相同，参数类型不同、个数不同、顺序不同，方法返回值和访问修饰符可以不同。</p><p>下面是《Java 核心技术》对重载这个概念的介绍：</p><p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/bg/desktopjava%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF-%E9%87%8D%E8%BD%BD.jpg" alt=""></p><p>综上：重载就是同一个类中多个同名方法根据不同的传参来执行不同的逻辑处理。</p><p><strong>重写：</strong></p><p>重写发生在运行期，是子类对父类的允许访问的方法的实现过程进行重新编写。</p><ol><li>返回值类型、方法名、参数列表必须相同，抛出的异常范围小于等于父类，访问修饰符范围大于等于父类。</li><li>如果父类方法访问修饰符为 <code>private/final/static</code> 则子类就不能重写该方法，但是被 static 修饰的方法能够被再次声明。</li><li>构造方法无法被重写</li></ol><p>综上：重写就是子类对父类方法的重新改造，外部样子不能改变，内部逻辑可以改变</p><p>暖心的 Guide 哥最后再来个图表总结一下！</p><table><thead><tr><th align="left">区别点</th><th align="left">重载方法</th><th align="left">重写方法</th></tr></thead><tbody><tr><td align="left">发生范围</td><td align="left">同一个类</td><td align="left">子类</td></tr><tr><td align="left">参数列表</td><td align="left">必须修改</td><td align="left">一定不能修改</td></tr><tr><td align="left">返回类型</td><td align="left">可修改</td><td align="left">子类方法返回值类型应比父类方法返回值类型更小或相等</td></tr><tr><td align="left">异常</td><td align="left">可修改</td><td align="left">子类方法声明抛出的异常类应比父类方法声明抛出的异常类更小或相等；</td></tr><tr><td align="left">访问修饰符</td><td align="left">可修改</td><td align="left">一定不能做更严格的限制（可以降低限制）</td></tr><tr><td align="left">发生阶段</td><td align="left">编译期</td><td align="left">运行期</td></tr></tbody></table><p><strong>方法的重写要遵循“两同两小一大”</strong>（以下内容摘录自《疯狂 Java 讲义》,<a href="https://github.com/Snailclimb/JavaGuide/issues/892" target="_blank" rel="noopener">issue#892</a> ）：</p><ul><li>“两同”即方法名相同、形参列表相同；</li><li>“两小”指的是子类方法返回值类型应比父类方法返回值类型更小或相等，子类方法声明抛出的异常类应比父类方法声明抛出的异常类更小或相等；</li><li>“一大”指的是子类方法的访问权限应比父类方法的访问权限更大或相等。</li></ul><p>⭐️ 关于 <strong>重写的返回值类</strong>型 这里需要额外多说明一下，上面的表述不太清晰准确：如果方法的返回类型是void和基本数据类型，则返回值重写时不可修改。但是如果方法的返回值是引用类型，重写时是可以返回该引用类型的子类的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hero</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">name</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"超级英雄"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SuperMan</span> <span class="keyword">extends</span> <span class="title">Hero</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">name</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"超人"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Hero <span class="title">hero</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Hero();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SuperSuperMan</span> <span class="keyword">extends</span> <span class="title">SuperMan</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">name</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"超级超级英雄"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> SuperMan <span class="title">hero</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> SuperMan();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-1-9-Java-面向对象编程三大特性-封装-继承-多态"><a href="#2-1-9-Java-面向对象编程三大特性-封装-继承-多态" class="headerlink" title="2.1.9. Java 面向对象编程三大特性: 封装 继承 多态"></a>2.1.9. Java 面向对象编程三大特性: 封装 继承 多态</h3><h4 id="2-1-9-1-封装"><a href="#2-1-9-1-封装" class="headerlink" title="2.1.9.1. 封装"></a>2.1.9.1. 封装</h4><p>封装把一个对象的属性私有化，同时提供一些可以被外界访问的属性的方法，如果属性不想被外界访问，我们大可不必提供方法给外界访问。但是如果一个类没有提供给外界访问的方法，那么这个类也没有什么意义了。</p><h4 id="2-1-9-2-继承"><a href="#2-1-9-2-继承" class="headerlink" title="2.1.9.2. 继承"></a>2.1.9.2. 继承</h4><p>继承是使用已存在的类的定义作为基础建立新类的技术，新类的定义可以增加新的数据或新的功能，也可以用父类的功能，但不能选择性地继承父类。通过使用继承我们能够非常方便地复用以前的代码。</p><p><strong>关于继承如下 3 点请记住：</strong></p><ol><li>子类拥有父类对象所有的属性和方法（包括私有属性和私有方法），但是父类中的私有属性和方法子类是无法访问，<strong>只是拥有</strong>。</li><li>子类可以拥有自己属性和方法，即子类可以对父类进行扩展。</li><li>子类可以用自己的方式实现父类的方法。（以后介绍）。</li></ol><h4 id="2-1-9-3-多态"><a href="#2-1-9-3-多态" class="headerlink" title="2.1.9.3. 多态"></a>2.1.9.3. 多态</h4><p>所谓多态就是指程序中定义的引用变量所指向的具体类型和通过该引用变量发出的方法调用在编程时并不确定，而是在程序运行期间才确定，即一个引用变量到底会指向哪个类的实例对象，该引用变量发出的方法调用到底是哪个类中实现的方法，必须在由程序运行期间才能决定。</p><p>在 Java 中有两种形式可以实现多态：继承（多个子类对同一方法的重写）和接口（实现接口并覆盖接口中同一方法）。</p><h3 id="2-1-10-String-StringBuffer-和-StringBuilder-的区别是什么-String-为什么是不可变的"><a href="#2-1-10-String-StringBuffer-和-StringBuilder-的区别是什么-String-为什么是不可变的" class="headerlink" title="2.1.10. String StringBuffer 和 StringBuilder 的区别是什么? String 为什么是不可变的?"></a>2.1.10. String StringBuffer 和 StringBuilder 的区别是什么? String 为什么是不可变的?</h3><p><strong>可变性</strong></p><p>简单的来说：<code>String</code> 类中使用 <code>final</code> 关键字修饰字符数组来保存字符串，<code>private final char value[]</code>，所以 String 对象是不可变的。</p><blockquote><p>补充（来自<a href="https://github.com/Snailclimb/JavaGuide/issues/675" target="_blank" rel="noopener">issue 675</a>）：在 Java 9 之后，String 、<code>StringBuilder</code> 与 <code>StringBuffer</code> 的实现改用 byte 数组存储字符串 <code>private final byte[] value</code></p></blockquote><p>而 <code>StringBuilder</code> 与 <code>StringBuffer</code> 都继承自 <code>AbstractStringBuilder</code> 类，在 <code>AbstractStringBuilder</code> 中也是使用字符数组保存字符串<code>char[]value</code> 但是没有用 <code>final</code> 关键字修饰，所以这两种对象都是可变的。</p><p><code>StringBuilder</code> 与 <code>StringBuffer</code> 的构造方法都是调用父类构造方法也就是 <code>AbstractStringBuilder</code> 实现的，大家可以自行查阅源码。</p><p><code>AbstractStringBuilder.java</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractStringBuilder</span> <span class="keyword">implements</span> <span class="title">Appendable</span>, <span class="title">CharSequence</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The value is used for character storage.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">char</span>[] value;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The count is the number of characters used.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> count;</span><br><span class="line"></span><br><span class="line">    AbstractStringBuilder(<span class="keyword">int</span> capacity) &#123;</span><br><span class="line">        value = <span class="keyword">new</span> <span class="keyword">char</span>[capacity];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><blockquote><p>Q: 为什么String类型是不可变的？<br>Q: 为什么 <code>StringBuffer</code> 是线程安全的？</p></blockquote><p><strong>线程安全性</strong></p><p><code>String</code> 中的对象是不可变的，也就可以理解为常量，线程安全。<code>AbstractStringBuilder</code> 是 <code>StringBuilder</code> 与 <code>StringBuffer</code> 的公共父类，定义了一些字符串的基本操作，如 <code>expandCapacity</code>、<code>append</code>、<code>insert</code>、<code>indexOf</code> 等公共方法。<code>StringBuffer</code> 对方法加了同步锁或者对调用的方法加了同步锁，所以是线程安全的。<code>StringBuilder</code> 并没有对方法进行加同步锁，所以是非线程安全的。</p><p><strong>性能</strong></p><p>每次对 <code>String</code> 类型进行改变的时候，都会生成一个新的 <code>String</code> 对象，然后将指针指向新的 <code>String</code> 对象。<code>StringBuffer</code> 每次都会对 <code>StringBuffer</code> 对象本身进行操作，而不是生成新的对象并改变对象引用。相同情况下使用 <code>StringBuilder</code> 相比使用 <code>StringBuffer</code> 仅能获得 10%~15% 左右的性能提升，但却要冒多线程不安全的风险。</p><p><strong>对于三者使用的总结：</strong></p><ol><li>操作少量的数据: 适用 <code>String</code></li><li>单线程操作字符串缓冲区下操作大量数据: 适用 <code>StringBuilder</code></li><li>多线程操作字符串缓冲区下操作大量数据: 适用 <code>StringBuffer</code></li></ol><h3 id="2-1-11-自动装箱与拆箱"><a href="#2-1-11-自动装箱与拆箱" class="headerlink" title="2.1.11. 自动装箱与拆箱"></a>2.1.11. 自动装箱与拆箱</h3><ul><li><strong>装箱</strong>：将基本类型用它们对应的引用类型包装起来；</li><li><strong>拆箱</strong>：将包装类型转换为基本数据类型；</li></ul><p>更多内容见：<a href="https://www.cnblogs.com/dolphin0520/p/3780005.html" target="_blank" rel="noopener">深入剖析 Java 中的装箱和拆箱</a></p><blockquote><p>Q: 装箱和拆箱底层是怎么实现的？<br>A: 装箱过程是通过调用包装器的 <code>ValueOf</code> 方法实现的；拆箱过程是通过调用包装器的 <code>&lt;int/double/float...&gt;Value</code>实现的。</p></blockquote><h3 id="2-1-12-在一个静态方法内调用一个非静态成员为什么是非法的"><a href="#2-1-12-在一个静态方法内调用一个非静态成员为什么是非法的" class="headerlink" title="2.1.12. 在一个静态方法内调用一个非静态成员为什么是非法的?"></a>2.1.12. 在一个静态方法内调用一个非静态成员为什么是非法的?</h3><p>由于静态方法可以不通过对象进行调用，因此在静态方法里，不能调用其他非静态变量，也不可以访问非静态变量成员。</p><h3 id="2-1-13-在-Java-中定义一个不做事且没有参数的构造方法的作用"><a href="#2-1-13-在-Java-中定义一个不做事且没有参数的构造方法的作用" class="headerlink" title="2.1.13. 在 Java 中定义一个不做事且没有参数的构造方法的作用"></a>2.1.13. 在 Java 中定义一个不做事且没有参数的构造方法的作用</h3><p>Java 程序在执行子类的构造方法之前，如果没有用 <code>super()</code>来调用父类特定的构造方法，则会调用父类中“没有参数的构造方法”。因此，如果父类中只定义了有参数的构造方法，而在子类的构造方法中又没有用 <code>super()</code>来调用父类中特定的构造方法，则编译时将发生错误，因为 Java 程序在父类中找不到没有参数的构造方法可供执行。解决办法是在父类里加上一个不做事且没有参数的构造方法。</p><blockquote><p>Q: 我们知道，如果一个类没有声明构造方法，却可以拥有一个默认的构造方法。那么，为什么还需要定义不带参没有内容的构造方法，以供子类加载呢？<br>A: <del>因为如果类没有定义构造方法，是编译器在将java文件 <strong>编译</strong> 成.class文件的的时候自动为类添加无参构造方法。而子类需要在 <strong>类加载</strong> 的验证阶段检查父类的数据，初始化父类。</del></p></blockquote><h3 id="2-1-14-接口和抽象类的区别是什么？"><a href="#2-1-14-接口和抽象类的区别是什么？" class="headerlink" title="2.1.14. 接口和抽象类的区别是什么？"></a>2.1.14. 接口和抽象类的区别是什么？</h3><ol><li>接口的方法默认是 <code>public</code>，所有方法在接口中不能有实现(Java 8 开始接口方法可以有默认实现），而抽象类可以有非抽象的方法。</li><li>接口中除了 <code>static</code>、<code>final</code> 变量，不能有其他变量，而抽象类中则不一定。</li><li>一个类可以实现多个接口，但只能实现一个抽象类。接口自己本身可以通过 <code>extends</code> 关键字扩展多个接口。</li><li>接口方法默认修饰符是 <code>public</code>，抽象方法可以有 <code>public</code>、<code>protected</code> 和 <code>default</code> 这些修饰符（抽象方法就是为了被重写所以不能使用 <code>private</code> 关键字修饰！）。</li><li>从设计层面来说，抽象是对类的抽象，是一种模板设计，而接口是对行为的抽象，是一种行为的规范。</li></ol><blockquote><p>备注：</p><ol><li>在 JDK8 中，接口也可以定义静态方法，可以直接用接口名调用。实现类和实现是不可以调用的。如果同时实现两个接口，接口中定义了一样的默认方法，则必须重写，不然会报错。(详见 issue:<a href="https://github.com/Snailclimb/JavaGuide/issues/146" target="_blank" rel="noopener">https://github.com/Snailclimb/JavaGuide/issues/146</a>。</li><li>jdk9 的接口被允许定义私有方法 。</li></ol></blockquote><p>总结一下 jdk7~jdk9 Java 中接口概念的变化（<a href="https://www.geeksforgeeks.org/private-methods-java-9-interfaces/" target="_blank" rel="noopener">相关阅读</a>）：</p><ol><li>在 jdk 7 或更早版本中，接口里面只能有常量变量和抽象方法。这些接口方法必须由选择实现接口的类实现。</li><li>jdk 8 的时候接口可以有默认方法和静态方法功能。</li><li>Jdk 9 在接口中引入了私有方法和私有静态方法。</li></ol><h3 id="2-1-15-成员变量与局部变量的区别有哪些？"><a href="#2-1-15-成员变量与局部变量的区别有哪些？" class="headerlink" title="2.1.15. 成员变量与局部变量的区别有哪些？"></a>2.1.15. 成员变量与局部变量的区别有哪些？</h3><ol><li>从语法形式上看:成员变量是属于类的，而局部变量是在方法中定义的变量或是方法的参数；成员变量可以被 <code>public</code>,<code>private</code>,<code>static</code> 等修饰符所修饰，而局部变量不能被访问控制修饰符及 <code>static</code> 所修饰；但是，成员变量和局部变量都能被 <code>final</code> 所修饰。</li><li>从变量在内存中的存储方式来看:如果成员变量是使用<code>static</code>修饰的，那么这个成员变量是属于类的，如果没有使用<code>static</code>修饰，这个成员变量是属于实例的。对象存于堆内存，如果局部变量类型为基本数据类型，那么存储在栈内存，如果为引用数据类型，那存放的是指向堆内存对象的引用或者是指向常量池中的地址。</li><li>从变量在内存中的生存时间上看:成员变量是对象的一部分，它随着对象的创建而存在，而局部变量随着方法的调用而自动消失。</li><li>成员变量如果没有被赋初值:则会自动以类型的默认值而赋值（一种情况例外:被 <code>final</code> 修饰的成员变量也必须显式地赋值），而局部变量则不会自动赋值。</li></ol><h3 id="2-1-16-创建一个对象用什么运算符-对象实体与对象引用有何不同"><a href="#2-1-16-创建一个对象用什么运算符-对象实体与对象引用有何不同" class="headerlink" title="2.1.16. 创建一个对象用什么运算符?对象实体与对象引用有何不同?"></a>2.1.16. 创建一个对象用什么运算符?对象实体与对象引用有何不同?</h3><p>new 运算符，new 创建对象实例（对象实例在堆内存中），对象引用指向对象实例（对象引用存放在栈内存中）。一个对象引用可以指向 0 个或 1 个对象（一根绳子可以不系气球，也可以系一个气球）;一个对象可以有 n 个引用指向它（可以用 n 条绳子系住一个气球）。</p><h3 id="2-1-17-什么是方法的返回值-返回值在类的方法里的作用是什么"><a href="#2-1-17-什么是方法的返回值-返回值在类的方法里的作用是什么" class="headerlink" title="2.1.17. 什么是方法的返回值?返回值在类的方法里的作用是什么?"></a>2.1.17. 什么是方法的返回值?返回值在类的方法里的作用是什么?</h3><p>方法的返回值是指我们获取到的某个方法体中的代码执行后产生的结果！（前提是该方法可能产生结果）。返回值的作用:接收出结果，使得它可以用于其他的操作！</p><h3 id="2-1-18-一个类的构造方法的作用是什么-若一个类没有声明构造方法，该程序能正确执行吗-为什么"><a href="#2-1-18-一个类的构造方法的作用是什么-若一个类没有声明构造方法，该程序能正确执行吗-为什么" class="headerlink" title="2.1.18. 一个类的构造方法的作用是什么? 若一个类没有声明构造方法，该程序能正确执行吗? 为什么?"></a>2.1.18. 一个类的构造方法的作用是什么? 若一个类没有声明构造方法，该程序能正确执行吗? 为什么?</h3><p>主要作用是完成对类对象的初始化工作。可以执行。因为一个类即使没有声明构造方法也会有默认的不带参数的构造方法。</p><h3 id="2-1-19-构造方法有哪些特性？"><a href="#2-1-19-构造方法有哪些特性？" class="headerlink" title="2.1.19. 构造方法有哪些特性？"></a>2.1.19. 构造方法有哪些特性？</h3><ol><li>名字与类名相同。</li><li>没有返回值，但不能用 void 声明构造函数。</li><li>生成类的对象时自动执行，无需调用。</li></ol><h3 id="2-1-20-静态方法和实例方法有何不同"><a href="#2-1-20-静态方法和实例方法有何不同" class="headerlink" title="2.1.20. 静态方法和实例方法有何不同"></a>2.1.20. 静态方法和实例方法有何不同</h3><ol><li><p>在外部调用静态方法时，可以使用”类名.方法名”的方式，也可以使用”对象名.方法名”的方式。而实例方法只有后面这种方式。也就是说，调用静态方法可以无需创建对象。</p></li><li><p>静态方法在访问本类的成员时，只允许访问静态成员（即静态成员变量和静态方法），而不允许访问实例成员变量和实例方法；实例方法则无此限制。</p></li></ol><h3 id="2-1-21-对象的相等与指向他们的引用相等-两者有什么不同"><a href="#2-1-21-对象的相等与指向他们的引用相等-两者有什么不同" class="headerlink" title="2.1.21. 对象的相等与指向他们的引用相等,两者有什么不同?"></a>2.1.21. 对象的相等与指向他们的引用相等,两者有什么不同?</h3><p>对象的相等，比的是内存中存放的内容是否相等。而引用相等，比较的是他们指向的内存地址是否相等。</p><h3 id="2-1-22-在调用子类构造方法之前会先调用父类没有参数的构造方法-其目的是"><a href="#2-1-22-在调用子类构造方法之前会先调用父类没有参数的构造方法-其目的是" class="headerlink" title="2.1.22. 在调用子类构造方法之前会先调用父类没有参数的构造方法,其目的是?"></a>2.1.22. 在调用子类构造方法之前会先调用父类没有参数的构造方法,其目的是?</h3><p>帮助子类做初始化工作。</p><h3 id="2-1-23-与-equals-重要"><a href="#2-1-23-与-equals-重要" class="headerlink" title="2.1.23. == 与 equals(重要)"></a>2.1.23. == 与 equals(重要)</h3><p><strong>==</strong> : 它的作用是判断两个对象的地址是不是相等。即，判断两个对象是不是同一个对象(基本数据类型==比较的是值，引用数据类型==比较的是内存地址)。</p><p><strong>equals()</strong> : 它的作用也是判断两个对象是否相等。但它一般有两种使用情况：</p><ul><li>情况 1：类没有覆盖 equals() 方法。则通过 equals() 比较该类的两个对象时，等价于通过“==”比较这两个对象。</li><li>情况 2：类覆盖了 equals() 方法。一般，我们都覆盖 equals() 方法来比较两个对象的内容是否相等；若它们的内容相等，则返回 true (即，认为这两个对象相等)。</li></ul><p><strong>举个例子：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String a = <span class="keyword">new</span> String(<span class="string">"ab"</span>); <span class="comment">// a 为一个引用</span></span><br><span class="line">        String b = <span class="keyword">new</span> String(<span class="string">"ab"</span>); <span class="comment">// b为另一个引用,对象的内容一样</span></span><br><span class="line">        String aa = <span class="string">"ab"</span>; <span class="comment">// 放在常量池中</span></span><br><span class="line">        String bb = <span class="string">"ab"</span>; <span class="comment">// 从常量池中查找</span></span><br><span class="line">        <span class="keyword">if</span> (aa == bb) <span class="comment">// true</span></span><br><span class="line">            System.out.println(<span class="string">"aa==bb"</span>);</span><br><span class="line">        <span class="keyword">if</span> (a == b) <span class="comment">// false，非同一对象</span></span><br><span class="line">            System.out.println(<span class="string">"a==b"</span>);</span><br><span class="line">        <span class="keyword">if</span> (a.equals(b)) <span class="comment">// true</span></span><br><span class="line">            System.out.println(<span class="string">"aEQb"</span>);</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">42</span> == <span class="number">42.0</span>) &#123; <span class="comment">// true</span></span><br><span class="line">            System.out.println(<span class="string">"true"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>说明：</strong></p><ul><li>String 中的 equals 方法是被重写过的，因为 object 的 equals 方法是比较的对象的内存地址，而 String 的 equals 方法比较的是对象的值。</li><li>当创建 String 类型的对象时，虚拟机会在常量池中查找有没有已经存在的值和要创建的值相同的对象，如果有就把它赋给当前引用。如果没有就在常量池中重新创建一个 String 对象。</li></ul><h3 id="2-1-24-hashCode-与-equals-重要"><a href="#2-1-24-hashCode-与-equals-重要" class="headerlink" title="2.1.24. hashCode 与 equals (重要)"></a>2.1.24. hashCode 与 equals (重要)</h3><p>面试官可能会问你：“你重写过 <code>hashcode</code> 和 <code>equals</code>么，为什么重写 <code>equals</code> 时必须重写 <code>hashCode</code> 方法？”</p><p><strong>1)hashCode()介绍:</strong></p><p><code>hashCode()</code> 的作用是获取哈希码，也称为散列码；它实际上是返回一个 int 整数。这个哈希码的作用是确定该对象在哈希表中的索引位置。<code>hashCode()</code>定义在 JDK 的 <code>Object</code> 类中，这就意味着 Java 中的任何类都包含有 <code>hashCode()</code> 函数。另外需要注意的是： <code>Object</code> 的 hashcode 方法是本地方法，也就是用 c 语言或 c++ 实现的，该方法通常用来将对象的 内存地址 转换为整数之后返回。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>散列表存储的是键值对(key-value)，它的特点是：能根据“键”快速的检索出对应的“值”。这其中就利用到了散列码！（可以快速找到所需要的对象）</p><p><strong>2)为什么要有 hashCode？</strong></p><p>我们以“<code>HashSet</code> 如何检查重复”为例子来说明为什么要有 hashCode？</p><p>当你把对象加入 <code>HashSet</code> 时，<code>HashSet</code> 会先计算对象的 hashcode 值来判断对象加入的位置，同时也会与其他已经加入的对象的 hashcode 值作比较，如果没有相符的 hashcode，<code>HashSet</code> 会假设对象没有重复出现。但是如果发现有相同 hashcode 值的对象，这时会调用 <code>equals()</code> 方法来检查 hashcode 相等的对象是否真的相同。如果两者相同，<code>HashSet</code> 就不会让其加入操作成功。如果不同的话，就会重新散列到其他位置。（摘自我的 Java 启蒙书《Head First Java》第二版）。这样我们就大大减少了 equals 的次数，相应就大大提高了执行速度。</p><p><strong>3)为什么重写 <code>equals</code> 时必须重写 <code>hashCode</code> 方法？</strong></p><p>如果两个对象相等，则 hashcode 一定也是相同的。两个对象相等,对两个对象分别调用 equals 方法都返回 true。但是，两个对象有相同的 hashcode 值，它们也不一定是相等的 。<strong>因此，equals 方法被覆盖过，则 <code>hashCode</code> 方法也必须被覆盖。</strong></p><blockquote><p><code>hashCode()</code>的默认行为是对堆上的对象产生独特值。如果没有重写 <code>hashCode()</code>，则该 class 的两个对象无论如何都不会相等（即使这两个对象指向相同的数据）</p></blockquote><p><strong>4)为什么两个对象有相同的 hashcode 值，它们也不一定是相等的？</strong></p><p>在这里解释一位小伙伴的问题。以下内容摘自《Head Fisrt Java》。</p><p>因为 <code>hashCode()</code> 所使用的杂凑算法也许刚好会让多个对象传回相同的杂凑值。越糟糕的杂凑算法越容易碰撞，但这也与数据值域分布的特性有关（所谓碰撞也就是指的是不同的对象得到相同的 <code>hashCode</code>。</p><p>我们刚刚也提到了 <code>HashSet</code>,如果 <code>HashSet</code> 在对比的时候，同样的 hashcode 有多个对象，它会使用 <code>equals()</code> 来判断是否真的相同。也就是说 <code>hashcode</code> 只是用来缩小查找成本。</p><p>更多关于 <code>hashcode()</code> 和 <code>equals()</code> 的内容可以查看：<a href="https://www.cnblogs.com/skywang12345/p/3324958.html" target="_blank" rel="noopener">Java hashCode() 和 equals()的若干问题解答</a></p><h3 id="2-1-25-为什么-Java-中只有值传递？"><a href="#2-1-25-为什么-Java-中只有值传递？" class="headerlink" title="2.1.25. 为什么 Java 中只有值传递？"></a>2.1.25. 为什么 Java 中只有值传递？</h3><p>首先回顾一下在程序设计语言中有关将参数传递给方法（或函数）的一些专业术语。<strong>按值调用(call by value)表示方法接收的是调用者提供的值，而按引用调用（call by reference)表示方法接收的是调用者提供的变量地址。一个方法可以修改传递引用所对应的变量值，而不能修改传递值调用所对应的变量值。</strong> 它用来描述各种程序设计语言（不只是 Java)中方法参数传递方式。</p><p><strong>Java 程序设计语言总是采用按值调用。也就是说，方法得到的是所有参数值的一个拷贝，也就是说，方法不能修改传递给它的任何参数变量的内容。</strong></p><p><strong>下面通过 3 个例子来给大家说明</strong></p><blockquote><p><strong>example 1</strong></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num1 = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span> num2 = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">    swap(num1, num2);</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">"num1 = "</span> + num1);</span><br><span class="line">    System.out.println(<span class="string">"num2 = "</span> + num2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = temp;</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">"a = "</span> + a);</span><br><span class="line">    System.out.println(<span class="string">"b = "</span> + b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>结果：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a &#x3D; 20</span><br><span class="line">b &#x3D; 10</span><br><span class="line">num1 &#x3D; 10</span><br><span class="line">num2 &#x3D; 20</span><br></pre></td></tr></table></figure><p><strong>解析：</strong></p><p><img src="http://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-9-27/22191348.jpg" alt="example 1 "></p><p>在 swap 方法中，a、b 的值进行交换，并不会影响到 num1、num2。因为，a、b 中的值，只是从 num1、num2 的复制过来的。也就是说，a、b 相当于 num1、num2 的副本，副本的内容无论怎么修改，都不会影响到原件本身。</p><p><strong>通过上面例子，我们已经知道了一个方法不能修改一个基本数据类型的参数，而对象引用作为参数就不一样，请看 example2.</strong></p><blockquote><p><strong>example 2</strong></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span>[] arr = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> &#125;;</span><br><span class="line">System.out.println(arr[<span class="number">0</span>]);</span><br><span class="line">change(arr);</span><br><span class="line">System.out.println(arr[<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 将数组的第一个元素变为0</span></span><br><span class="line">array[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>结果：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">0</span><br></pre></td></tr></table></figure><p><strong>解析：</strong></p><p><img src="http://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-9-27/3825204.jpg" alt="example 2"></p><p>array 被初始化 arr 的拷贝也就是一个对象的引用，也就是说 array 和 arr 指向的是同一个数组对象。 因此，外部对引用对象的改变会反映到所对应的对象上。</p><p><strong>通过 example2 我们已经看到，实现一个改变对象参数状态的方法并不是一件难事。理由很简单，方法得到的是对象引用的拷贝，对象引用及其他的拷贝同时引用同一个对象。</strong></p><p><strong>很多程序设计语言（特别是，C++和 Pascal)提供了两种参数传递的方式：值调用和引用调用。有些程序员（甚至本书的作者）认为 Java 程序设计语言对对象采用的是引用调用，实际上，这种理解是不对的。由于这种误解具有一定的普遍性，所以下面给出一个反例来详细地阐述一下这个问题。</strong></p><blockquote><p><strong>example 3</strong></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">Student s1 = <span class="keyword">new</span> Student(<span class="string">"小张"</span>);</span><br><span class="line">Student s2 = <span class="keyword">new</span> Student(<span class="string">"小李"</span>);</span><br><span class="line">Test.swap(s1, s2);</span><br><span class="line">System.out.println(<span class="string">"s1:"</span> + s1.getName());</span><br><span class="line">System.out.println(<span class="string">"s2:"</span> + s2.getName());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(Student x, Student y)</span> </span>&#123;</span><br><span class="line">Student temp = x;</span><br><span class="line">x = y;</span><br><span class="line">y = temp;</span><br><span class="line">System.out.println(<span class="string">"x:"</span> + x.getName());</span><br><span class="line">System.out.println(<span class="string">"y:"</span> + y.getName());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>结果：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">x:小李</span><br><span class="line">y:小张</span><br><span class="line">s1:小张</span><br><span class="line">s2:小李</span><br></pre></td></tr></table></figure><p><strong>解析：</strong></p><p>交换之前：</p><p><img src="http://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-9-27/88729818.jpg" alt=""></p><p>交换之后：</p><p><img src="http://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-9-27/34384414.jpg" alt=""></p><p>通过上面两张图可以很清晰的看出： <strong>方法并没有改变存储在变量 s1 和 s2 中的对象引用。swap 方法的参数 x 和 y 被初始化为两个对象引用的拷贝，这个方法交换的是这两个拷贝</strong></p><blockquote><p><strong>总结</strong></p></blockquote><p>Java 程序设计语言对对象采用的不是引用调用，实际上，对象引用是按<br>值传递的。</p><p>下面再总结一下 Java 中方法参数的使用情况：</p><ul><li>一个方法不能修改一个基本数据类型的参数（即数值型或布尔型）。</li><li>一个方法可以改变一个对象参数的状态。</li><li>一个方法不能让对象参数引用一个新的对象。</li></ul><p><strong>参考：</strong></p><p>《Java 核心技术卷 Ⅰ》基础知识第十版第四章 4.5 小节</p><h3 id="2-1-26-简述线程、程序、进程的基本概念。以及他们之间关系是什么"><a href="#2-1-26-简述线程、程序、进程的基本概念。以及他们之间关系是什么" class="headerlink" title="2.1.26. 简述线程、程序、进程的基本概念。以及他们之间关系是什么?"></a>2.1.26. 简述线程、程序、进程的基本概念。以及他们之间关系是什么?</h3><p><strong>线程</strong>与进程相似，但线程是一个比进程更小的执行单位。一个进程在其执行的过程中可以产生多个线程。与进程不同的是同类的多个线程共享同一块内存空间和一组系统资源，所以系统在产生一个线程，或是在各个线程之间作切换工作时，负担要比进程小得多，也正因为如此，线程也被称为轻量级进程。</p><p><strong>程序</strong>是含有指令和数据的文件，被存储在磁盘或其他的数据存储设备中，也就是说程序是静态的代码。</p><p><strong>进程</strong>是程序的一次执行过程，是系统运行程序的基本单位，因此进程是动态的。系统运行一个程序即是一个进程从创建，运行到消亡的过程。简单来说，一个进程就是一个执行中的程序，它在计算机中一个指令接着一个指令地执行着，同时，每个进程还占有某些系统资源如 CPU 时间，内存空间，文件，输入输出设备的使用权等等。换句话说，当程序在执行时，将会被操作系统载入内存中。<br>线程是进程划分成的更小的运行单位。线程和进程最大的不同在于基本上各进程是独立的，而各线程则不一定，因为同一进程中的线程极有可能会相互影响。从另一角度来说，进程属于操作系统的范畴，主要是同一段时间内，可以同时执行一个以上的程序，而线程则是在同一程序内几乎同时执行一个以上的程序段。</p><h3 id="2-1-27-线程有哪些基本状态"><a href="#2-1-27-线程有哪些基本状态" class="headerlink" title="2.1.27. 线程有哪些基本状态?"></a>2.1.27. 线程有哪些基本状态?</h3><p>Java 线程在运行的生命周期中的指定时刻只可能处于下面 6 种不同状态的其中一个状态（图源《Java 并发编程艺术》4.1.4 节）。</p><p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/19-1-29/Java%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%8A%B6%E6%80%81.png" alt="Java线程的状态"></p><p>线程在生命周期中并不是固定处于某一个状态而是随着代码的执行在不同状态之间切换。Java 线程状态变迁如下图所示（图源《Java 并发编程艺术》4.1.4 节）：</p><p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/19-1-29/Java%20%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81%E5%8F%98%E8%BF%81.png" alt="Java线程状态变迁"></p><p>由上图可以看出：</p><p>线程创建之后它将处于 <strong>NEW（新建）</strong> 状态，调用 <code>start()</code> 方法后开始运行，线程这时候处于 <strong>READY（可运行）</strong> 状态。可运行状态的线程获得了 cpu 时间片（timeslice）后就处于 <strong>RUNNING（运行）</strong> 状态。</p><blockquote><p>操作系统隐藏 Java 虚拟机（JVM）中的 READY 和 RUNNING 状态，它只能看到 RUNNABLE 状态（图源：<a href="https://howtodoinjava.com/" target="_blank" rel="noopener">HowToDoInJava</a>：<a href="https://howtodoinjava.com/java/multi-threading/java-thread-life-cycle-and-thread-states/" target="_blank" rel="noopener">Java Thread Life Cycle and Thread States</a>），所以 Java 系统一般将这两个状态统称为 <strong>RUNNABLE（运行中）</strong> 状态 。</p></blockquote><p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-3/RUNNABLE-VS-RUNNING.png" alt="RUNNABLE-VS-RUNNING"></p><p>当线程执行 <code>wait()</code>方法之后，线程进入 <strong>WAITING（等待）</strong>状态。进入等待状态的线程需要依靠其他线程的通知才能够返回到运行状态，而 <strong>TIME_WAITING(超时等待)</strong> 状态相当于在等待状态的基础上增加了超时限制，比如通过 <code>sleep（long millis）</code>方法或 <code>wait（long millis）</code>方法可以将 Java 线程置于 TIMED WAITING 状态。当超时时间到达后 Java 线程将会返回到 RUNNABLE 状态。当线程调用同步方法时，在没有获取到锁的情况下，线程将会进入到 <strong>BLOCKED（阻塞）</strong> 状态。线程在执行 Runnable 的<code>run()</code>方法之后将会进入到 <strong>TERMINATED（终止）</strong> 状态。</p><h3 id="2-1-28-关于-final-关键字的一些总结"><a href="#2-1-28-关于-final-关键字的一些总结" class="headerlink" title="2.1.28. 关于 final 关键字的一些总结"></a>2.1.28. 关于 final 关键字的一些总结</h3><p>final 关键字主要用在三个地方：变量、方法、类。</p><ol><li>对于一个 final 变量，如果是基本数据类型的变量，则其数值一旦在初始化之后便不能更改；如果是引用类型的变量，则在对其初始化之后便不能再让其指向另一个对象。</li><li>当用 final 修饰一个类时，表明这个类不能被继承。final 类中的所有成员方法都会被隐式地指定为 final 方法。</li><li>使用 final 方法的原因有两个。第一个原因是把方法锁定，以防任何继承类修改它的含义；第二个原因是效率。在早期的 Java 实现版本中，会将 final 方法转为内嵌调用。但是如果方法过于庞大，可能看不到内嵌调用带来的任何性能提升（现在的 Java 版本已经不需要使用 final 方法进行这些优化了）。类中所有的 private 方法都隐式地指定为 final。</li></ol><h3 id="2-1-29-Java-中的异常处理"><a href="#2-1-29-Java-中的异常处理" class="headerlink" title="2.1.29. Java 中的异常处理"></a>2.1.29. Java 中的异常处理</h3><h4 id="2-1-29-1-Java-异常类层次结构图"><a href="#2-1-29-1-Java-异常类层次结构图" class="headerlink" title="2.1.29.1. Java 异常类层次结构图"></a>2.1.29.1. Java 异常类层次结构图</h4><p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/2020-12/Java%E5%BC%82%E5%B8%B8%E7%B1%BB%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84%E5%9B%BE.png" alt=""></p><p style="font-size:13px;text-align:right">图片来自：https://simplesnippets.tech/exception-handling-in-java-part-1/</p><p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/2020-12/Java%E5%BC%82%E5%B8%B8%E7%B1%BB%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84%E5%9B%BE2.png" alt=""></p><p style="font-size:13px;text-align:right">图片来自：https://chercher.tech/java-programming/exceptions-java</p><p>在 Java 中，所有的异常都有一个共同的祖先 <code>java.lang</code> 包中的 <code>Throwable</code> 类。<code>Throwable</code> 类有两个重要的子类 <code>Exception</code>（异常）和 <code>Error</code>（错误）。<code>Exception</code> 能被程序本身处理(<code>try-catch</code>)， <code>Error</code> 是无法处理的(只能尽量避免)。</p><p><code>Exception</code> 和 <code>Error</code> 二者都是 Java 异常处理的重要子类，各自都包含大量子类。</p><ul><li><strong><code>Exception</code></strong> :程序本身可以处理的异常，可以通过 <code>catch</code> 来进行捕获。<code>Exception</code> 又可以分为 受检查异常(必须处理) 和 不受检查异常(可以不处理)。</li><li><strong><code>Error</code></strong> ：<code>Error</code> 属于程序无法处理的错误 ，我们没办法通过 <code>catch</code> 来进行捕获 。例如，Java 虚拟机运行错误（<code>Virtual MachineError</code>）、虚拟机内存不够错误(<code>OutOfMemoryError</code>)、类定义错误（<code>NoClassDefFoundError</code>）等 。这些异常发生时，Java 虚拟机（JVM）一般会选择线程终止。</li></ul><p><strong>受检查异常</strong></p><p>Java 代码在编译过程中，如果受检查异常没有被 <code>catch</code>/<code>throw</code> 处理的话，就没办法通过编译 。比如下面这段 IO 操作的代码。</p><p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/2020-12/check-exception.png" alt="check-exception"></p><p>除了<code>RuntimeException</code>及其子类以外，其他的<code>Exception</code>类及其子类都属于检查异常 。常见的受检查异常有： IO 相关的异常、<code>ClassNotFoundException</code> 、<code>SQLException</code>…。</p><p><strong>不受检查异常</strong></p><p>Java 代码在编译过程中 ，我们即使不处理不受检查异常也可以正常通过编译。</p><p><code>RuntimeException</code> 及其子类都统称为非受检查异常，例如：<code>NullPoin​terException</code>、<code>NumberFormatException</code>（字符串转换为数字）、<code>ArrayIndexOutOfBoundsException</code>（数组越界）、<code>ClassCastException</code>（类型转换错误）、<code>ArithmeticException</code>（算术错误）等。</p><h4 id="2-1-29-2-Throwable-类常用方法"><a href="#2-1-29-2-Throwable-类常用方法" class="headerlink" title="2.1.29.2. Throwable 类常用方法"></a>2.1.29.2. Throwable 类常用方法</h4><ul><li><strong><code>public string getMessage()</code></strong>:返回异常发生时的简要描述</li><li><strong><code>public string toString()</code></strong>:返回异常发生时的详细信息</li><li><strong><code>public string getLocalizedMessage()</code></strong>:返回异常对象的本地化信息。使用 <code>Throwable</code> 的子类覆盖这个方法，可以生成本地化信息。如果子类没有覆盖该方法，则该方法返回的信息与 <code>getMessage（）</code>返回的结果相同</li><li><strong><code>public void printStackTrace()</code></strong>:在控制台上打印 <code>Throwable</code> 对象封装的异常信息</li></ul><h4 id="2-1-29-3-异常处理总结"><a href="#2-1-29-3-异常处理总结" class="headerlink" title="2.1.29.3. 异常处理总结"></a>2.1.29.3. 异常处理总结</h4><ul><li><strong><code>try</code>块：</strong> 用于捕获异常。其后可接零个或多个 <code>catch</code> 块，如果没有 <code>catch</code> 块，则必须跟一个 <code>finally</code> 块。</li><li><strong><code>catch</code>块：</strong> 用于处理 try 捕获到的异常。</li><li><strong><code>finally</code> 块：</strong> 无论是否捕获或处理异常，<code>finally</code> 块里的语句都会被执行。当在 <code>try</code> 块或 <code>catch</code> 块中遇到 <code>return</code> 语句时，<code>finally</code> 语句块将在方法返回之前被执行。</li></ul><p><strong>在以下 3 种特殊情况下，<code>finally</code> 块不会被执行：</strong></p><ol><li>在 <code>try</code> 或 <code>finally</code>块中用了 <code>System.exit(int)</code>退出程序。但是，如果 <code>System.exit(int)</code> 在异常语句之后，<code>finally</code> 还是会被执行</li><li>程序所在的线程死亡。</li><li>关闭 CPU。</li></ol><p>下面这部分内容来自 issue:<a href="https://github.com/Snailclimb/JavaGuide/issues/190" target="_blank" rel="noopener">https://github.com/Snailclimb/JavaGuide/issues/190</a>。</p><p><strong>注意：</strong> 当 try 语句和 finally 语句中都有 return 语句时，在方法返回之前，finally 语句的内容将被执行，并且 finally 语句的返回值将会覆盖原始的返回值。如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> value * value;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (value == <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果调用 <code>f(2)</code>，返回值将是 0，因为 finally 语句的返回值覆盖了 try 语句块的返回值。</p><h3 id="2-1-30-Java-序列化中如果有些字段不想进行序列化，怎么办？"><a href="#2-1-30-Java-序列化中如果有些字段不想进行序列化，怎么办？" class="headerlink" title="2.1.30. Java 序列化中如果有些字段不想进行序列化，怎么办？"></a>2.1.30. Java 序列化中如果有些字段不想进行序列化，怎么办？</h3><p>对于不想进行序列化的变量，使用 transient 关键字修饰。</p><p>transient 关键字的作用是：阻止实例中那些用此关键字修饰的的变量序列化；当对象被反序列化时，被 transient 修饰的变量值不会被持久化和恢复。transient 只能修饰变量，不能修饰类和方法。</p><h3 id="2-1-31-获取用键盘输入常用的两种方法"><a href="#2-1-31-获取用键盘输入常用的两种方法" class="headerlink" title="2.1.31. 获取用键盘输入常用的两种方法"></a>2.1.31. 获取用键盘输入常用的两种方法</h3><p>方法 1：通过 Scanner</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Scanner input = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">String s  = input.nextLine();</span><br><span class="line">input.close();</span><br></pre></td></tr></table></figure><p>方法 2：通过 BufferedReader</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">BufferedReader input = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in));</span><br><span class="line">String s = input.readLine();</span><br></pre></td></tr></table></figure><h3 id="2-1-32-Java-中-IO-流"><a href="#2-1-32-Java-中-IO-流" class="headerlink" title="2.1.32. Java 中 IO 流"></a>2.1.32. Java 中 IO 流</h3><h4 id="2-1-32-1-Java-中-IO-流分为几种"><a href="#2-1-32-1-Java-中-IO-流分为几种" class="headerlink" title="2.1.32.1. Java 中 IO 流分为几种?"></a>2.1.32.1. Java 中 IO 流分为几种?</h4><ul><li>按照流的流向分，可以分为输入流和输出流；</li><li>按照操作单元划分，可以划分为字节流和字符流；</li><li>按照流的角色划分为节点流和处理流。</li></ul><p>Java Io 流共涉及 40 多个类，这些类看上去很杂乱，但实际上很有规则，而且彼此之间存在非常紧密的联系， Java I0 流的 40 多个类都是从如下 4 个抽象类基类中派生出来的。</p><ul><li>InputStream/Reader: 所有的输入流的基类，前者是字节输入流，后者是字符输入流。</li><li>OutputStream/Writer: 所有输出流的基类，前者是字节输出流，后者是字符输出流。</li></ul><p>按操作方式分类结构图：</p><p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/IO-%E6%93%8D%E4%BD%9C%E6%96%B9%E5%BC%8F%E5%88%86%E7%B1%BB.png" alt="IO-操作方式分类"></p><p>按操作对象分类结构图：</p><p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/IO-%E6%93%8D%E4%BD%9C%E5%AF%B9%E8%B1%A1%E5%88%86%E7%B1%BB.png" alt="IO-操作对象分类"></p><h4 id="2-1-32-2-既然有了字节流-为什么还要有字符流"><a href="#2-1-32-2-既然有了字节流-为什么还要有字符流" class="headerlink" title="2.1.32.2. 既然有了字节流,为什么还要有字符流?"></a>2.1.32.2. 既然有了字节流,为什么还要有字符流?</h4><p>问题本质想问：<strong>不管是文件读写还是网络发送接收，信息的最小存储单元都是字节，那为什么 I/O 流操作要分为字节流操作和字符流操作呢？</strong></p><p>回答：字符流是由 Java 虚拟机将字节转换得到的，问题就出在这个过程还算是非常耗时，并且，如果我们不知道编码类型就很容易出现乱码问题。所以， I/O 流就干脆提供了一个直接操作字符的接口，方便我们平时对字符进行流操作。如果音频文件、图片等媒体文件用字节流比较好，如果涉及到字符的话使用字符流比较好。</p><h4 id="2-1-32-3-BIO-NIO-AIO-有什么区别"><a href="#2-1-32-3-BIO-NIO-AIO-有什么区别" class="headerlink" title="2.1.32.3. BIO,NIO,AIO 有什么区别?"></a>2.1.32.3. BIO,NIO,AIO 有什么区别?</h4><ul><li><strong>BIO (Blocking I/O):</strong> 同步阻塞 I/O 模式，数据的读取写入必须阻塞在一个线程内等待其完成。在活动连接数不是特别高（小于单机 1000）的情况下，这种模型是比较不错的，可以让每一个连接专注于自己的 I/O 并且编程模型简单，也不用过多考虑系统的过载、限流等问题。线程池本身就是一个天然的漏斗，可以缓冲一些系统处理不了的连接或请求。但是，当面对十万甚至百万级连接的时候，传统的 BIO 模型是无能为力的。因此，我们需要一种更高效的 I/O 处理模型来应对更高的并发量。</li><li><strong>NIO (Non-blocking/New I/O):</strong> NIO 是一种同步非阻塞的 I/O 模型，在 Java 1.4 中引入了 NIO 框架，对应 java.nio 包，提供了 Channel , Selector，Buffer 等抽象。NIO 中的 N 可以理解为 Non-blocking，不单纯是 New。它支持面向缓冲的，基于通道的 I/O 操作方法。 NIO 提供了与传统 BIO 模型中的 <code>Socket</code> 和 <code>ServerSocket</code> 相对应的 <code>SocketChannel</code> 和 <code>ServerSocketChannel</code> 两种不同的套接字通道实现,两种通道都支持阻塞和非阻塞两种模式。阻塞模式使用就像传统中的支持一样，比较简单，但是性能和可靠性都不好；非阻塞模式正好与之相反。对于低负载、低并发的应用程序，可以使用同步阻塞 I/O 来提升开发速率和更好的维护性；对于高负载、高并发的（网络）应用，应使用 NIO 的非阻塞模式来开发</li><li><strong>AIO (Asynchronous I/O):</strong> AIO 也就是 NIO 2。在 Java 7 中引入了 NIO 的改进版 NIO 2,它是异步非阻塞的 IO 模型。异步 IO 是基于事件和回调机制实现的，也就是应用操作之后会直接返回，不会堵塞在那里，当后台处理完成，操作系统会通知相应的线程进行后续的操作。AIO 是异步 IO 的缩写，虽然 NIO 在网络操作中，提供了非阻塞的方法，但是 NIO 的 IO 行为还是同步的。对于 NIO 来说，我们的业务线程是在 IO 操作准备好时，得到通知，接着就由这个线程自行进行 IO 操作，IO 操作本身是同步的。查阅网上相关资料，我发现就目前来说 AIO 的应用还不是很广泛，Netty 之前也尝试使用过 AIO，不过又放弃了。</li></ul><h3 id="2-1-33-深拷贝-vs-浅拷贝"><a href="#2-1-33-深拷贝-vs-浅拷贝" class="headerlink" title="2.1.33. 深拷贝 vs 浅拷贝"></a>2.1.33. 深拷贝 vs 浅拷贝</h3><ol><li><strong>浅拷贝</strong>：对基本数据类型进行值传递，对引用数据类型进行引用传递般的拷贝，此为浅拷贝。</li><li><strong>深拷贝</strong>：对基本数据类型进行值传递，对引用数据类型，创建一个新的对象，并复制其内容，此为深拷贝。</li></ol><p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-7/java-deep-and-shallow-copy.jpg" alt="deep and shallow copy"></p><h3 id="2-1-34-参考"><a href="#2-1-34-参考" class="headerlink" title="2.1.34. 参考"></a>2.1.34. 参考</h3><ul><li><a href="https://stackoverflow.com/questions/1906445/what-is-the-difference-between-jdk-and-jre" target="_blank" rel="noopener">https://stackoverflow.com/questions/1906445/what-is-the-difference-between-jdk-and-jre</a></li><li><a href="https://www.educba.com/oracle-vs-openjdk/" target="_blank" rel="noopener">https://www.educba.com/oracle-vs-openjdk/</a></li><li><a href="https://stackoverflow.com/questions/22358071/differences-between-oracle-jdk-and-openjdk?answertab=active#tab-top" target="_blank" rel="noopener">https://stackoverflow.com/questions/22358071/differences-between-oracle-jdk-and-openjdk?answertab=active#tab-top</a></li></ul><h3 id="2-1-35-公众号"><a href="#2-1-35-公众号" class="headerlink" title="2.1.35. 公众号"></a>2.1.35. 公众号</h3><p>如果大家想要实时关注我更新的文章以及分享的干货的话，可以关注我的公众号。</p><p><strong>《JavaGuide 面试突击版》 :</strong> 由本文档衍生的专为面试而生的《JavaGuide 面试突击版》 版本<a href="#公众号">公众号</a>后台回复 <strong>“Java 面试突击”</strong> 即可免费领取！</p><p><strong>Java 工程师必备学习资源:</strong> 一些 Java 工程师常用学习资源公众号后台回复关键字 <strong>“1”</strong> 即可免费无套路获取。</p><p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/167598cd2e17b8ec.png" alt="我的公众号"></p>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;p&gt;&lt;strong&gt;摘要：&lt;/strong&gt;&lt;br&gt;在原作基础上添加学习笔记。&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>LeetCode 274. H指数</title>
    <link href="https://accepted.org.cn/2021/07/11/LeetCode-274-H%E6%8C%87%E6%95%B0/"/>
    <id>https://accepted.org.cn/2021/07/11/LeetCode-274-H%E6%8C%87%E6%95%B0/</id>
    <published>2021-07-11T05:13:26.000Z</published>
    <updated>2021-07-11T05:38:52.215Z</updated>
    
    <content type="html"><![CDATA[<p><strong>摘要：</strong><br>题目有点绕，好在一遍A。</p><a id="more"></a><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给定一位研究者论文被引用次数的数组（被引用次数是非负整数）。编写一个方法，计算出研究者的 $h$ 指数。</p><p><strong>h 指数的定义：</strong> $h$ 代表“高引用次数”（high citations），一名科研人员的 $h$ 指数是指他（她）的 （N 篇论文中）<strong>总共</strong> 有 $h$ 篇论文分别被引用了<strong>至少</strong> $h$ 次。且其余的 $N - h$ 篇论文每篇被引用次数 <strong>不超过</strong> $h$ 次。</p><p>例如：某人的 $h$ 指数是 $20$，这表示他已发表的论文中，每篇被引用了至少 $20$ 次的论文总共有 $20$ 篇。</p><p><strong>示例：</strong></p><blockquote><p>输入：citations = [3,0,6,1,5]<br>输出：3<br>解释：给定数组表示研究者总共有 5 篇论文，每篇论文相应的被引用了 3, 0, 6, 1, 5 次。</p><p>由于研究者有 3 篇论文每篇 至少 被引用了 3 次，其余两篇论文每篇被引用 不多于 3 次，所以她的 h 指数是 3。</p></blockquote><p>提示：如果 $h$ 有多种可能的值，$h$ 指数是其中最大的那个。</p><h3 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h3><p>题目可以抽象成，在所有的论文当中有 $h$ 篇，其中每篇被引用至少 $h$ 次。</p><p>那么我们就开一个计数数组，对于数组第 $i$ 项，记录引用次数为 $i$ 的论文有多少篇。<br>比如对于示例1，计数数组为：<br>0-1<br>1-1<br>2-0<br>3-1<br>4-0<br>5-1<br>6-1<br>从数组末尾开始遍历，当引用次数对应的篇数不为零时，对应着有效的一项。<br>对于每一个有效项，累加总篇数，和当前下标（即引用次数）比较取最小值 $min$ 就表示当前有 $min$ 篇每篇引用至少 $min$ 次。也就是说每一项都会产生一个新的 $h$ 值，比较所有 $h$ 值取最大者即可。</p><p>Q: 为什么要从计数数组末尾开始遍历？<br>A: 只有从末尾开始遍历，对于每个计数数组中的有效项，累加的篇数和对应下标的引用次数取最小才可以表示成：<br>在当前累加篇数的论文中，每篇引用 <strong>至少</strong> 对应下标次数。从数组开头开始遍历没法表示 <strong>至少</strong>。</p><div class="tabs" id="g_tab0"><ul class="nav-tabs"><li class="tab active"><a href="#g_tab0-1">C++</a></li></ul><div class="tab-content"><div class="tab-pane active" id="g_tab0-1"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">hIndex</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; ci)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> mx = *max_element(ci.<span class="built_in">begin</span>(), ci.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">int</span> n = ci.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">cnt</span><span class="params">(mx + <span class="number">10</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            cnt[ci[i]]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//for (int i = 0; i &lt; mx + 10; ++i) cout &lt;&lt; i &lt;&lt; "-"  &lt;&lt; cnt[i] &lt;&lt; endl;</span></span><br><span class="line">        <span class="comment">//return 0;</span></span><br><span class="line">        <span class="keyword">int</span> paper_cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = mx + <span class="number">9</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cnt[i]) &#123;</span><br><span class="line">                paper_cnt += cnt[i];</span><br><span class="line">                <span class="keyword">int</span> tmp = <span class="built_in">min</span>(paper_cnt, i);</span><br><span class="line">                res = <span class="built_in">max</span>(res, tmp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div></div></div><div class="note primary">            <p><strong>原题链接：</strong> <a href="https://leetcode-cn.com/problems/h-index/" target="_blank" rel="noopener">LeetCode 274. H指数</a></p>          </div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;摘要：&lt;/strong&gt;&lt;br&gt;题目有点绕，好在一遍A。&lt;/p&gt;
    
    </summary>
    
    
      <category term="指尖飞舞" scheme="https://accepted.org.cn/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/"/>
    
      <category term="算法" scheme="https://accepted.org.cn/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/%E7%AE%97%E6%B3%95/"/>
    
      <category term="LeetCode" scheme="https://accepted.org.cn/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/%E7%AE%97%E6%B3%95/LeetCode/"/>
    
    
      <category term="算法" scheme="https://accepted.org.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="LeetCode" scheme="https://accepted.org.cn/tags/LeetCode/"/>
    
      <category term="计数排序" scheme="https://accepted.org.cn/tags/%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 930. 和相同的二元子数组</title>
    <link href="https://accepted.org.cn/2021/07/08/LeetCode-930-%E5%92%8C%E7%9B%B8%E5%90%8C%E7%9A%84%E4%BA%8C%E5%85%83%E5%AD%90%E6%95%B0%E7%BB%84/"/>
    <id>https://accepted.org.cn/2021/07/08/LeetCode-930-%E5%92%8C%E7%9B%B8%E5%90%8C%E7%9A%84%E4%BA%8C%E5%85%83%E5%AD%90%E6%95%B0%E7%BB%84/</id>
    <published>2021-07-08T03:12:48.000Z</published>
    <updated>2021-07-08T04:42:01.569Z</updated>
    
    <content type="html"><![CDATA[<p><strong>摘要：</strong><br>前缀和+TwoSum.</p><a id="more"></a><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给你一个二元数组 $nums$ ，和一个整数 $goal$ ，请你统计并返回有多少个和为 $goal$ 的 <strong>非空</strong> 子数组。</p><p><strong>子数组</strong> 是数组的一段连续部分。</p><p><strong>示例 1：</strong></p><blockquote><p>输入：nums = [1,0,1,0,1], goal = 2<br>输出：4<br>解释：<br>如下面黑体所示，有 4 个满足题目要求的子数组：<br>[<strong>1,0,1</strong> ,0,1]<br>[<strong>1,0,1,0</strong> ,1]<br>[1, <strong>0,1,0,1</strong>]<br>[1,0, <strong>1,0,1</strong>]</p></blockquote><p><strong>示例 2：</strong></p><blockquote><p>输入：nums = [0,0,0,0,0], goal = 0<br>输出：15</p></blockquote><p><strong>提示：</strong></p><ul><li>$1 &lt;= nums.length &lt;= 3 * 10^4$</li><li>$nums[i]$ 不是 $0$ 就是 $1$</li><li>$0 &lt;= goal &lt;= nums.length$</li></ul><hr><h3 id="前缀和"><a href="#前缀和" class="headerlink" title="前缀和"></a>前缀和</h3><p>因为要求出所有和为特定值的子数组个数，子数组是连续的，所以必然联想到前缀和。</p><p>如果预处理出前缀和数组，再暴力枚举所有子数组，复杂度为 $O(N^2)$，还是会超时。</p><p>考虑到以下标为 $i$ 的数开始，以下标为 $j$ 的数结尾的子数组的和为 $presum[j] - presum[i - 1]$，如果这个数和 $goal$ 相等，那么 $[i, j]$ 的子数组就是满足要求的。</p><p>问题就等价于求出原数组中对于每个下标 $j$，有多少小于等于 $j$ 的下标 $i$，满足:</p><p>$presum[i - 1] + goal = presum[j]$.</p><p>显然这是一个TwoSum问题。<br>我们可以维护一个哈希表，存放所有 $prsum[j]$ 的数量。在之后的遍历中，如果出现当前下标的前缀和减去 $goal$ 已经存在，那么 $j$ 一定和当前下标构成一个满足条件的子数组。</p><div class="tabs" id="g_tab0"><ul class="nav-tabs"><li class="tab active"><a href="#g_tab0-1">C++</a></li></ul><div class="tab-content"><div class="tab-pane active" id="g_tab0-1"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numSubarraysWithSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> goal)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">presum</span><span class="params">(n + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) presum[i] = presum[i - <span class="number">1</span>] + nums[i - <span class="number">1</span>];</span><br><span class="line">        <span class="comment">//for (int i = 0; i &lt; n + 1; i++) cout &lt;&lt; presum[i] &lt;&lt; ' ';</span></span><br><span class="line">        <span class="comment">//cout &lt;&lt; endl;</span></span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; hash;</span><br><span class="line">        hash[<span class="number">0</span>]++;  <span class="comment">// 第0项左边的虚拟的和为0，和第零项对应，如果第零项恰好等于goal，那么正好和第零项左边的和匹配</span></span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            res += hash[presum[i] - goal];</span><br><span class="line">            hash[presum[i]]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div></div></div><p>注意每遍历到一个下标，都是先判断当前前缀和减去 $goal$ 是否已存在吗，如果存在就加上存在的数量。那么思考一下数组第 $1$ 个数的情况。</p><p>判断数组第 $1$ 个数对应前缀和减去 $goal$ 是否已存在，它对应的是未出现任何元素之前所有“元素”的和，显然 $0$ 的数量为 $1$，所以 $hash[0]$ 初始化为 $1$.</p><p>这道题和 <a href="https://eetoa.github.io/2021/07/03/【LeetCode周赛247】C-LeetCode-1915-最美子字符串的数目/" target="_blank" rel="noopener">【LeetCode周赛247】C LeetCode 1915. 最美子字符串的数目</a> 非常类似。</p><div class="note primary">            <p><strong>原题链接：</strong> <a href="https://leetcode-cn.com/problems/binary-subarrays-with-sum/" target="_blank" rel="noopener">LeetCode 930. 和相同的二元子数组</a></p>          </div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;摘要：&lt;/strong&gt;&lt;br&gt;前缀和+TwoSum.&lt;/p&gt;
    
    </summary>
    
    
      <category term="指尖飞舞" scheme="https://accepted.org.cn/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/"/>
    
      <category term="算法" scheme="https://accepted.org.cn/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/%E7%AE%97%E6%B3%95/"/>
    
      <category term="LeetCode" scheme="https://accepted.org.cn/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/%E7%AE%97%E6%B3%95/LeetCode/"/>
    
    
      <category term="算法" scheme="https://accepted.org.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="LeetCode" scheme="https://accepted.org.cn/tags/LeetCode/"/>
    
      <category term="哈希表" scheme="https://accepted.org.cn/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    
      <category term="前缀和" scheme="https://accepted.org.cn/tags/%E5%89%8D%E7%BC%80%E5%92%8C/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 1711. 大餐计数</title>
    <link href="https://accepted.org.cn/2021/07/07/LeetCode-1711-%E5%A4%A7%E9%A4%90%E8%AE%A1%E6%95%B0/"/>
    <id>https://accepted.org.cn/2021/07/07/LeetCode-1711-%E5%A4%A7%E9%A4%90%E8%AE%A1%E6%95%B0/</id>
    <published>2021-07-07T04:55:26.000Z</published>
    <updated>2021-07-07T05:15:38.289Z</updated>
    
    <content type="html"><![CDATA[<p><strong>摘要：</strong><br>TwoSum升级版。</p><a id="more"></a><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p><strong>大餐</strong> 是指 <strong>恰好包含两道不同餐品</strong> 的一餐，其美味程度之和等于 $2$ 的幂。</p><p>你可以搭配 <strong>任意</strong> 两道餐品做一顿大餐。</p><p>给你一个整数数组 $deliciousness$ ，其中 $deliciousness[i]$ 是第 $i$​​​​​​​​​​​​​​ 道餐品的美味程度，返回你可以用数组中的餐品做出的不同 <strong>大餐</strong> 的数量。结果需要对 $10^9 + 7$ 取余。</p><p>注意，只要餐品下标不同，就可以认为是不同的餐品，即便它们的美味程度相同。</p><p><strong>示例 1：</strong></p><blockquote><p>输入：deliciousness = [1,3,5,7,9]<br>输出：4<br>解释：大餐的美味程度组合为 (1,3) 、(1,7) 、(3,5) 和 (7,9) 。<br>它们各自的美味程度之和分别为 4 、8 、8 和 16 ，都是 2 的幂。</p></blockquote><p><strong>示例 2：</strong></p><blockquote><p>输入：deliciousness = [1,1,1,3,3,3,7]<br>输出：15<br>解释：大餐的美味程度组合为 3 种 (1,1) ，9 种 (1,3) ，和 3 种 (1,7) 。</p></blockquote><p><strong>提示：</strong></p><ul><li>$1 &lt;= deliciousness.length &lt;= 10^5$</li><li>$0 &lt;= deliciousness[i] &lt;= 2^{20}$</li></ul><hr><h3 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h3><p>对于数组中的每个元素，从 $2^0$ 到 $2^{21}$ 依次计算目标值，将目标值放入哈希表计数加一。<br>那么，对于每一个元素需要先从哈希表里面找自己是不是之前某数的目标值，如果是，则结果加上目标值的计数。<br>值得注意的是，$0 &lt;= deliciousness[i] &lt;= 2^{20}$，所以当数组存在多个最大范围的值时，目标值最高可取到  $2^20 + 2^{20}$ 也就是 $2^{21}$.</p><p>我们可以先求出原数组中的最大值，那么对于每个数循环 $[2^0,2^{21}]$ 时，目标值可能的范围在 $0 &lt;= deliciousness[i] &lt;= 2^{20}$，超出可以不考虑，因为数组元素在这个范围，不可能遇到超出范围的。</p><div class="tabs" id="g_tab0"><ul class="nav-tabs"><li class="tab active"><a href="#g_tab0-1">C++</a></li><li class="tab"><a href="#g_tab0-2">C++</a></li></ul><div class="tab-content"><div class="tab-pane active" id="g_tab0-1"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 2021-7-7 13:15:21</span></span><br><span class="line"><span class="comment"> * author: etoa</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">auto</span> <span class="built_in">shutdown</span> = []()&#123;</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>)-&gt;sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;();</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">int</span> MOD = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="title">ksm</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> res = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (; b; a = a * a, b &gt;&gt;= <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (b &amp; <span class="number">1</span>) res = res * a;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countPairs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; d)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = d.<span class="built_in">size</span>();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt; target;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">21</span>; i++) &#123;</span><br><span class="line">            target.push_back(ksm(<span class="number">2</span>, i));</span><br><span class="line">        &#125;   </span><br><span class="line">        <span class="keyword">int</span> mx = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) </span><br><span class="line">            mx = <span class="built_in">max</span>(mx, d[i]);</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>, <span class="keyword">int</span>&gt; hash; <span class="comment">// expected - cnt</span></span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (hash.count(d[i])) &#123;</span><br><span class="line">                res += hash[d[i]];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//cout &lt;&lt; d[i] &lt;&lt; "---" &lt;&lt; endl;</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= <span class="number">21</span>; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (target[j] - d[i] &gt; mx) <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">if</span> (target[j] - d[i] &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    hash[target[j] - d[i]]++;</span><br><span class="line">                    <span class="comment">//cout &lt;&lt; target[j] - d[i] &lt;&lt; '-' &lt;&lt; hash[target[j] - d[i]] &lt;&lt; endl;</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">return</span> res % MOD;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="g_tab0-2"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 优化：快速幂可以用位运算代替；</span></span><br><span class="line"><span class="comment"> * 求数组最值可以使用max_element;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">auto</span> <span class="built_in">shutdown</span> = []()&#123;</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>)-&gt;sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;();</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">int</span> MOD = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countPairs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; d)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = d.<span class="built_in">size</span>();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt; target;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">21</span>; i++) &#123;</span><br><span class="line">            target.push_back(<span class="number">1</span> &lt;&lt; i);</span><br><span class="line">        &#125;   </span><br><span class="line">        <span class="keyword">int</span> mx = *max_element(d.<span class="built_in">begin</span>(), d.<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>, <span class="keyword">int</span>&gt; hash; <span class="comment">// expected - cnt</span></span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (hash.count(d[i])) &#123;</span><br><span class="line">                res += hash[d[i]];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//cout &lt;&lt; d[i] &lt;&lt; "---" &lt;&lt; endl;</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= <span class="number">21</span>; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (target[j] - d[i] &gt; mx) <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">if</span> (target[j] - d[i] &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    hash[target[j] - d[i]]++;</span><br><span class="line">                    <span class="comment">//cout &lt;&lt; target[j] - d[i] &lt;&lt; '-' &lt;&lt; hash[target[j] - d[i]] &lt;&lt; endl;</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">return</span> res % MOD;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div></div></div><div class="note primary">            <p><strong>原题链接：</strong> <a href="https://leetcode-cn.com/problems/count-good-meals/" target="_blank" rel="noopener">LeetCode 1711. 大餐计数</a></p>          </div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;摘要：&lt;/strong&gt;&lt;br&gt;TwoSum升级版。&lt;/p&gt;
    
    </summary>
    
    
      <category term="指尖飞舞" scheme="https://accepted.org.cn/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/"/>
    
      <category term="算法" scheme="https://accepted.org.cn/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/%E7%AE%97%E6%B3%95/"/>
    
      <category term="LeetCode" scheme="https://accepted.org.cn/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/%E7%AE%97%E6%B3%95/LeetCode/"/>
    
    
      <category term="算法" scheme="https://accepted.org.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="LeetCode" scheme="https://accepted.org.cn/tags/LeetCode/"/>
    
      <category term="哈希表" scheme="https://accepted.org.cn/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 1418. 点菜展示表</title>
    <link href="https://accepted.org.cn/2021/07/06/LeetCode-1418-%E7%82%B9%E8%8F%9C%E5%B1%95%E7%A4%BA%E8%A1%A8/"/>
    <id>https://accepted.org.cn/2021/07/06/LeetCode-1418-%E7%82%B9%E8%8F%9C%E5%B1%95%E7%A4%BA%E8%A1%A8/</id>
    <published>2021-07-06T05:54:21.000Z</published>
    <updated>2021-07-07T05:18:27.538Z</updated>
    
    <content type="html"><![CDATA[<p><strong>摘要：</strong><br>使用有序集合和有序map简化代码。</p><a id="more"></a><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给你一个数组 $orders$，表示客户在餐厅中完成的订单。</p><p>确切地说， $orders[i]=[customerNamei,tableNumberi,foodItemi]$ ，其中 $customerNamei$ 是客户的姓名，$tableNumberi$ 是客户所在餐桌的桌号，而 $foodItemi$ 是客户点的餐品名称。</p><p>请你返回该餐厅的 <strong>点菜展示表</strong> 。在这张表中，表中第一行为标题，其第一列为餐桌桌号 “Table” ，后面每一列都是按字母顺序排列的餐品名称。接下来每一行中的项则表示每张餐桌订购的相应餐品数量，第一列应当填对应的桌号，后面依次填写下单的餐品数量。</p><p>注意：客户姓名不是点菜展示表的一部分。此外，表中的数据行应该按餐桌桌号升序排列。</p><p><strong>示例 1：</strong></p><blockquote><p>输入：orders = [[“David”,”3”,”Ceviche”],[“Corina”,”10”,”Beef Burrito”],[“David”,”3”,”Fried Chicken”],[“Carla”,”5”,”Water”],[“Carla”,”5”,”Ceviche”],[“Rous”,”3”,”Ceviche”]]<br>输出：[[“Table”,”Beef Burrito”,”Ceviche”,”Fried Chicken”,”Water”],[“3”,”0”,”2”,”1”,”0”],[“5”,”0”,”1”,”0”,”1”],[“10”,”1”,”0”,”0”,”0”]]<br>解释：<br>点菜展示表如下所示：</p><table><thead><tr><th align="left">Table</th><th align="left">Beef Burrito</th><th align="left">Ceviche</th><th align="left">Fried Chicken</th><th align="left">Water</th></tr></thead><tbody><tr><td align="left">3</td><td align="left">0</td><td align="left">2</td><td align="left">1</td><td align="left">0</td></tr><tr><td align="left">5</td><td align="left">0</td><td align="left">1</td><td align="left">0</td><td align="left">1</td></tr><tr><td align="left">10</td><td align="left">1</td><td align="left">0</td><td align="left">0</td><td align="left">0</td></tr></tbody></table><p>对于餐桌 3：David 点了 “Ceviche” 和 “Fried Chicken”，而 Rous 点了 “Ceviche”<br>而餐桌 5：Carla 点了 “Water” 和 “Ceviche”<br>餐桌 10：Corina 点了 “Beef Burrito” </p></blockquote><p><strong>示例 2：</strong></p><blockquote><p>输入：orders = [[“James”,”12”,”Fried Chicken”],[“Ratesh”,”12”,”Fried Chicken”],[“Amadeus”,”12”,”Fried Chicken”],[“Adam”,”1”,”Canadian Waffles”],[“Brianna”,”1”,”Canadian Waffles”]]<br>输出：[[“Table”,”Canadian Waffles”,”Fried Chicken”],[“1”,”2”,”0”],[“12”,”0”,”3”]]<br>解释：<br>对于餐桌 1：Adam 和 Brianna 都点了 “Canadian Waffles”<br>而餐桌 12：James, Ratesh 和 Amadeus 都点了 “Fried Chicken”</p></blockquote><p><strong>示例 3：</strong></p><blockquote><p>输入：orders = [[“Laura”,”2”,”Bean Burrito”],[“Jhon”,”2”,”Beef Burrito”],[“Melissa”,”2”,”Soda”]]<br>输出：[[“Table”,”Bean Burrito”,”Beef Burrito”,”Soda”],[“2”,”1”,”1”,”1”]]</p></blockquote><p><strong>提示：</strong></p><ul><li>$1 &lt;= orders.length &lt;= 5 \times 10^4$</li><li>$orders[i].length = 3$</li><li>$1 &lt;= customerNamei.length, foodItemi.length &lt;= 20$</li><li>$customerNamei$ 和 $foodItemi$ 由大小写英文字母及空格字符 <code>&#39; &#39;</code> 组成。</li><li>$tableNumberi$ 是 $1$ 到 $500$ 范围内的整数。</li></ul><hr><h3 id="模拟"><a href="#模拟" class="headerlink" title="模拟"></a>模拟</h3><p>构建一个桌号数组，数组中放入有序哈希表。遍历 $orders$ 数组，将桌号对应的菜品放入到对应的哈希表中。</p><div class="tabs" id="g_tab0"><ul class="nav-tabs"><li class="tab active"><a href="#g_tab0-1">C++</a></li></ul><div class="tab-content"><div class="tab-pane active" id="g_tab0-1"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 2021-7-6 14:11:00</span></span><br><span class="line"><span class="comment"> * author: etoa</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">int</span> N = <span class="number">507</span>;</span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; table[N];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; <span class="title">displayTable</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt;&amp; orders)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">set</span>&lt;<span class="built_in">string</span>&gt; fooditem;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;e : orders) &#123;</span><br><span class="line">            fooditem.insert(e[<span class="number">2</span>]);</span><br><span class="line">            table[stoi(e[<span class="number">1</span>])][e[<span class="number">2</span>]]++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; res;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; intro;</span><br><span class="line">        intro.push_back(<span class="string">"Table"</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;e : fooditem) intro.push_back(e);</span><br><span class="line">        res.push_back(intro);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!table[i].empty()) &#123;</span><br><span class="line">                <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; each_table;</span><br><span class="line">                each_table.push_back(to_string(i));</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;e : fooditem) &#123;</span><br><span class="line">                    each_table.push_back(to_string(table[i][e]));</span><br><span class="line">                &#125;</span><br><span class="line">                res.push_back(each_table);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div></div></div><div class="note primary">            <p><strong>原题链接：</strong> <a href="https://leetcode-cn.com/problems/display-table-of-food-orders-in-a-restaurant/" target="_blank" rel="noopener">LeetCode 1418. 点菜展示表</a></p>          </div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;摘要：&lt;/strong&gt;&lt;br&gt;使用有序集合和有序map简化代码。&lt;/p&gt;
    
    </summary>
    
    
      <category term="指尖飞舞" scheme="https://accepted.org.cn/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/"/>
    
      <category term="算法" scheme="https://accepted.org.cn/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/%E7%AE%97%E6%B3%95/"/>
    
      <category term="LeetCode" scheme="https://accepted.org.cn/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/%E7%AE%97%E6%B3%95/LeetCode/"/>
    
    
      <category term="算法" scheme="https://accepted.org.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="LeetCode" scheme="https://accepted.org.cn/tags/LeetCode/"/>
    
      <category term="哈希表" scheme="https://accepted.org.cn/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    
      <category term="集合" scheme="https://accepted.org.cn/tags/%E9%9B%86%E5%90%88/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 726. 原子的数量</title>
    <link href="https://accepted.org.cn/2021/07/06/LeetCode-726-%E5%8E%9F%E5%AD%90%E7%9A%84%E6%95%B0%E9%87%8F/"/>
    <id>https://accepted.org.cn/2021/07/06/LeetCode-726-%E5%8E%9F%E5%AD%90%E7%9A%84%E6%95%B0%E9%87%8F/</id>
    <published>2021-07-05T16:34:58.000Z</published>
    <updated>2021-07-05T16:44:55.985Z</updated>
    
    <content type="html"><![CDATA[<p><strong>摘要：</strong><br>很容易想到使用DFS解决问题。</p><a id="more"></a><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给定一个化学式 $formula$（作为字符串），返回每种原子的数量。</p><p>原子总是以一个大写字母开始，接着跟随 $0$ 个或任意个小写字母，表示原子的名字。</p><p>如果数量大于 $1$，原子后会跟着数字表示原子的数量。如果数量等于 $1$ 则不会跟数字。例如，$H2O$ 和 $H2O2$ 是可行的，但 $H1O2$ 这个表达是不可行的。</p><p>两个化学式连在一起是新的化学式。例如 $H2O2He3Mg4$ 也是化学式。</p><p>一个括号中的化学式和数字（可选择性添加）也是化学式。例如 $(H2O2)$ 和 $(H2O2)3$ 是化学式。</p><p>给定一个化学式 $formula$ ，返回所有原子的数量。格式为：第一个（按字典序）原子的名字，跟着它的数量（如果数量大于 $1$），然后是第二个原子的名字（按字典序），跟着它的数量（如果数量大于 $1$），以此类推。</p><p><strong>示例 1：</strong></p><blockquote><p>输入：formula = “H2O”<br>输出：”H2O”<br>解释：<br>原子的数量是 {‘H’: 2, ‘O’: 1}。</p></blockquote><p><strong>示例 2：</strong></p><blockquote><p>输入：formula = “Mg(OH)2”<br>输出：”H2MgO2”<br>解释：<br>原子的数量是 {‘H’: 2, ‘Mg’: 1, ‘O’: 2}。</p></blockquote><p><strong>示例 3：</strong></p><blockquote><p>输入：formula = “K4(ON(SO3)2)2”<br>输出：”K4N2O14S4”<br>解释：<br>原子的数量是 {‘K’: 4, ‘N’: 2, ‘O’: 14, ‘S’: 4}。</p></blockquote><p><strong>示例 4：</strong></p><blockquote><p>输入：formula = “Be32”<br>输出：”Be32”</p></blockquote><p><strong>提示：</strong></p><ul><li>$1 &lt;= formula.length &lt;= 1000$</li><li>$formula$ 由小写英文字母、数字 <code>(</code> 和 <code>)</code> 组成。</li><li>$formula$ 是有效的化学式。</li></ul><hr><h3 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h3><p>本题会遇到嵌套的括号，可以使用递归解决问题。<br>每遇到左括号就进入递归，并计算括号内的原子数量，保存在 <code>map</code> 中。<br>遇到右括号递归终止，返回。<br>回溯阶段判断右括号外的倍数问题，将返回的 <code>map</code> 中原子数目全部乘倍数。<br>因为题目要求使用字典序输出内容，故不使用 <code>unordered_map</code> 而使用 <code>map</code>.</p><div class="tabs" id="g_tab0"><ul class="nav-tabs"><li class="tab active"><a href="#g_tab0-1">C++</a></li><li class="tab"><a href="#g_tab0-2">C++</a></li></ul><div class="tab-content"><div class="tab-pane active" id="g_tab0-1"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 2021-7-6 00:43:56</span></span><br><span class="line"><span class="comment"> * author: etoa</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">countOfAtoms</span><span class="params">(<span class="built_in">string</span> formula)</span> </span>&#123;</span><br><span class="line">        n = formula.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> u = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">auto</span> ordereded_map = dfs(formula, u);</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">string</span> res;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;[atom, cnt] : ordereded_map) &#123;</span><br><span class="line">            res += atom;</span><br><span class="line">            <span class="keyword">if</span> (cnt &gt; <span class="number">1</span>) res += to_string(cnt);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    map&lt;string, int&gt; dfs(string &amp;formula, int &amp;u) &#123;</span><br><span class="line">        <span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; tres;</span><br><span class="line">        <span class="keyword">for</span> (; u &lt; n;) &#123;</span><br><span class="line">            <span class="keyword">if</span> (formula[u] == <span class="string">'('</span>) &#123;</span><br><span class="line">                ++u;</span><br><span class="line">                <span class="keyword">auto</span> tmap = dfs(formula, u);</span><br><span class="line">                <span class="comment">// checks if current is digits</span></span><br><span class="line">                <span class="keyword">int</span> mul = <span class="number">0</span>, k = u;</span><br><span class="line">                <span class="keyword">for</span> (; k &lt; n &amp;&amp; <span class="built_in">isdigit</span>(formula[k]); ++k) &#123;</span><br><span class="line">                    mul = mul * <span class="number">10</span> + formula[k] - <span class="string">'0'</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (!mul) ++mul;</span><br><span class="line">                u = k;</span><br><span class="line">                <span class="comment">// merge</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;[atom, cnt] : tmap) &#123;</span><br><span class="line">                    tres[atom] += cnt * mul;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (formula[u] == <span class="string">')'</span>) &#123;    <span class="comment">// endof dfs</span></span><br><span class="line">                ++u;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123; </span><br><span class="line">                <span class="keyword">int</span> k = u + <span class="number">1</span>;  <span class="comment">// 从字母的下一位开始</span></span><br><span class="line">                <span class="built_in">string</span> atom;</span><br><span class="line">                <span class="keyword">for</span> (; k &lt; n &amp;&amp; <span class="built_in">islower</span>(formula[k]); ++k);</span><br><span class="line">                <span class="keyword">int</span> atomlen = k - u;</span><br><span class="line">                atom = formula.substr(u, atomlen);</span><br><span class="line">                <span class="comment">//cout &lt;&lt; atom &lt;&lt; endl;</span></span><br><span class="line">                </span><br><span class="line">                <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span> (; k &lt; n &amp;&amp; <span class="built_in">isdigit</span>(formula[k]); k++) &#123;</span><br><span class="line">                    cnt = cnt * <span class="number">10</span> + formula[k] - <span class="string">'0'</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (!cnt) ++cnt;</span><br><span class="line">                <span class="comment">//cout &lt;&lt; cnt &lt;&lt; endl;</span></span><br><span class="line">                tres[atom] += cnt;</span><br><span class="line">                u = k;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> tres;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="g_tab0-2"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * author: yxc@acwing</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; MPSI;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">MPSI <span class="title">dfs</span><span class="params">(<span class="built_in">string</span>&amp; str, <span class="keyword">int</span>&amp; u)</span> </span>&#123;</span><br><span class="line">        MPSI res;</span><br><span class="line">        <span class="keyword">while</span> (u &lt; str.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (str[u] == <span class="string">'('</span>) &#123;</span><br><span class="line">                u ++ ;</span><br><span class="line">                <span class="keyword">auto</span> t = dfs(str, u);</span><br><span class="line">                u ++ ;</span><br><span class="line">                <span class="keyword">int</span> cnt = <span class="number">1</span>, k = u;</span><br><span class="line">                <span class="keyword">while</span> (k &lt; str.<span class="built_in">size</span>() &amp;&amp; <span class="built_in">isdigit</span>(str[k])) k ++ ;</span><br><span class="line">                <span class="keyword">if</span> (k &gt; u) &#123;</span><br><span class="line">                    cnt = stoi(str.substr(u, k - u));</span><br><span class="line">                    u = k;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; [x, y]: t) res[x] += y * cnt;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (str[u] == <span class="string">')'</span>) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> k = u + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">while</span> (k &lt; str.<span class="built_in">size</span>() &amp;&amp; str[k] &gt;= <span class="string">'a'</span> &amp;&amp; str[k] &lt;= <span class="string">'z'</span>) k ++ ;</span><br><span class="line">                <span class="keyword">auto</span> key = str.substr(u, k - u);</span><br><span class="line">                u = k;</span><br><span class="line">                <span class="keyword">int</span> cnt = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">while</span> (k &lt; str.<span class="built_in">size</span>() &amp;&amp; <span class="built_in">isdigit</span>(str[k])) k ++ ;</span><br><span class="line">                <span class="keyword">if</span> (k &gt; u) &#123;</span><br><span class="line">                    cnt = stoi(str.substr(u, k - u));</span><br><span class="line">                    u = k;</span><br><span class="line">                &#125;</span><br><span class="line">                res[key] += cnt;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">countOfAtoms</span><span class="params">(<span class="built_in">string</span> formula)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">auto</span> t = dfs(formula, k);</span><br><span class="line">        <span class="built_in">string</span> res;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; [x, y]: t) &#123;</span><br><span class="line">            res += x;</span><br><span class="line">            <span class="keyword">if</span> (y &gt; <span class="number">1</span>) res += to_string(y);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div></div></div><div class="note primary">            <p><strong>原题链接：</strong> <a href="https://leetcode-cn.com/problems/number-of-atoms/" target="_blank" rel="noopener">LeetCode 726. 原子的数量</a></p>          </div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;摘要：&lt;/strong&gt;&lt;br&gt;很容易想到使用DFS解决问题。&lt;/p&gt;
    
    </summary>
    
    
      <category term="指尖飞舞" scheme="https://accepted.org.cn/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/"/>
    
      <category term="算法" scheme="https://accepted.org.cn/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/%E7%AE%97%E6%B3%95/"/>
    
      <category term="LeetCode" scheme="https://accepted.org.cn/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/%E7%AE%97%E6%B3%95/LeetCode/"/>
    
    
      <category term="算法" scheme="https://accepted.org.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="LeetCode" scheme="https://accepted.org.cn/tags/LeetCode/"/>
    
      <category term="DFS" scheme="https://accepted.org.cn/tags/DFS/"/>
    
      <category term="字符串" scheme="https://accepted.org.cn/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
      <category term="回溯" scheme="https://accepted.org.cn/tags/%E5%9B%9E%E6%BA%AF/"/>
    
  </entry>
  
  <entry>
    <title>【LeetCode周赛248】C LeetCode 5802. 统计好数字的数目</title>
    <link href="https://accepted.org.cn/2021/07/05/%E3%80%90LeetCode%E5%91%A8%E8%B5%9B248%E3%80%91C-LeetCode-5802-%E7%BB%9F%E8%AE%A1%E5%A5%BD%E6%95%B0%E5%AD%97%E7%9A%84%E6%95%B0%E7%9B%AE/"/>
    <id>https://accepted.org.cn/2021/07/05/%E3%80%90LeetCode%E5%91%A8%E8%B5%9B248%E3%80%91C-LeetCode-5802-%E7%BB%9F%E8%AE%A1%E5%A5%BD%E6%95%B0%E5%AD%97%E7%9A%84%E6%95%B0%E7%9B%AE/</id>
    <published>2021-07-04T17:14:16.000Z</published>
    <updated>2021-07-05T03:45:26.959Z</updated>
    
    <content type="html"><![CDATA[<p><strong>摘要：</strong><br>经典模意义下快速幂应用。</p><a id="more"></a><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>我们称一个数字字符串是 <strong>好数字</strong> 当它满足（下标从 $0$ 开始）<strong>偶数</strong> 下标处的数字为 <strong>偶数</strong> 且 <strong>奇数</strong> 下标处的数字为 <strong>质数</strong> （$2$，$3$，$5$ 或 $7$）。</p><ul><li>比方说，$2582$ 是好数字，因为偶数下标处的数字（$2$ 和 $8$）是偶数且奇数下标处的数字（$5$ 和 $2$）为质数。但 $3245$ <strong>不是</strong> 好数字，因为 $3$ 在偶数下标处但不是偶数。</li></ul><p>给你一个整数 $n$ ，请你返回长度为 $n$ 且为好数字的数字字符串 <strong>总数</strong> 。由于答案可能会很大，请你将它对 $10^9 + 7$ <strong>取余后返回</strong> 。</p><p>一个 <strong>数字字符串</strong> 是每一位都由 $0$ 到 $9$ 组成的字符串，且可能包含前导 $0$ 。</p><p><strong>示例 1：</strong></p><blockquote><p>输入：n = 1<br>输出：5<br>解释：长度为 1 的好数字包括 “0”，”2”，”4”，”6”，”8” 。</p></blockquote><p><strong>示例 2：</strong></p><blockquote><p>输入：n = 4<br>输出：400</p></blockquote><p><strong>示例 3：</strong></p><blockquote><p>输入：n = 50<br>输出：564908303</p></blockquote><p><strong>提示：</strong></p><ul><li>$1 &lt;= n &lt;= 10^{15}$</li></ul><hr><h3 id="快速幂"><a href="#快速幂" class="headerlink" title="快速幂"></a>快速幂</h3><p>对于长度为 $n$ 的数字，偶数位对应着 $0, 2, 4, 6, 8$ 共 $5$ 种选择；奇数位对应着 $2, 3, 5, 7$ 共 $4$ 种选择。</p><p>偶数位共有 $\lceil n / 2 \rceil$ 个，奇数位共有 $\lfloor n / 2 \rfloor$ 个。</p><p>那么答案应该是 $5^{\lceil n / 2 \rceil} \times 4^{\lfloor n / 2 \rfloor} \bmod (10^9 + 7)$.</p><p>使用模意义下的快速幂可以在 $O(log(\lceil n / 2 \rceil + \lfloor n / 2 \rfloor))$ 复杂度内算出。</p><div class="tabs" id="g_tab0"><ul class="nav-tabs"><li class="tab active"><a href="#g_tab0-1">C++</a></li></ul><div class="tab-content"><div class="tab-pane active" id="g_tab0-1"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> MOD = <span class="number">1'000'000'007</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> LL <span class="title">ksm</span><span class="params">(LL a, LL b, LL MOD)</span> </span>&#123;</span><br><span class="line">        LL res = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (b) &#123;</span><br><span class="line">            <span class="keyword">if</span> (b &amp; <span class="number">1</span>) res = res * a % MOD;</span><br><span class="line">            a = a * a % MOD;</span><br><span class="line">            b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countGoodNumbers</span><span class="params">(LL n)</span> </span>&#123;</span><br><span class="line">        LL even = n + <span class="number">1</span> &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        LL odd = n &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> (ksm(<span class="number">5</span>, even, MOD) * ksm(<span class="number">4</span>, odd, MOD)) % MOD;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div></div></div><div class="note primary">            <p><strong>原题链接：</strong> <a href="https://leetcode-cn.com/problems/count-good-numbers/" target="_blank" rel="noopener">LeetCode 5802. 统计好数字的数目</a></p>          </div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;摘要：&lt;/strong&gt;&lt;br&gt;经典模意义下快速幂应用。&lt;/p&gt;
    
    </summary>
    
    
      <category term="指尖飞舞" scheme="https://accepted.org.cn/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/"/>
    
      <category term="算法" scheme="https://accepted.org.cn/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/%E7%AE%97%E6%B3%95/"/>
    
      <category term="LeetCode" scheme="https://accepted.org.cn/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/%E7%AE%97%E6%B3%95/LeetCode/"/>
    
      <category term="竞赛" scheme="https://accepted.org.cn/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/%E7%AE%97%E6%B3%95/%E7%AB%9E%E8%B5%9B/"/>
    
      <category term="LeetCode周赛" scheme="https://accepted.org.cn/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/%E7%AE%97%E6%B3%95/%E7%AB%9E%E8%B5%9B/LeetCode%E5%91%A8%E8%B5%9B/"/>
    
      <category term="248" scheme="https://accepted.org.cn/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/%E7%AE%97%E6%B3%95/%E7%AB%9E%E8%B5%9B/LeetCode%E5%91%A8%E8%B5%9B/248/"/>
    
    
      <category term="算法" scheme="https://accepted.org.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="LeetCode" scheme="https://accepted.org.cn/tags/LeetCode/"/>
    
      <category term="数学" scheme="https://accepted.org.cn/tags/%E6%95%B0%E5%AD%A6/"/>
    
      <category term="竞赛" scheme="https://accepted.org.cn/tags/%E7%AB%9E%E8%B5%9B/"/>
    
      <category term="数论" scheme="https://accepted.org.cn/tags/%E6%95%B0%E8%AE%BA/"/>
    
      <category term="快速幂" scheme="https://accepted.org.cn/tags/%E5%BF%AB%E9%80%9F%E5%B9%82/"/>
    
  </entry>
  
  <entry>
    <title>【AcWing算法基础】第四讲-数学知识-快速幂 AcWing 875. 快速幂</title>
    <link href="https://accepted.org.cn/2021/07/04/%E3%80%90AcWing%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E3%80%91%E7%AC%AC%E5%9B%9B%E8%AE%B2-%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86-%E5%BF%AB%E9%80%9F%E5%B9%82-AcWing-875-%E5%BF%AB%E9%80%9F%E5%B9%82/"/>
    <id>https://accepted.org.cn/2021/07/04/%E3%80%90AcWing%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E3%80%91%E7%AC%AC%E5%9B%9B%E8%AE%B2-%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86-%E5%BF%AB%E9%80%9F%E5%B9%82-AcWing-875-%E5%BF%AB%E9%80%9F%E5%B9%82/</id>
    <published>2021-07-04T15:46:47.000Z</published>
    <updated>2021-07-04T17:00:24.720Z</updated>
    
    <content type="html"><![CDATA[<p><strong>摘要：</strong><br>经典快速求幂的算法。</p><a id="more"></a><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给定 $n$ 组 $a_i$, $b_i$, $p_i$，对于每组数据，求出 $a_i^{b_i} \bmod p_i$ 的值。</p><p><strong>输入格式</strong></p><p>第一行包含整数 $n$。</p><p>接下来 $n$ 行，每行包含三个整数 $a_i$, $b_i$, $p_i$。</p><p><strong>输出格式</strong></p><p>对于每组数据，输出一个结果，表示 $a_i^{b_i} \bmod p_i$ 的值。</p><p>每个结果占一行。</p><p><strong>数据范围</strong></p><ul><li>$1≤n≤100000$,</li><li>$1≤a_i, b_i, p_i≤2×10^9$</li></ul><p><strong>输入样例：</strong></p><blockquote><p>2<br>3 2 5<br>4 3 9</p></blockquote><p><strong>输出样例：</strong></p><blockquote><p>4<br>1</p></blockquote><hr><h3 id="二进制反复平方"><a href="#二进制反复平方" class="headerlink" title="二进制反复平方"></a>二进制反复平方</h3><p>本题是模意义下取幂，我们知道取模运算不会干涉乘法运算。所以我们核心关注如何求 $a^b$.</p><p>如果我们可以将 $b$ 拆分成 $2^{x_1} + 2^{x_2} + … + 2^{x_i}$，那么</p><p>$a^b = a^{2^{x_1} + 2^{x_2} + … + 2^{x_i}}$ (即$a^b = a^{2^{x_1}} \times a^{2^{x_2}} \times … \times a^{2^{x_i}}$).</p><p>显然这是将 $b$ 转化为 $2$ 进制后进行 $10$ 进制展开的结果，很轻松可以做到。</p><p>那么现在考虑如何快速获得 $a^{2^{x_1}} \times a^{2^{x_2}} \times … \times a^{2^{x_i}}$ 的值。</p><p>我们可以很方便地预处理出来 $a^{2^0}, a^{2^1}, a^{2^2} … a^{2^{log_2b}}$ 的序列。其中最后一项 $a^{2^{log_2b}}$ 需要刚好小于等于 $a^{b}$.</p><p>有了这样一个序列，我们就可以从中选择需要的数字相乘即可得到最终答案。显然，当 $b$ 的二进制位为1的时候就是对应需要的值（如果二进制位为 $0$，则 $10$ 进制展开的时候是 $0 \times 2^{x_i}$，相加的时候被忽略）。</p><p>在预处理过程中，每一项都是由前一项平方得到，那么整个算法的时间复杂度为 $O(logb)$.</p><div class="tabs" id="g_tab0"><ul class="nav-tabs"><li class="tab active"><a href="#g_tab0-1">C++</a></li></ul><div class="tab-content"><div class="tab-pane active" id="g_tab0-1"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">ksm</span><span class="params">(<span class="keyword">int</span> &amp;a, <span class="keyword">int</span> &amp;b, <span class="keyword">int</span> &amp;p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LL res = <span class="number">1</span>; <span class="comment">// 2的零次幂</span></span><br><span class="line">    <span class="keyword">while</span> (b) &#123;</span><br><span class="line">        <span class="comment">// 如果b的最后一位是1，那么将b拆成2进制表示再分解成若干个2的xi次幂因式的时候，某一个因式对应着该位</span></span><br><span class="line">        <span class="keyword">if</span> (b &amp; <span class="number">1</span>) res = res * a % p;  <span class="comment">// a,b &gt;= 1，所以至少需要算一下第一次a的2的0次幂(等于a)，所以res初始化为1. 随后的计算, a被更新成对应a的2的若干次幂</span></span><br><span class="line">        <span class="comment">// 不管b最后一位是否是1，都需要反复求a的平方，直到a的2的x次幂 &gt; a的b次幂，此时一共计算了log_2b次</span></span><br><span class="line">        a = (LL)a * a % p;  <span class="comment">// 下一次a更新成本次a的平方，其中a = a的2的xi次幂</span></span><br><span class="line">        b &gt;&gt;= <span class="number">1</span>;    <span class="comment">// b右移一位，直到为0退出循环</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>)-&gt;sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">int</span> a, b, p;</span><br><span class="line">    <span class="keyword">while</span> (n--) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b &gt;&gt; p;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; ksm(a, b, p) &lt;&lt; <span class="built_in">endl</span>;    </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div></div><p>现在证明模意义下取幂的正确性：<br>根据模运算性质可知，<br>$x \times y \bmod p = x \bmod p \times y \bmod p$.</p><p>那么，$a^b \bmod p = (a^{2^{x_1}} \times a^{2^{x_2}} \times … \times a^{2^{x_i}}) \bmod p$.</p><p>即$a^b \bmod p = (a^{2^{x_1}} \bmod p \times a^{2^{x_2}} \bmod p \times … \times a^{2^{x_i}} \bmod p) \bmod p$.</p><p>那么每次 $a$ 的迭代 $\bmod p$ 一次，对应上式中每一项 $\bmod p$，每次 $res$ 计算的时候 $\bmod p$ 一次对应上式中最后面的 $\bmod p$.</p><p>取模运算不会干涉乘法运算。</p><div class="note primary">            <p><strong>原题链接：</strong> <a href="https://www.acwing.com/problem/content/description/877/" target="_blank" rel="noopener">AcWing 875. 快速幂</a></p>          </div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;摘要：&lt;/strong&gt;&lt;br&gt;经典快速求幂的算法。&lt;/p&gt;
    
    </summary>
    
    
      <category term="指尖飞舞" scheme="https://accepted.org.cn/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/"/>
    
      <category term="算法" scheme="https://accepted.org.cn/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/%E7%AE%97%E6%B3%95/"/>
    
      <category term="AcWing" scheme="https://accepted.org.cn/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/%E7%AE%97%E6%B3%95/AcWing/"/>
    
      <category term="算法基础课" scheme="https://accepted.org.cn/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/%E7%AE%97%E6%B3%95/AcWing/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BE/"/>
    
      <category term="第四讲数学知识" scheme="https://accepted.org.cn/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/%E7%AE%97%E6%B3%95/AcWing/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BE/%E7%AC%AC%E5%9B%9B%E8%AE%B2%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="算法" scheme="https://accepted.org.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="数学" scheme="https://accepted.org.cn/tags/%E6%95%B0%E5%AD%A6/"/>
    
      <category term="位运算" scheme="https://accepted.org.cn/tags/%E4%BD%8D%E8%BF%90%E7%AE%97/"/>
    
      <category term="AcWing" scheme="https://accepted.org.cn/tags/AcWing/"/>
    
      <category term="数论" scheme="https://accepted.org.cn/tags/%E6%95%B0%E8%AE%BA/"/>
    
      <category term="快速幂" scheme="https://accepted.org.cn/tags/%E5%BF%AB%E9%80%9F%E5%B9%82/"/>
    
  </entry>
  
  <entry>
    <title>【LeetCode周赛248】B LeetCode 5801. 消灭怪物的最大数量</title>
    <link href="https://accepted.org.cn/2021/07/04/%E3%80%90LeetCode%E5%91%A8%E8%B5%9B248%E3%80%91B-LeetCode-5801-%E6%B6%88%E7%81%AD%E6%80%AA%E7%89%A9%E7%9A%84%E6%9C%80%E5%A4%A7%E6%95%B0%E9%87%8F/"/>
    <id>https://accepted.org.cn/2021/07/04/%E3%80%90LeetCode%E5%91%A8%E8%B5%9B248%E3%80%91B-LeetCode-5801-%E6%B6%88%E7%81%AD%E6%80%AA%E7%89%A9%E7%9A%84%E6%9C%80%E5%A4%A7%E6%95%B0%E9%87%8F/</id>
    <published>2021-07-04T14:22:06.000Z</published>
    <updated>2021-07-04T14:36:05.187Z</updated>
    
    <content type="html"><![CDATA[<p><strong>摘要：</strong><br>很明显的贪心题，植物大战僵尸。</p><a id="more"></a><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>你正在玩一款电子游戏，在游戏中你需要保护城市免受怪物侵袭。给你一个 <strong>下标从 $0$ 开始</strong> 且长度为 $n$ 的整数数组 $dist$ ，其中 $dist[i]$ 是第 $i$ 个怪物与城市的 <strong>初始距离</strong>（单位：米）。</p><p>怪物以 <strong>恒定</strong> 的速度走向城市。给你一个长度为 $n$ 的整数数组 $speed$ 表示每个怪物的速度，其中 $speed[i]$ 是第 $i$ 个怪物的速度（单位：米/分）。</p><p>怪物从 <strong>第 $0$ 分钟</strong> 时开始移动。你有一把武器，并可以 <strong>选择</strong> 在每一分钟的开始时使用，包括第 0 分钟。但是你无法在一分钟的中间使用武器。这种武器威力惊人，一次可以消灭任一还活着的怪物。</p><p>一旦任一怪物到达城市，你就输掉了这场游戏。如果某个怪物 <strong>恰</strong> 在某一分钟开始时到达城市，这会被视为 <strong>输掉</strong> 游戏，在你可以使用武器之前，游戏就会结束。</p><p>返回在你输掉游戏前可以消灭的怪物的 <strong>最大</strong> 数量。如果你可以在所有怪物到达城市前将它们全部消灭，返回  $n$ 。</p><p><strong>示例 1：</strong></p><blockquote><p>输入：dist = [1,3,4], speed = [1,1,1]<br>输出：3<br>解释：<br>第 0 分钟开始时，怪物的距离是 [1,3,4]，你消灭了第一个怪物。<br>第 1 分钟开始时，怪物的距离是 [X,2,3]，你没有消灭任何怪物。<br>第 2 分钟开始时，怪物的距离是 [X,1,2]，你消灭了第二个怪物。<br>第 3 分钟开始时，怪物的距离是 [X,X,1]，你消灭了第三个怪物。<br>所有 3 个怪物都可以被消灭。</p></blockquote><p><strong>示例 2：</strong></p><blockquote><p>输入：dist = [1,1,2,3], speed = [1,1,1,1]<br>输出：1<br>解释：<br>第 0 分钟开始时，怪物的距离是 [1,1,2,3]，你消灭了第一个怪物。<br>第 1 分钟开始时，怪物的距离是 [X,0,1,2]，你输掉了游戏。<br>你只能消灭 1 个怪物。</p></blockquote><p><strong>示例 3：</strong></p><blockquote><p>输入：dist = [3,2,4], speed = [5,3,2]<br>输出：1<br>解释：<br>第 0 分钟开始时，怪物的距离是 [3,2,4]，你消灭了第一个怪物。<br>第 1 分钟开始时，怪物的距离是 [X,0,2]，你输掉了游戏。<br>你只能消灭 1 个怪物。</p></blockquote><p><strong>提示：</strong></p><ul><li>$n = dist.length = speed.length$</li><li>$1 &lt;= n &lt;= 10^5$</li><li>$1 &lt;= dist[i], speed[i] &lt;= 10^5$</li></ul><hr><h3 id="贪心"><a href="#贪心" class="headerlink" title="贪心"></a>贪心</h3><p>不能根据距离判断优先击杀的对象，因为速度不同，所以要根据预计到达时间来判断。<br>因为每次击杀之后都需要获得最近到达的对象，所以考虑将所有对象的预计到达时间计算出来，从小到大排序。</p><div class="tabs" id="g_tab0"><ul class="nav-tabs"><li class="tab active"><a href="#g_tab0-1">C++</a></li></ul><div class="tab-content"><div class="tab-pane active" id="g_tab0-1"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">eliminateMaximum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; dist, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; speed)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = dist.<span class="built_in">size</span>();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; time;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            time.push_back((<span class="keyword">double</span>)dist[i] / speed[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        sort(time.<span class="built_in">begin</span>(), time.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (res &gt;= time[i]) <span class="keyword">return</span> res;</span><br><span class="line">            ++res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div></div></div><div class="note primary">            <p><strong>原题链接：</strong> <a href="https://leetcode-cn.com/problems/eliminate-maximum-number-of-monsters/" target="_blank" rel="noopener">LeetCode 5801. 消灭怪物的最大数量</a></p>          </div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;摘要：&lt;/strong&gt;&lt;br&gt;很明显的贪心题，植物大战僵尸。&lt;/p&gt;
    
    </summary>
    
    
      <category term="指尖飞舞" scheme="https://accepted.org.cn/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/"/>
    
      <category term="算法" scheme="https://accepted.org.cn/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/%E7%AE%97%E6%B3%95/"/>
    
      <category term="LeetCode" scheme="https://accepted.org.cn/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/%E7%AE%97%E6%B3%95/LeetCode/"/>
    
      <category term="竞赛" scheme="https://accepted.org.cn/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/%E7%AE%97%E6%B3%95/%E7%AB%9E%E8%B5%9B/"/>
    
      <category term="LeetCode周赛" scheme="https://accepted.org.cn/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/%E7%AE%97%E6%B3%95/%E7%AB%9E%E8%B5%9B/LeetCode%E5%91%A8%E8%B5%9B/"/>
    
      <category term="248" scheme="https://accepted.org.cn/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/%E7%AE%97%E6%B3%95/%E7%AB%9E%E8%B5%9B/LeetCode%E5%91%A8%E8%B5%9B/248/"/>
    
    
      <category term="算法" scheme="https://accepted.org.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="LeetCode" scheme="https://accepted.org.cn/tags/LeetCode/"/>
    
      <category term="竞赛" scheme="https://accepted.org.cn/tags/%E7%AB%9E%E8%B5%9B/"/>
    
      <category term="贪心" scheme="https://accepted.org.cn/tags/%E8%B4%AA%E5%BF%83/"/>
    
  </entry>
  
  <entry>
    <title>【LeetCode周赛247】C LeetCode 1915. 最美子字符串的数目</title>
    <link href="https://accepted.org.cn/2021/07/03/%E3%80%90LeetCode%E5%91%A8%E8%B5%9B247%E3%80%91C-LeetCode-1915-%E6%9C%80%E7%BE%8E%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%95%B0%E7%9B%AE/"/>
    <id>https://accepted.org.cn/2021/07/03/%E3%80%90LeetCode%E5%91%A8%E8%B5%9B247%E3%80%91C-LeetCode-1915-%E6%9C%80%E7%BE%8E%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%95%B0%E7%9B%AE/</id>
    <published>2021-07-03T15:51:04.000Z</published>
    <updated>2021-07-05T16:49:13.415Z</updated>
    
    <content type="html"><![CDATA[<p><strong>摘要：</strong><br>将奇偶性的状态压缩成一个二进制数字。</p><a id="more"></a><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>如果某个字符串中 至多一个 字母出现 <strong>奇数</strong> 次，则称其为 <strong>最美</strong> 字符串。</p><ul><li>例如，$ccjjc$ 和 $abab$ 都是最美字符串，但 $ab$ 不是。</li></ul><p>给你一个字符串 $word$ ，该字符串由前十个小写英文字母组成（$a$ 到 $j$）。请你返回 $word$ 中 <strong>最美非空子字符串</strong> 的数目。如果同样的子字符串在 $word$ 中出现多次，那么应当对 <strong>每次出现</strong> 分别计数。</p><p><strong>子字符串</strong> 是字符串中的一个连续字符序列。</p><p><strong>示例 1：</strong></p><blockquote><p>输入：word = “aba”<br>输出：4<br>解释：4 个最美子字符串如下所示：<br>– “aba” -&gt; “a”<br>– “aba” -&gt; “b”<br>– “aba” -&gt; “a”<br>– “aba” -&gt; “aba”</p></blockquote><p><strong>示例 2：</strong></p><blockquote><p>输入：word = “aabb”<br>输出：9<br>解释：9 个最美子字符串如下所示：<br>– “aabb” -&gt; “a”<br>– “aabb” -&gt; “aa”<br>– “aabb” -&gt; “aab”<br>– “aabb” -&gt; “aabb”<br>– “aabb” -&gt; “a”<br>– “aabb” -&gt; “abb”<br>– “aabb” -&gt; “b”<br>– “aabb” -&gt; “bb”<br>– “aabb” -&gt; “b”</p></blockquote><p><strong>示例 3：</strong></p><blockquote><p>输入：word = “he”<br>输出：2<br>解释：2 个最美子字符串如下所示：<br>– “he” -&gt; “h”<br>– “he” -&gt; “e”</p></blockquote><p><strong>提示：</strong></p><ul><li>$1 &lt;= word.length &lt;= 10^5$</li><li>$word$ 由从 $a$ 到 $j$ 的小写英文字母组成</li></ul><hr><h3 id="前缀和"><a href="#前缀和" class="headerlink" title="前缀和"></a>前缀和</h3><p>根据题意，在某个最美子串中，所有的字母出现的的次数要么全为偶数次，要么有一位字母出现了奇数次。<br>很容易想到使用前缀和快速拿到出现次数。配合暴力枚举子串，复杂度为 $n \times (n + 1) / 2$，必然超时。</p><p>定义前缀和数组 $presum[N][j]$，其中 $1 &lt;= N &lt;= 10^5$, $j = 10$. $presum[i][j]$ 表示在原字符串中从第 $1$ 位开始到第 $i$ 位结尾的子串某个字母出现的次数。</p><p>那么一段下标为 $[a, b]$ 的子串，它的某个字母 $j$ 出现次数可表示为 $presum[b][j] - presum[a - 1][j]$。 根据数学知识，如果它是一个奇数，那么 $presum[b][j]$ 和 $presum[a - 1][j]$ 奇偶性不同，反之相同。</p><p>那么问题就变成了：在字符串所有子串中，每个字母对应的 $presum[b][j]$ 和 $presum[a - 1][j]$ 奇偶性不同的情况最多只能出现一次的子串一共多少。</p><p>现在对前缀和数组的某一项的每一位字母出现的奇偶性状态进行压缩。<br>对于某个子串，我们可以将出现奇数次的字母记为 $1$，将出现偶数次的字母记为 $0$.由于字母范围为字母表前 $10$ 个，那么一段子串的每一位字母出现次数的奇偶性状态可表示为一个 $10$ 位的二进制数。</p><p>$presum[b][j]$ 和 $presum[a - 1][j]$ 的各字母出现奇偶性的状态都可以表示成一个 $10$ 位二进制数。<br>对于以下标 $b$ 结尾的前缀子串的奇偶性状态，以下标 $a$ 结尾的子串共有 $11$ 种对应的状态可以满足奇偶性不同的情况最多一次的条件。其中，完全和该状态相同的状态表示奇偶性不同的情况出现 $0$ 次，即奇偶性完全相同；另外 $10$ 种对应着原状态的 $10$ 位奇偶状态的某一位不同。<br>比如一个状态为：<code>0001000110</code>. 满足条件的 $11$ 种状态如下：<br><code>0001000110</code><br><code>1001000110</code><br><code>0101000110</code><br><code>0011000110</code><br><code>0000000110</code><br><code>0001100110</code><br><code>0001010110</code><br><code>0001001110</code><br><code>0001000010</code><br><code>0001000100</code><br><code>0001000111</code><br>那么我们考虑遍历字符串，当遍历到第 $b$ 位时，枚举上述 $11$ 种状态，如果之前出现过其中一种或多种，那么以那一种或多种对应下标开始到 $b$ 结束的子串即满足要求。</p><p>所以我们需要一个计数数组，将从第 $1$ 个字符开始到遍历到的每一位字符结束的状态数量记录下来供后面使用。<br>考虑到二进制状态数字最高 $10$ 位，所以可以开一个数量为 $10000000000_2$（$1024_{10}$）的计数数组.</p><p>另外，思考一下计数数组的第 $0$ 位初始化为什么应该是 $1$.<br>在字符串第 $0$ 位之前，存在一个状态 <code>0000000000</code>，它表示每一位字母出现了 $0$ 次（均为偶数）。所以这种状态在遍历之前计数为 $1$.</p><p>举例：对于一个字符串 $a$ 来说，它的最美子串数目为 $1$. 我们初始化状态 <code>0000000000</code> 的数量为 $1$，这样，在遍历到字符串第 $0$ 个数的时候状态为 <code>1000000000</code>，$11$ 个期望的状态中共有一种符合与之构成最美子串的状态，即初始化的 <code>0000000000</code>. 这两个状态有一位字母的出现的奇偶性不同。对应子串为 $a$.</p><div class="tabs" id="g_tab0"><ul class="nav-tabs"><li class="tab active"><a href="#g_tab0-1">C++</a></li></ul><div class="tab-content"><div class="tab-pane active" id="g_tab0-1"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">int</span> N = <span class="number">1024</span>;</span><br><span class="line">    <span class="keyword">int</span> cnt[N];    </span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> res;</span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">wonderfulSubstrings</span><span class="params">(<span class="built_in">string</span> <span class="keyword">word</span>)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = <span class="keyword">word</span>.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">presum</span><span class="params">(len + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; (<span class="number">10</span>, <span class="number">0</span>))</span></span>;</span><br><span class="line">        <span class="built_in">memset</span>(cnt, <span class="number">0</span>, <span class="keyword">sizeof</span> cnt);</span><br><span class="line">        cnt[<span class="number">0</span>]++;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="keyword">char</span> c = <span class="keyword">word</span>[i];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">10</span>; j++) &#123;</span><br><span class="line">                presum[i + <span class="number">1</span>][j] = presum[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">            presum[i + <span class="number">1</span>][c - <span class="string">'a'</span>]++;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">            for (int j = 0; j &lt; 10; j++) &#123;</span></span><br><span class="line"><span class="comment">                cout &lt;&lt; presum[i + 1][j] &lt;&lt; ' ';</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">            cout &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            <span class="keyword">int</span> state = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">10</span>; j++)</span><br><span class="line">                state = state * <span class="number">2</span> + presum[i + <span class="number">1</span>][j] % <span class="number">2</span>;    <span class="comment">// 跟10进制一样的。一段十进制序列转换成十进制数：for (int j = 0; j &lt; len; j++) res = res * 10 + seq[j];</span></span><br><span class="line">            <span class="comment">// 对于当前以i结尾的字符串，根据当前状态枚举每一种可能的状态，通过cnt数组查看之前有没有出现过</span></span><br><span class="line">            <span class="comment">// 首先是完全一样的状态，如果在[0, i - 1]这一段出现过跟以i结尾的字符串完全一致的状态，那么它们构成的子串有0个字母出现了奇数次</span></span><br><span class="line">            res += cnt[state];</span><br><span class="line">            <span class="comment">// 其次是10种不同状态，每种有一位和当前状态不同</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">10</span>; j++) &#123;</span><br><span class="line">                res += cnt[state ^ (<span class="number">1</span> &lt;&lt; j)];</span><br><span class="line">            &#125;</span><br><span class="line">            cnt[state]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div></div></div><p>代码涉及到的两个额外知识，且都和位运算有关:</p><ol><li><p>将一段二进制序列转换成十进制数：<br>对于以下标b结束的前缀和字母计数序列，需要将它的各位奇偶性状态压缩成一个二进制数。代码是：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> state = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">10</span>; j++)</span><br><span class="line">    state = state * <span class="number">2</span> + presum[i + <span class="number">1</span>][j] % <span class="number">2</span>;</span><br></pre></td></tr></table></figure></li><li><p>一个二进制数 $x$，它的距离最低位 $k$ 个数字不同且其他位相同的二进制数为：<br><code>x ^ (1 &lt;&lt; k)</code></p></li></ol><div class="note primary">            <p><strong>原题链接：</strong> <a href="https://leetcode-cn.com/problems/number-of-wonderful-substrings/" target="_blank" rel="noopener">LeetCode 1915. 最美子字符串的数目</a></p>          </div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;摘要：&lt;/strong&gt;&lt;br&gt;将奇偶性的状态压缩成一个二进制数字。&lt;/p&gt;
    
    </summary>
    
    
      <category term="指尖飞舞" scheme="https://accepted.org.cn/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/"/>
    
      <category term="算法" scheme="https://accepted.org.cn/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/%E7%AE%97%E6%B3%95/"/>
    
      <category term="LeetCode" scheme="https://accepted.org.cn/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/%E7%AE%97%E6%B3%95/LeetCode/"/>
    
      <category term="竞赛" scheme="https://accepted.org.cn/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/%E7%AE%97%E6%B3%95/%E7%AB%9E%E8%B5%9B/"/>
    
      <category term="LeetCode周赛" scheme="https://accepted.org.cn/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/%E7%AE%97%E6%B3%95/%E7%AB%9E%E8%B5%9B/LeetCode%E5%91%A8%E8%B5%9B/"/>
    
      <category term="247" scheme="https://accepted.org.cn/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/%E7%AE%97%E6%B3%95/%E7%AB%9E%E8%B5%9B/LeetCode%E5%91%A8%E8%B5%9B/247/"/>
    
    
      <category term="算法" scheme="https://accepted.org.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="LeetCode" scheme="https://accepted.org.cn/tags/LeetCode/"/>
    
      <category term="前缀和" scheme="https://accepted.org.cn/tags/%E5%89%8D%E7%BC%80%E5%92%8C/"/>
    
      <category term="位运算" scheme="https://accepted.org.cn/tags/%E4%BD%8D%E8%BF%90%E7%AE%97/"/>
    
      <category term="竞赛" scheme="https://accepted.org.cn/tags/%E7%AB%9E%E8%B5%9B/"/>
    
  </entry>
  
  <entry>
    <title>【LeetCode双周赛55】C LeetCode 1911. 最大子序列交替和</title>
    <link href="https://accepted.org.cn/2021/07/03/%E3%80%90LeetCode%E5%8F%8C%E5%91%A8%E8%B5%9B55%E3%80%91C-LeetCode-1911-%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%88%97%E4%BA%A4%E6%9B%BF%E5%92%8C/"/>
    <id>https://accepted.org.cn/2021/07/03/%E3%80%90LeetCode%E5%8F%8C%E5%91%A8%E8%B5%9B55%E3%80%91C-LeetCode-1911-%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%88%97%E4%BA%A4%E6%9B%BF%E5%92%8C/</id>
    <published>2021-07-03T04:50:36.000Z</published>
    <updated>2021-07-05T16:49:27.747Z</updated>
    
    <content type="html"><![CDATA[<p><strong>摘要：</strong><br>经典的状态机类型的dp问题。</p><a id="more"></a><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>一个下标从 $0$ 开始的数组的 <strong>交替和</strong> 定义为 <strong>偶数</strong> 下标处元素之 <strong>和</strong> 减去 <strong>奇数</strong> 下标处元素之 <strong>和</strong> 。</p><ul><li>比方说，数组 $[4,2,5,3]$ 的交替和为 $(4 + 5) - (2 + 3) = 4$ 。</li></ul><p>给你一个数组 $nums$ ，请你返回 $nums$ 中任意子序列的 <strong>最大交替和</strong> （子序列的下标 <strong>重新</strong> 从 $0$ 开始编号）。</p><p>一个数组的 <strong>子序列</strong> 是从原数组中删除一些元素后（也可能一个也不删除）剩余元素不改变顺序组成的数组。比方说，$[2,7,4]$ 是 $[4,2,3,7,2,1,4]$ 的一个子序列（加粗元素），但是 $[2,4,2]$ 不是。</p><p><strong>示例 1：</strong></p><blockquote><p>输入：nums = [4,2,5,3]<br>输出：7<br>解释：最优子序列为 [4,2,5] ，交替和为 (4 + 5) - 2 = 7 。</p></blockquote><p><strong>示例 2：</strong></p><blockquote><p>输入：nums = [5,6,7,8]<br>输出：8<br>解释：最优子序列为 [8] ，交替和为 8 。</p></blockquote><p><strong>示例 3：</strong></p><p>输入：nums = [6,2,1,2,4,5]<br>输出：10<br>解释：最优子序列为 [6,1,5] ，交替和为 (6 + 5) - 1 = 10 。</p><p><strong>提示：</strong></p><ul><li>$1 &lt;= nums.length &lt;= 10^5$</li><li>$1 &lt;= nums[i] &lt;= 10^5$</li></ul><hr><h3 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h3><p><strong>状态集合：</strong> 前 $i$ 个数字，数字总数为偶数的子序列与前 $i$ 个数字，数字总数为奇数的子序列构成的集合。</p><p><strong>状态集合元素属性：</strong> 对于集合中的每个元素（子序列），定义子序列的交替和的最大值为元素属性。</p><p><strong>状态计算：</strong> 设 $f[i][0]$ 为前 $i$ 个数字，数字总数为偶数的子序列的最大交替和；设 $f[i][1]$ 为前 $i$ 个数字，数字总数为奇数的子序列的最大交替和；</p><p>对前 $i$ 个数字依次计算两种交替和：</p><ul><li><p>前 $i$ 个数字，子序列总数为偶数时，最后一个数字 $nums[i]$ 可取可不取。</p><ul><li><p>取第 $i$ 个数字时，对于整个构成的子序列而言，由原数组前 $i - 1$ 个数字构成的子序列前部分总数一定是奇数，那么问题就变成了，由原数组前 $i - 1$ 个数字构成的总数为奇数的子序列的最大交替和与第 $i$ 项数字共同构成的子序列的最大交替和是多少。因为子序列下标从 $0$ 开始计算，取最后一项后总数是偶数，那么最后一项在子序列中的下标一定是奇数。由交替和的定义可知：</p><p>$f[i][0] = f[i - 1][1] - nums[i]$</p></li><li><p>不取第 $i$ 个数字时，我们从前 $i - 1$ 项来考虑。我们现在假设由原数组前 $i - 1$ 项构成的子序列总数是偶数，现在有第 $i$ 项存在，但是我们不取，那么原数组前 $i$ 项构成的子序列总数依然是偶数，且有：</p><p>$f[i][0] = f[i - 1][0]$</p></li><li><p>将上述两种情况合并有：</p><p>$f[i][0] = max(f[i - 1][0], f[i - 1][1] - nums[i])$</p></li></ul></li><li><p>前i个数字，子序列总数为奇数时，最后一个数字 $nums[i]$ 也是可取可不取。</p><ul><li><p>取第 $i$ 个数字时，这里又分为两种情况：</p><ul><li><p>取了之后放弃子序列中所有前面的值，只留原数组第 $i$ 个数，总数依旧是奇数。<br>那么有：</p><p>$f[i][1] = 0 + nums[i]$</p></li><li><p>取了之后保留子序列中所有前面的值，对于整个构成的子序列而言，由原数组前 $i - 1$ 个数字构成的子序列前部分总数一定是偶数，那么问题就变成了，由原数组前 $i - 1$ 个数字构成的总数为偶数的子序列的最大交替和与第 $i$ 项数字共同构成的子序列的最大交替和是多少。因为子序列下标从 $0$ 开始计算，取最后一项后总数是奇数，那么最后一项在子序列中的下标一定是偶数。由交替和的定义可知：</p><p>$f[i][1] = f[i - 1][1] + nums[i]$</p></li><li><p>将这两种子情况合并有：</p><p>$f[i][1] = max(0 + f[i - 1][1]) + nums[i]$</p></li></ul></li><li><p>不取第 $i$ 个数字时，我们从前 $i - 1$ 项来考虑。我们现在假设由原数组前 $i - 1$ 项构成的子序列总数是奇数，现在有第 $i$ 项存在，但是我们不取，那么原数组前 $i$ 项构成的子序列总数依然是奇数，且有：</p><p>$f[i][1] = f[i - 1][1]$</p></li><li><p>将上述两种情况合并有：</p><p>$f[i][1] = max(f[i - 1][1], max(0 + f[i - 1][1]) + nums[i])$</p></li></ul></li></ul><div class="tabs" id="g_tab0"><ul class="nav-tabs"><li class="tab active"><a href="#g_tab0-1">C++</a></li></ul><div class="tab-content"><div class="tab-pane active" id="g_tab0-1"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">maxAlternatingSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="comment">// dp[i][0]: 前 i 个数，总数为偶数的子序列的最大交替和</span></span><br><span class="line">        <span class="comment">// dp[i][1]: 前 i 个数，总数为奇数的子序列的最大交替和</span></span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt;&gt; <span class="title">dp</span><span class="params">(n, <span class="built_in">vector</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt;(<span class="number">2</span>, <span class="number">0</span>))</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>, dp[<span class="number">0</span>][<span class="number">1</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="comment">// 考虑前i个数中子序列总数为偶数的情况</span></span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][<span class="number">0</span>], dp[i - <span class="number">1</span>][<span class="number">1</span>] - nums[i]);</span><br><span class="line">            <span class="comment">// 考虑前i个数中子序列总数为奇数的情况</span></span><br><span class="line">            dp[i][<span class="number">1</span>] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][<span class="number">1</span>], <span class="built_in">max</span>(<span class="number">0l</span>l, dp[i - <span class="number">1</span>][<span class="number">0</span>]) + nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(dp[n - <span class="number">1</span>][<span class="number">0</span>], dp[n - <span class="number">1</span>][<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div></div></div><p>仔细观察不难发现，dp数组每一项都是非负的（因为原数组每一项取值为$1 &lt;= nums[i] &lt;= 10^5$，且dp数组的初始项非负，且后序计算是不断地取最大值扩展的），那么 <code>max(0ll, dp[i - 1][0]) + nums[i]</code> 可以优化成 <code>dp[i - 1][0] + nums[i]</code>.</p><div class="note primary">            <p><strong>原题链接：</strong> <a href="https://leetcode-cn.com/problems/maximum-alternating-subsequence-sum/" target="_blank" rel="noopener">LeetCode 1911. 最大子序列交替和</a></p>          </div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;摘要：&lt;/strong&gt;&lt;br&gt;经典的状态机类型的dp问题。&lt;/p&gt;
    
    </summary>
    
    
      <category term="指尖飞舞" scheme="https://accepted.org.cn/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/"/>
    
      <category term="算法" scheme="https://accepted.org.cn/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/%E7%AE%97%E6%B3%95/"/>
    
      <category term="LeetCode" scheme="https://accepted.org.cn/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/%E7%AE%97%E6%B3%95/LeetCode/"/>
    
      <category term="竞赛" scheme="https://accepted.org.cn/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/%E7%AE%97%E6%B3%95/%E7%AB%9E%E8%B5%9B/"/>
    
      <category term="LeetCode双周赛" scheme="https://accepted.org.cn/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/%E7%AE%97%E6%B3%95/%E7%AB%9E%E8%B5%9B/LeetCode%E5%8F%8C%E5%91%A8%E8%B5%9B/"/>
    
      <category term="55" scheme="https://accepted.org.cn/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/%E7%AE%97%E6%B3%95/%E7%AB%9E%E8%B5%9B/LeetCode%E5%8F%8C%E5%91%A8%E8%B5%9B/55/"/>
    
    
      <category term="算法" scheme="https://accepted.org.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="LeetCode" scheme="https://accepted.org.cn/tags/LeetCode/"/>
    
      <category term="动态规划" scheme="https://accepted.org.cn/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
      <category term="竞赛" scheme="https://accepted.org.cn/tags/%E7%AB%9E%E8%B5%9B/"/>
    
      <category term="状态机" scheme="https://accepted.org.cn/tags/%E7%8A%B6%E6%80%81%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 451. 根据字符出现频率排序</title>
    <link href="https://accepted.org.cn/2021/07/03/LeetCode-451-%E6%A0%B9%E6%8D%AE%E5%AD%97%E7%AC%A6%E5%87%BA%E7%8E%B0%E9%A2%91%E7%8E%87%E6%8E%92%E5%BA%8F/"/>
    <id>https://accepted.org.cn/2021/07/03/LeetCode-451-%E6%A0%B9%E6%8D%AE%E5%AD%97%E7%AC%A6%E5%87%BA%E7%8E%B0%E9%A2%91%E7%8E%87%E6%8E%92%E5%BA%8F/</id>
    <published>2021-07-03T01:14:28.000Z</published>
    <updated>2021-07-03T01:27:42.861Z</updated>
    
    <content type="html"><![CDATA[<p><strong>摘要：</strong><br>STL sort() 配合Lambda表达式排序。</p><a id="more"></a><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给定一个字符串，请将字符串里的字符按照出现的频率降序排列。</p><p><strong>示例 1:</strong></p><p>输入:</p><blockquote><p>“tree”<br>输出:<br>“eert”<br>解释:<br>‘e’出现两次，’r’和’t’都只出现一次。<br>因此’e’必须出现在’r’和’t’之前。此外，”eetr”也是一个有效的答案。</p></blockquote><p><strong>示例 2:</strong></p><p>输入:</p><blockquote><p>“cccaaa”<br>输出:<br>“cccaaa”<br>解释:<br>‘c’和’a’都出现三次。此外，”aaaccc”也是有效的答案。<br>注意”cacaca”是不正确的，因为相同的字母必须放在一起。</p></blockquote><p><strong>示例 3:</strong></p><p>输入:</p><blockquote><p>“Aabb”<br>输出:<br>“bbAa”<br>解释:<br>此外，”bbaA”也是一个有效的答案，但”Aabb”是不正确的。<br>注意’A’和’a’被认为是两种不同的字符。</p></blockquote><hr><h3 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h3><p>先将字符计数，再根据计数来排序。<br>需要注意的地方是，当两个不同字符频率相同时，可能会出现顺序打乱的情况，比如说 $a$ 出现 $2$ 次，$b$ 出现 $2$ 次，那么输出可能是 $abab$。<br>为了避免这样的情况，我们需要在不同字符出现相同频率后再按照ascii码排序。</p><div class="tabs" id="g_tab0"><ul class="nav-tabs"><li class="tab active"><a href="#g_tab0-1">C++</a></li></ul><div class="tab-content"><div class="tab-pane active" id="g_tab0-1"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">frequencySort</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; cnt;</span><br><span class="line">        <span class="keyword">int</span> len = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">            cnt[s[i]]++;</span><br><span class="line">        sort(s.<span class="built_in">begin</span>(), s.<span class="built_in">end</span>(), [&amp;](<span class="keyword">char</span> a, <span class="keyword">char</span> b) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cnt[a] != cnt[b]) <span class="keyword">return</span> cnt[a] &gt;= cnt[b];</span><br><span class="line">            <span class="keyword">return</span> a &lt; b;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div></div></div><p>为什么要用Lambda呢，因为leetcode排序 <code>cmp</code> 如果写在类里面需要加 <code>static</code> (不加会隐式的加上this指针)，<code>cmp</code> 中需要用到 <code>cnt</code> 数组或者哈希表，这时候就需要将 <code>cnt</code> 数组或者哈希表放在类变量中或者类外面。如果放在类变量中，因为 <code>cmp</code> 函数时 <code>static</code> 的，那么 <code>cnt</code> 数组或者哈希表也需要是 <code>static</code> 的，就会出现一些很奇怪的问题。如果放在类外面，因为leetcode的问题也会出现一些很奇怪的问题比如执行测试用例可以过但是提交评测无法通过的情况。具体请看：<br><a href="https://eetoa.github.io/2021/06/06/在LeetCode刷题应尽量避免使用全局变量/" target="_blank" rel="noopener">在LeetCode刷题应尽量避免使用全局变量</a></p><div class="note primary">            <p><strong>原题链接：</strong> <a href="https://leetcode-cn.com/problems/sort-characters-by-frequency/" target="_blank" rel="noopener">LeetCode 451. 根据字符出现频率排序</a></p>          </div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;摘要：&lt;/strong&gt;&lt;br&gt;STL sort() 配合Lambda表达式排序。&lt;/p&gt;
    
    </summary>
    
    
      <category term="指尖飞舞" scheme="https://accepted.org.cn/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/"/>
    
      <category term="算法" scheme="https://accepted.org.cn/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/%E7%AE%97%E6%B3%95/"/>
    
      <category term="LeetCode" scheme="https://accepted.org.cn/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/%E7%AE%97%E6%B3%95/LeetCode/"/>
    
    
      <category term="算法" scheme="https://accepted.org.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="LeetCode" scheme="https://accepted.org.cn/tags/LeetCode/"/>
    
      <category term="排序" scheme="https://accepted.org.cn/tags/%E6%8E%92%E5%BA%8F/"/>
    
      <category term="字符串" scheme="https://accepted.org.cn/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
  </entry>
  
  <entry>
    <title>【LeetCode周赛247】B LeetCode 1914. 循环轮转矩阵</title>
    <link href="https://accepted.org.cn/2021/07/02/%E3%80%90LeetCode%E5%91%A8%E8%B5%9B247%E3%80%91B-LeetCode-1914-%E5%BE%AA%E7%8E%AF%E8%BD%AE%E8%BD%AC%E7%9F%A9%E9%98%B5/"/>
    <id>https://accepted.org.cn/2021/07/02/%E3%80%90LeetCode%E5%91%A8%E8%B5%9B247%E3%80%91B-LeetCode-1914-%E5%BE%AA%E7%8E%AF%E8%BD%AE%E8%BD%AC%E7%9F%A9%E9%98%B5/</id>
    <published>2021-07-02T14:12:30.000Z</published>
    <updated>2021-07-05T16:49:33.853Z</updated>
    
    <content type="html"><![CDATA[<p><strong>摘要：</strong><br>一道模拟过程的题目，不难，但是有点繁琐。</p><a id="more"></a><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给你一个大小为 $m \times n$ 的整数矩阵 $grid$​​​ ，其中 $m$ 和 $n$ 都是 <strong>偶数</strong> ；另给你一个整数 $k$ 。</p><p>矩阵由若干层组成，如下图所示，每种颜色代表一层：</p><p><img src="0.png" alt="0x0"></p><p>矩阵的循环轮转是通过分别循环轮转矩阵中的每一层完成的。在对某一层进行一次循环旋转操作时，层中的每一个元素将会取代其 <strong>逆时针</strong> 方向的相邻元素。轮转示例如下：</p><p><img src="1.jpg" alt="0x1"><br>返回执行 $k$ 次循环轮转操作后的矩阵。</p><p><strong>示例 1：</strong></p><p><img src="2.png" alt="0x2"></p><blockquote><p>输入：grid = [[40,10],[30,20]], k = 1<br>输出：[[10,20],[40,30]]<br>解释：上图展示了矩阵在执行循环轮转操作时每一步的状态。</p></blockquote><p><strong>示例 2：</strong></p><p><img src="3.png" alt="0x3"></p><p><img src="4.png" alt="0x3"></p><p><img src="5.png" alt="0x3"></p><blockquote><p>输入：grid = [[1,2,3,4],[5,6,7,8],[9,10,11,12],[13,14,15,16]], k = 2<br>输出：[[3,4,8,12],[2,11,10,16],[1,7,6,15],[5,9,13,14]]<br>解释：上图展示了矩阵在执行循环轮转操作时每一步的状态。</p></blockquote><hr><h3 id="模拟"><a href="#模拟" class="headerlink" title="模拟"></a>模拟</h3><p>将每一层放到一个队列中，再计算出每一层的每一位对应轮转 $k$ 次后在队列中的什么位置。<br>将每一层分为 $4$ 次分别处理入队，分别是上右下左，依次是行不变列增加；行增加列不变；行不变列减小；行减小列减小。<br>另外注意不能数组原地替换，因为前面被替换的数原本包含着最后的要替换的数的数。所以需要额外维护一个同样大小的数组。</p><div class="tabs" id="g_tab0"><ul class="nav-tabs"><li class="tab active"><a href="#g_tab0-1">C++</a></li></ul><div class="tab-content"><div class="tab-pane active" id="g_tab0-1"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">rotateGrid</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> R = grid.<span class="built_in">size</span>(), C = grid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">res</span><span class="params">(R, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(C, <span class="number">0</span>))</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> mxr = R, mxc = C, <span class="built_in">begin</span> = <span class="number">0</span>; mxr &gt; <span class="number">0</span> &amp;&amp; mxc &gt; <span class="number">0</span>; mxr -= <span class="number">2</span>, mxc -= <span class="number">2</span>, ++<span class="built_in">begin</span>) &#123; <span class="comment">// 逐层将坐标放入数组中</span></span><br><span class="line">            <span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; &gt; <span class="built_in">queue</span>;</span><br><span class="line">            <span class="keyword">int</span> r = <span class="built_in">begin</span>, c = <span class="built_in">begin</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; mxc - <span class="number">1</span>; i++) <span class="built_in">queue</span>.emplace_back(r, ++c);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; mxr - <span class="number">1</span>; i++) <span class="built_in">queue</span>.emplace_back(++r, c);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; mxc - <span class="number">1</span>; i++) <span class="built_in">queue</span>.emplace_back(r, --c);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; mxr - <span class="number">1</span>; i++) <span class="built_in">queue</span>.emplace_back(--r, c);</span><br><span class="line">            <span class="comment">//for (auto &amp;each : queue) cout &lt;&lt; grid[each.first][each.second] &lt;&lt; " ";</span></span><br><span class="line">            <span class="comment">//cout &lt;&lt; endl;</span></span><br><span class="line">            <span class="keyword">int</span> len = <span class="built_in">queue</span>.<span class="built_in">size</span>();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">                <span class="keyword">int</span> t = (i + k) % len;</span><br><span class="line">                res[<span class="built_in">queue</span>[i].first][<span class="built_in">queue</span>[i].second] = grid[<span class="built_in">queue</span>[t].first][<span class="built_in">queue</span>[t].second];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div></div></div><h3 id="模拟-DFS"><a href="#模拟-DFS" class="headerlink" title="模拟 + DFS"></a>模拟 + DFS</h3><p>我的思路是先确定一共需要进行多少层轮转，对于每一层的每一次轮转写进行一次深搜，一共 $k$ 次，注意 $k$ 需要对一层的总数取模。</p><p>核心在于如何对指定层进行一次轮转。</p><p>深搜从每一层的左上角开始，所以我们要确定每一层的第一个数坐标。<br>深搜过程中到达拐点处需要改变搜索方向，所以我们需要知道每一层的长和宽。<br>另外我们需要对搜索过的格子进行计数，以便判断递归终止。</p><div class="tabs" id="g_tab1"><ul class="nav-tabs"><li class="tab active"><a href="#g_tab1-1">C++</a></li></ul><div class="tab-content"><div class="tab-pane active" id="g_tab1-1"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">int</span> dr[<span class="number">4</span>] = &#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span>&#125;, dc[<span class="number">4</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> R, C;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">rotateGrid</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        R = grid.<span class="built_in">size</span>(), C = grid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> level = <span class="built_in">min</span>(R, C) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//cout &lt;&lt; level &lt;&lt; endl;</span></span><br><span class="line">        <span class="comment">//return res;</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, mod = <span class="number">0</span>; i &lt; level; i++) &#123;</span><br><span class="line">            mod = <span class="number">2</span> * (R - i * <span class="number">2</span>) + <span class="number">2</span> * (C - i * <span class="number">2</span>) - <span class="number">4</span>;</span><br><span class="line">            <span class="comment">//cout &lt;&lt; mod &lt;&lt; endl;</span></span><br><span class="line">            <span class="keyword">int</span> t = k % mod;</span><br><span class="line">            rotation(grid, i, t, mod, R - i * <span class="number">2</span>, C - i * <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> grid;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="keyword">inline</span> <span class="title">rotation</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; &amp;g, <span class="keyword">int</span> level, <span class="keyword">int</span> k, <span class="keyword">int</span> mod, <span class="keyword">int</span> mxr, <span class="keyword">int</span> mxc)</span> </span>&#123;</span><br><span class="line">        pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; start = &#123;<span class="number">0</span> + level * <span class="number">1</span>, <span class="number">0</span> + level * <span class="number">1</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> direction = <span class="number">0</span>; k--; direction = <span class="number">0</span>) &#123;</span><br><span class="line">            dfs(<span class="number">0</span>, g, start, start, <span class="number">0</span>, mod, mxr, mxc, direction);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;   </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> value, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; &amp;g, pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; &amp;start, pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; pos, <span class="keyword">int</span> cnt, <span class="keyword">int</span> &amp;mod, <span class="keyword">int</span> &amp;mxr, <span class="keyword">int</span> &amp;mxc, <span class="keyword">int</span> &amp;direction)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//cout &lt;&lt; pos.first &lt;&lt; ',' &lt;&lt; pos.second &lt;&lt; "," &lt;&lt; cnt &lt;&lt; ',' &lt;&lt; mod &lt;&lt;endl;</span></span><br><span class="line">        <span class="keyword">if</span> (cnt == mod) &#123;</span><br><span class="line">            g[pos.first][pos.second] = value;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> nevalue = g[pos.first][pos.second];</span><br><span class="line">        g[pos.first][pos.second] = value;</span><br><span class="line">        <span class="keyword">if</span> ((pos.first == start.first + mxr - <span class="number">1</span> &amp;&amp; pos.second == start.second) || (pos.first == start.first + mxr - <span class="number">1</span> &amp;&amp; pos.second == start.second + mxc - <span class="number">1</span>) || (pos.first == start.first &amp;&amp; pos.second == start.second + mxc - <span class="number">1</span>)) &#123;</span><br><span class="line">            direction++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ner = pos.first + dr[direction], nec = pos.second + dc[direction];</span><br><span class="line">        dfs(nevalue, g, start, &#123;ner, nec&#125;, cnt + <span class="number">1</span>, mod, mxr, mxc, direction);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div></div></div><div class="note primary">            <p><strong>原题链接：</strong> <a href="https://leetcode-cn.com/problems/cyclically-rotating-a-grid/submissions/" target="_blank" rel="noopener">LeetCode 1914. 循环轮转矩阵</a></p>          </div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;摘要：&lt;/strong&gt;&lt;br&gt;一道模拟过程的题目，不难，但是有点繁琐。&lt;/p&gt;
    
    </summary>
    
    
      <category term="指尖飞舞" scheme="https://accepted.org.cn/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/"/>
    
      <category term="算法" scheme="https://accepted.org.cn/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/%E7%AE%97%E6%B3%95/"/>
    
      <category term="LeetCode" scheme="https://accepted.org.cn/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/%E7%AE%97%E6%B3%95/LeetCode/"/>
    
      <category term="竞赛" scheme="https://accepted.org.cn/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/%E7%AE%97%E6%B3%95/%E7%AB%9E%E8%B5%9B/"/>
    
      <category term="LeetCode周赛" scheme="https://accepted.org.cn/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/%E7%AE%97%E6%B3%95/%E7%AB%9E%E8%B5%9B/LeetCode%E5%91%A8%E8%B5%9B/"/>
    
      <category term="247" scheme="https://accepted.org.cn/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/%E7%AE%97%E6%B3%95/%E7%AB%9E%E8%B5%9B/LeetCode%E5%91%A8%E8%B5%9B/247/"/>
    
    
      <category term="算法" scheme="https://accepted.org.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="LeetCode" scheme="https://accepted.org.cn/tags/LeetCode/"/>
    
      <category term="竞赛" scheme="https://accepted.org.cn/tags/%E7%AB%9E%E8%B5%9B/"/>
    
      <category term="模拟" scheme="https://accepted.org.cn/tags/%E6%A8%A1%E6%8B%9F/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 1833. 雪糕的最大数量</title>
    <link href="https://accepted.org.cn/2021/07/02/LeetCode-1833-%E9%9B%AA%E7%B3%95%E7%9A%84%E6%9C%80%E5%A4%A7%E6%95%B0%E9%87%8F/"/>
    <id>https://accepted.org.cn/2021/07/02/LeetCode-1833-%E9%9B%AA%E7%B3%95%E7%9A%84%E6%9C%80%E5%A4%A7%E6%95%B0%E9%87%8F/</id>
    <published>2021-07-02T00:41:56.000Z</published>
    <updated>2021-07-02T00:50:11.348Z</updated>
    
    <content type="html"><![CDATA[<p><strong>摘要：</strong><br>排序+贪心题。</p><a id="more"></a><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>夏日炎炎，小男孩 Tony 想买一些雪糕消消暑。</p><p>商店中新到 $n$ 支雪糕，用长度为 $n$ 的数组 $costs$ 表示雪糕的定价，其中 $costs[i]$ 表示第 $i$ 支雪糕的现金价格。Tony 一共有 $coins$ 现金可以用于消费，他想要买尽可能多的雪糕。</p><p>给你价格数组 $costs$ 和现金量 $coins$ ，请你计算并返回 Tony 用 $coins$ 现金能够买到的雪糕的 <strong>最大数量</strong> 。</p><p>注意：Tony 可以按任意顺序购买雪糕。</p><p><strong>示例 1：</strong></p><blockquote><p>输入：costs = [1,3,2,4,1], coins = 7<br>输出：4<br>解释：Tony 可以买下标为 0、1、2、4 的雪糕，总价为 1 + 3 + 2 + 1 = 7</p></blockquote><p><strong>示例 2：</strong></p><blockquote><p>输入：costs = [10,6,8,7,7,8], coins = 5<br>输出：0<br>解释：Tony 没有足够的钱买任何一支雪糕。</p></blockquote><p><strong>示例 3：</strong></p><blockquote><p>输入：costs = [1,6,3,1,2,5], coins = 20<br>输出：6<br>解释：Tony 可以买下所有的雪糕，总价为 1 + 6 + 3 + 1 + 2 + 5 = 18 。</p></blockquote><p><strong>提示：</strong></p><ul><li>$costs.length = n$</li><li>$1 &lt;= n &lt;= 10^5$</li><li>$1 &lt;= costs[i] &lt;= 10^5$</li><li>$1 &lt;= coins &lt;= 10^8$</li></ul><hr><h3 id="贪心-计数排序"><a href="#贪心-计数排序" class="headerlink" title="贪心+计数排序"></a>贪心+计数排序</h3><p>因为数组中数值存在一个范围，那么我们可以用计数排序的方法优化排序的复杂度为线性。</p><p>按照价格升序选择雪糕，最终个数一定是最多的。</p><div class="tabs" id="g_tab0"><ul class="nav-tabs"><li class="tab active"><a href="#g_tab0-1">C++</a></li></ul><div class="tab-content"><div class="tab-pane active" id="g_tab0-1"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span> cnt[N];</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxIceCream</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; costs, <span class="keyword">int</span> coins)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = costs.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            cnt[costs[i]]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N &amp;&amp; coins &gt;= i; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (; cnt[i]--;) &#123;</span><br><span class="line">                <span class="keyword">if</span> (coins &gt;= i) &#123;</span><br><span class="line">                    res ++;</span><br><span class="line">                    coins -= i;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div></div></div><div class="note primary">            <p><strong>原题链接：</strong> <a href="https://leetcode-cn.com/problems/maximum-ice-cream-bars/" target="_blank" rel="noopener">LeetCode 1833. 雪糕的最大数量</a></p>          </div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;摘要：&lt;/strong&gt;&lt;br&gt;排序+贪心题。&lt;/p&gt;
    
    </summary>
    
    
      <category term="指尖飞舞" scheme="https://accepted.org.cn/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/"/>
    
      <category term="算法" scheme="https://accepted.org.cn/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/%E7%AE%97%E6%B3%95/"/>
    
      <category term="LeetCode" scheme="https://accepted.org.cn/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/%E7%AE%97%E6%B3%95/LeetCode/"/>
    
    
      <category term="算法" scheme="https://accepted.org.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="LeetCode" scheme="https://accepted.org.cn/tags/LeetCode/"/>
    
      <category term="排序" scheme="https://accepted.org.cn/tags/%E6%8E%92%E5%BA%8F/"/>
    
      <category term="贪心" scheme="https://accepted.org.cn/tags/%E8%B4%AA%E5%BF%83/"/>
    
      <category term="计数排序" scheme="https://accepted.org.cn/tags/%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>LCP 07. 传递信息</title>
    <link href="https://accepted.org.cn/2021/07/01/LCP-07-%E4%BC%A0%E9%80%92%E4%BF%A1%E6%81%AF/"/>
    <id>https://accepted.org.cn/2021/07/01/LCP-07-%E4%BC%A0%E9%80%92%E4%BF%A1%E6%81%AF/</id>
    <published>2021-07-01T05:42:12.000Z</published>
    <updated>2021-07-01T05:50:58.929Z</updated>
    
    <content type="html"><![CDATA[<p><strong>摘要：</strong><br>简单深搜题。</p><a id="more"></a><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>小朋友 A 在和 ta 的小伙伴们玩传信息游戏，游戏规则如下：</p><ol><li>有 $n$ 名玩家，所有玩家编号分别为 $0$ ～ $n-1$，其中小朋友 A 的编号为 $0$</li><li>每个玩家都有固定的若干个可传信息的其他玩家（也可能没有）。传信息的关系是单向的（比如 A 可以向 B 传信息，但 B 不能向 A 传信息）。</li><li>每轮信息必须需要传递给另一个人，且信息可重复经过同一个人</li></ol><p>给定总玩家数 $n$，以及按 [玩家编号,对应可传递玩家编号] 关系组成的二维数组 $relation$。返回信息从小 A (编号 $0$ ) 经过 $k$ 轮传递到编号为 $n-1$ 的小伙伴处的方案数；若不能到达，返回 $0$。</p><p><strong>示例 1：</strong></p><blockquote><p>输入：n = 5, relation = [[0,2],[2,1],[3,4],[2,3],[1,4],[2,0],[0,4]], k = 3<br>输出：3<br>解释：信息从小 A 编号 0 处开始，经 3 轮传递，到达编号 4。共有 3 种方案，分别是 0-&gt;2-&gt;0-&gt;4， 0-&gt;2-&gt;1-&gt;4， 0-&gt;2-&gt;3-&gt;4。</p></blockquote><p><strong>示例 2：</strong></p><blockquote><p>输入：n = 3, relation = [[0,2],[2,1]], k = 2<br>输出：0<br>解释：信息不能从小 A 处经过 2 轮传递到编号 2</p></blockquote><p><strong>限制：</strong></p><ul><li>$2 &lt;= n &lt;= 10$</li><li>$1 &lt;= k &lt;= 5$</li><li>$1 &lt;= relation.length &lt;= 90$, 且 $relation[i].length == 2$</li><li>$0 &lt;= relation[i][0],relation[i][1] &lt; n$ 且 $relation[i][0] != relation[i][1]$</li></ul><hr><h3 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h3><div class="tabs" id="g_tab0"><ul class="nav-tabs"><li class="tab active"><a href="#g_tab0-1">C++</a></li></ul><div class="tab-content"><div class="tab-pane active" id="g_tab0-1"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 2021-7-1 13:49:27</span></span><br><span class="line"><span class="comment"> * author: etoa</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">int</span> N = <span class="number">97</span>;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; cnt[N];</span><br><span class="line">    <span class="keyword">int</span> res;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numWays</span><span class="params">(<span class="keyword">int</span> n, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; rela, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = rela.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; each = rela[i];</span><br><span class="line">            cnt[each[<span class="number">0</span>]].push_back(each[<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(n, k, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> &amp;n, <span class="keyword">int</span> &amp;k, <span class="keyword">int</span> u, <span class="keyword">int</span> node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (u == k) &#123;</span><br><span class="line">            <span class="keyword">if</span> (node == n - <span class="number">1</span>)</span><br><span class="line">                res++;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; path = cnt[node];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; path.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> nenode = path[i];</span><br><span class="line">            dfs(n, k, u + <span class="number">1</span>, nenode);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div></div></div><div class="note primary">            <p><strong>原题链接：</strong> <a href="https://leetcode-cn.com/problems/chuan-di-xin-xi/" target="_blank" rel="noopener">LCP 07. 传递信息</a></p>          </div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;摘要：&lt;/strong&gt;&lt;br&gt;简单深搜题。&lt;/p&gt;
    
    </summary>
    
    
      <category term="指尖飞舞" scheme="https://accepted.org.cn/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/"/>
    
      <category term="算法" scheme="https://accepted.org.cn/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/%E7%AE%97%E6%B3%95/"/>
    
      <category term="LeetCode" scheme="https://accepted.org.cn/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/%E7%AE%97%E6%B3%95/LeetCode/"/>
    
    
      <category term="算法" scheme="https://accepted.org.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="LeetCode" scheme="https://accepted.org.cn/tags/LeetCode/"/>
    
      <category term="DFS" scheme="https://accepted.org.cn/tags/DFS/"/>
    
  </entry>
  
  <entry>
    <title>【LeetCode双周赛55】B LeetCode 1910. 删除一个字符串中所有出现的给定子字符串</title>
    <link href="https://accepted.org.cn/2021/06/30/%E3%80%90LeetCode%E5%8F%8C%E5%91%A8%E8%B5%9B55%E3%80%91B-LeetCode-1910-%E5%88%A0%E9%99%A4%E4%B8%80%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E6%89%80%E6%9C%89%E5%87%BA%E7%8E%B0%E7%9A%84%E7%BB%99%E5%AE%9A%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    <id>https://accepted.org.cn/2021/06/30/%E3%80%90LeetCode%E5%8F%8C%E5%91%A8%E8%B5%9B55%E3%80%91B-LeetCode-1910-%E5%88%A0%E9%99%A4%E4%B8%80%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E6%89%80%E6%9C%89%E5%87%BA%E7%8E%B0%E7%9A%84%E7%BB%99%E5%AE%9A%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2/</id>
    <published>2021-06-30T15:23:56.000Z</published>
    <updated>2021-07-05T16:49:44.686Z</updated>
    
    <content type="html"><![CDATA[<p><strong>摘要：</strong><br>简单字符串替换。</p><a id="more"></a><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给你两个字符串 $s$ 和 $part$ ，请你对 $s$ 反复执行以下操作直到 <strong>所有</strong> 子字符串 $part$ 都被删除：</p><ul><li>找到 $s$ 中 <strong>最左边</strong> 的子字符串 $part$ ，并将它从 $s$ 中删除。</li></ul><p>请你返回从 $s$ 中删除所有 $part$ 子字符串以后得到的剩余字符串。</p><p>一个 <strong>子字符串</strong> 是一个字符串中连续的字符序列。</p><p><strong>示例 1：</strong></p><blockquote><p>输入：s = “daabcbaabcbc”, part = “abc”<br>输出：”dab”<br>解释：以下操作按顺序执行：</p></blockquote><ul><li>s = “daabcbaabcbc” ，删除下标从 2 开始的 “abc” ，得到 s = “dabaabcbc” 。</li><li>s = “dabaabcbc” ，删除下标从 4 开始的 “abc” ，得到 s = “dababc” 。</li><li>s = “dababc” ，删除下标从 3 开始的 “abc” ，得到 s = “dab” 。<br>此时 s 中不再含有子字符串 “abc” 。</li></ul><p><strong>示例 2：</strong></p><p>输入：s = “axxxxyyyyb”, part = “xy”<br>输出：”ab”<br>解释：以下操作按顺序执行：</p><ul><li>s = “axxxxyyyyb” ，删除下标从 4 开始的 “xy” ，得到 s = “axxxyyyb” 。</li><li>s = “axxxyyyb” ，删除下标从 3 开始的 “xy” ，得到 s = “axxyyb” 。</li><li>s = “axxyyb” ，删除下标从 2 开始的 “xy” ，得到 s = “axyb” 。</li><li>s = “axyb” ，删除下标从 1 开始的 “xy” ，得到 s = “ab” 。<br>此时 s 中不再含有子字符串 “xy” 。</li></ul><p><strong>提示：</strong></p><ul><li>$1 &lt;= s.length &lt;= 1000$</li><li>$1 &lt;= part.length &lt;= 1000$</li><li>$s$​​​​​​ 和 $part$ 只包小写英文字母。</li></ul><hr><h3 id="字符串查找替换"><a href="#字符串查找替换" class="headerlink" title="字符串查找替换"></a>字符串查找替换</h3><div class="tabs" id="g_tab0"><ul class="nav-tabs"><li class="tab active"><a href="#g_tab0-1">C++</a></li></ul><div class="tab-content"><div class="tab-pane active" id="g_tab0-1"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">removeOccurrences</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len1 = s.<span class="built_in">size</span>(), len2 = p.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">int</span> idx = s.<span class="built_in">find</span>(p);</span><br><span class="line">            <span class="keyword">if</span> (idx == <span class="number">-1</span>) <span class="keyword">break</span>;</span><br><span class="line">            <span class="built_in">string</span> s1 = s.substr(<span class="number">0</span>, idx), s2 = s.substr(idx + len2);</span><br><span class="line">            s = s1 + s2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div></div></div><div class="note primary">            <p><strong>原题链接：</strong> <a href="https://leetcode-cn.com/problems/remove-all-occurrences-of-a-substring/" target="_blank" rel="noopener">LeetCode 1910. 删除一个字符串中所有出现的给定子字符串</a></p>          </div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;摘要：&lt;/strong&gt;&lt;br&gt;简单字符串替换。&lt;/p&gt;
    
    </summary>
    
    
      <category term="指尖飞舞" scheme="https://accepted.org.cn/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/"/>
    
      <category term="算法" scheme="https://accepted.org.cn/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/%E7%AE%97%E6%B3%95/"/>
    
      <category term="LeetCode" scheme="https://accepted.org.cn/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/%E7%AE%97%E6%B3%95/LeetCode/"/>
    
      <category term="竞赛" scheme="https://accepted.org.cn/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/%E7%AE%97%E6%B3%95/%E7%AB%9E%E8%B5%9B/"/>
    
      <category term="LeetCode双周赛" scheme="https://accepted.org.cn/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/%E7%AE%97%E6%B3%95/%E7%AB%9E%E8%B5%9B/LeetCode%E5%8F%8C%E5%91%A8%E8%B5%9B/"/>
    
      <category term="55" scheme="https://accepted.org.cn/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/%E7%AE%97%E6%B3%95/%E7%AB%9E%E8%B5%9B/LeetCode%E5%8F%8C%E5%91%A8%E8%B5%9B/55/"/>
    
    
      <category term="算法" scheme="https://accepted.org.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="LeetCode" scheme="https://accepted.org.cn/tags/LeetCode/"/>
    
      <category term="字符串" scheme="https://accepted.org.cn/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
      <category term="竞赛" scheme="https://accepted.org.cn/tags/%E7%AB%9E%E8%B5%9B/"/>
    
  </entry>
  
  <entry>
    <title>【LeetCode双周赛55】A LeetCode 1909. 删除一个元素使数组严格递增</title>
    <link href="https://accepted.org.cn/2021/06/30/%E3%80%90LeetCode%E5%8F%8C%E5%91%A8%E8%B5%9B55%E3%80%91A-LeetCode-1909-%E5%88%A0%E9%99%A4%E4%B8%80%E4%B8%AA%E5%85%83%E7%B4%A0%E4%BD%BF%E6%95%B0%E7%BB%84%E4%B8%A5%E6%A0%BC%E9%80%92%E5%A2%9E/"/>
    <id>https://accepted.org.cn/2021/06/30/%E3%80%90LeetCode%E5%8F%8C%E5%91%A8%E8%B5%9B55%E3%80%91A-LeetCode-1909-%E5%88%A0%E9%99%A4%E4%B8%80%E4%B8%AA%E5%85%83%E7%B4%A0%E4%BD%BF%E6%95%B0%E7%BB%84%E4%B8%A5%E6%A0%BC%E9%80%92%E5%A2%9E/</id>
    <published>2021-06-30T14:43:09.000Z</published>
    <updated>2021-07-05T16:49:54.913Z</updated>
    
    <content type="html"><![CDATA[<p><strong>摘要：</strong><br>签到题，但是又不那么水，题目质量挺好。</p><a id="more"></a><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给你一个下标从 $0$ 开始的整数数组 $nums$ ，如果 <strong>恰好</strong> 删除 <strong>一个</strong> 元素后，数组 <strong>严格递增</strong> ，那么请你返回 $true$ ，否则返回 $false$ 。如果数组本身已经是严格递增的，请你也返回 $true$ 。</p><p>数组 $nums$ 是 <strong>严格递增</strong> 的定义为：对于任意下标的 $1 &lt;= i &lt; nums.length$ 都满足 $nums[i - 1] &lt; nums[i]$ 。</p><p><strong>示例 1：</strong></p><blockquote><p>输入：nums = [1,2,10,5,7]<br>输出：true<br>解释：从 nums 中删除下标 2 处的 10 ，得到 [1,2,5,7] 。<br>[1,2,5,7] 是严格递增的，所以返回 true 。</p></blockquote><p><strong>示例 2：</strong></p><blockquote><p>输入：nums = [2,3,1,2]<br>输出：false<br>解释：<br>[3,1,2] 是删除下标 0 处元素后得到的结果。<br>[2,1,2] 是删除下标 1 处元素后得到的结果。<br>[2,3,2] 是删除下标 2 处元素后得到的结果。<br>[2,3,1] 是删除下标 3 处元素后得到的结果。<br>没有任何结果数组是严格递增的，所以返回 false 。</p></blockquote><p><strong>示例 3：</strong></p><blockquote><p>输入：nums = [1,1,1]<br>输出：false<br>解释：删除任意元素后的结果都是 [1,1] 。<br>[1,1] 不是严格递增的，所以返回 false 。</p></blockquote><p><strong>示例 4：</strong></p><p>输入：nums = [1,2,3]<br>输出：true<br>解释：[1,2,3] 已经是严格递增的，所以返回 true 。</p><p><strong>提示：</strong></p><ul><li>$2 &lt;= nums.length &lt;= 1000$</li><li>$1 &lt;= nums[i] &lt;= 1000$</li></ul><hr><h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><p>枚举每一位数，剔除后判断剩余数组是否严格单调递增。复杂度 $O(N^2)$, 数组长度最高 $1000$，复杂度是$1000000$ ，可以过掉。</p><div class="tabs" id="g_tab0"><ul class="nav-tabs"><li class="tab active"><a href="#g_tab0-1">C++</a></li></ul><div class="tab-content"><div class="tab-pane active" id="g_tab0-1"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canBeIncreasing</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">-1</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> last = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">bool</span> isgood = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; len; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (j == i) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span> (nums[j] &lt;= last) &#123;</span><br><span class="line">                    isgood = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                last = nums[j];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (isgood) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div></div></div><p>从 <code>-1</code> 开始枚举需要删除的数，<code>-1</code> 表示不删除任何数，判断原数组是否为严格单调递增，太妙了。<br>注意 <code>nums.size()</code> 返回的是一个 <code>unsigned int</code> 类型，需要强转成 <code>int</code> 类型，配合 <code>-1</code>，不然有bug。</p><div class="note primary">            <p><strong>原题链接：</strong> <a href="https://leetcode-cn.com/problems/remove-one-element-to-make-the-array-strictly-increasing/" target="_blank" rel="noopener">LeetCode 1909. 删除一个元素使数组严格递增</a></p>          </div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;摘要：&lt;/strong&gt;&lt;br&gt;签到题，但是又不那么水，题目质量挺好。&lt;/p&gt;
    
    </summary>
    
    
      <category term="指尖飞舞" scheme="https://accepted.org.cn/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/"/>
    
      <category term="算法" scheme="https://accepted.org.cn/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/%E7%AE%97%E6%B3%95/"/>
    
      <category term="LeetCode" scheme="https://accepted.org.cn/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/%E7%AE%97%E6%B3%95/LeetCode/"/>
    
      <category term="竞赛" scheme="https://accepted.org.cn/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/%E7%AE%97%E6%B3%95/%E7%AB%9E%E8%B5%9B/"/>
    
      <category term="LeetCode双周赛" scheme="https://accepted.org.cn/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/%E7%AE%97%E6%B3%95/%E7%AB%9E%E8%B5%9B/LeetCode%E5%8F%8C%E5%91%A8%E8%B5%9B/"/>
    
      <category term="55" scheme="https://accepted.org.cn/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/%E7%AE%97%E6%B3%95/%E7%AB%9E%E8%B5%9B/LeetCode%E5%8F%8C%E5%91%A8%E8%B5%9B/55/"/>
    
    
      <category term="算法" scheme="https://accepted.org.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="LeetCode" scheme="https://accepted.org.cn/tags/LeetCode/"/>
    
      <category term="竞赛" scheme="https://accepted.org.cn/tags/%E7%AB%9E%E8%B5%9B/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 297. 二叉树的序列化与反序列化</title>
    <link href="https://accepted.org.cn/2021/06/30/LeetCode-297-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8E%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"/>
    <id>https://accepted.org.cn/2021/06/30/LeetCode-297-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8E%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/</id>
    <published>2021-06-30T03:18:11.000Z</published>
    <updated>2021-06-30T03:32:40.375Z</updated>
    
    <content type="html"><![CDATA[<p><strong>摘要：</strong><br>根据遍历来序列化和反序列化二叉树。</p><a id="more"></a><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>序列化是将一个数据结构或者对象转换为连续的比特位的操作，进而可以将转换后的数据存储在一个文件或者内存中，同时也可以通过网络传输到另一个计算机环境，采取相反方式重构得到原数据。</p><p>请设计一个算法来实现二叉树的序列化与反序列化。这里不限定你的序列 / 反序列化算法执行逻辑，你只需要保证一个二叉树可以被序列化为一个字符串并且将这个字符串反序列化为原始的树结构。</p><p>提示: 输入输出格式与 LeetCode 目前使用的方式一致，详情请参阅 LeetCode 序列化二叉树的格式。你并非必须采取这种方式，你也可以采用其他的方法解决这个问题。</p><p><strong>示例1：</strong></p><p><img src="0.jpg" alt="0x0"></p><blockquote><p>输入：root = [1,2,3,null,null,4,5]<br>输出：[1,2,3,null,null,4,5]</p></blockquote><p><strong>示例 2：</strong></p><blockquote><p>输入：root = []<br>输出：[]</p></blockquote><p><strong>示例 3：</strong></p><blockquote><p>输入：root = [1]<br>输出：[1]</p></blockquote><p><strong>示例 4：</strong></p><blockquote><p>输入：root = [1,2]<br>输出：[1,2]</p></blockquote><p><strong>提示：</strong></p><ul><li>树中结点数在范围 $[0, 104]$ 内</li><li>$-1000 &lt;= Node.val &lt;= 1000$</li></ul><p><strong>树的定义和方法的调用：</strong></p><div class="tabs" id="g_tab0"><ul class="nav-tabs"><li class="tab active"><a href="#g_tab0-1">C++</a></li><li class="tab"><a href="#g_tab0-2">Java</a></li></ul><div class="tab-content"><div class="tab-pane active" id="g_tab0-1"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Your Codec object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment">// Codec codec;</span></span><br><span class="line"><span class="comment">// codec.deserialize(codec.serialize(root));</span></span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="g_tab0-2"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Your Codec object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment">// Codec codec = new Codec();</span></span><br><span class="line"><span class="comment">// codec.deserialize(codec.serialize(root));</span></span><br></pre></td></tr></table></figure></div></div></div><h3 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h3><p>在看这道题前，请回顾一下 <a href="https://eetoa.github.io/2021/02/23/剑指Offer-07-重建二叉树/" target="_blank" rel="noopener">剑指Offer 07. 重建二叉树</a>.<br>在上面这道题中，为了反序列化一颗二叉树，我们需要前序遍历序列和中序遍历序列，当这两个序列不包含原树的空节点。<br>如果给定一个包含原树空节点的前序遍历序列，我们就可以直接反序列化这颗二叉树。</p><p>另外这道题注意节点值的负数情况。</p><div class="tabs" id="g_tab1"><ul class="nav-tabs"><li class="tab active"><a href="#g_tab1-1">C++</a></li></ul><div class="tab-content"><div class="tab-pane active" id="g_tab1-1"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Codec</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">string</span> path;</span><br><span class="line">    <span class="comment">// Encodes a tree to a single string.</span></span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">serialize</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        dfs_s(root);</span><br><span class="line">        <span class="keyword">return</span> path;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs_s</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) path += <span class="string">"#,"</span>;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            path += to_string(root-&gt;val) + <span class="string">','</span>;</span><br><span class="line">            dfs_s(root-&gt;left);</span><br><span class="line">            dfs_s(root-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Decodes your encoded data to tree.</span></span><br><span class="line">    <span class="function">TreeNode* <span class="title">deserialize</span><span class="params">(<span class="built_in">string</span> data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> u = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> dfs_d(data, u);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">TreeNode* <span class="title">dfs_d</span><span class="params">(<span class="built_in">string</span>&amp; data, <span class="keyword">int</span>&amp; u)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (data[u] == <span class="string">'#'</span>) &#123;</span><br><span class="line">            u += <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> k = u;</span><br><span class="line">            <span class="keyword">while</span> (data[u] != <span class="string">','</span>) u ++ ;</span><br><span class="line">            <span class="keyword">auto</span> root = <span class="keyword">new</span> TreeNode(stoi(data.substr(k, u - k)));</span><br><span class="line">            u ++ ;</span><br><span class="line">            root-&gt;left = dfs_d(data, u);</span><br><span class="line">            root-&gt;right = dfs_d(data, u);</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div></div></div><div class="note primary">            <p><strong>原题链接：</strong> <a href="https://leetcode-cn.com/problems/serialize-and-deserialize-binary-tree/submissions/" target="_blank" rel="noopener">LeetCode 297. 二叉树的序列化与反序列化</a></p>          </div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;摘要：&lt;/strong&gt;&lt;br&gt;根据遍历来序列化和反序列化二叉树。&lt;/p&gt;
    
    </summary>
    
    
      <category term="指尖飞舞" scheme="https://accepted.org.cn/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/"/>
    
      <category term="算法" scheme="https://accepted.org.cn/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/%E7%AE%97%E6%B3%95/"/>
    
      <category term="LeetCode" scheme="https://accepted.org.cn/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/%E7%AE%97%E6%B3%95/LeetCode/"/>
    
    
      <category term="算法" scheme="https://accepted.org.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="LeetCode" scheme="https://accepted.org.cn/tags/LeetCode/"/>
    
      <category term="DFS" scheme="https://accepted.org.cn/tags/DFS/"/>
    
      <category term="树" scheme="https://accepted.org.cn/tags/%E6%A0%91/"/>
    
      <category term="二叉树" scheme="https://accepted.org.cn/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>【AcWing算法基础】第一讲-基础算法-归并排序 AcWing 787. 归并排序</title>
    <link href="https://accepted.org.cn/2021/06/29/%E3%80%90AcWing%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E3%80%91%E7%AC%AC%E4%B8%80%E8%AE%B2-%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95-%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F-AcWing-787-%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/"/>
    <id>https://accepted.org.cn/2021/06/29/%E3%80%90AcWing%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E3%80%91%E7%AC%AC%E4%B8%80%E8%AE%B2-%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95-%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F-AcWing-787-%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/</id>
    <published>2021-06-29T03:52:06.000Z</published>
    <updated>2021-06-29T13:34:12.370Z</updated>
    
    <content type="html"><![CDATA[<p><strong>摘要：</strong><br>经典归并排序模板。</p><a id="more"></a><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给定你一个长度为 $n$ 的整数数列。</p><p>请你使用归并排序对这个数列按照从小到大进行排序。</p><p>并将排好序的数列按顺序输出。</p><p><strong>输入格式</strong></p><p>输入共两行，第一行包含整数 $n$。</p><p>第二行包含 $n$ 个整数（所有整数均在 $1∼10^9$ 范围内），表示整个数列。</p><p><strong>输出格式</strong></p><p>输出共一行，包含 $n$ 个整数，表示排好序的数列。</p><p><strong>数据范围</strong></p><ul><li>$1≤n≤100000$</li></ul><p><strong>输入样例：</strong></p><blockquote><p>5<br>3 1 2 4 5</p></blockquote><p><strong>输出样例：</strong></p><blockquote><p>1 2 3 4 5</p></blockquote><hr><h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><p>归并排序的核心思想是递归地将原数组划分成两段，在不可再分的时候（一对数或一个数）进行第一次双指针排序。<br>然后在「归」的过程利用上一层已经排序好的两段，将它们使用双指针合并排序。</p><div class="tabs" id="g_tab0"><ul class="nav-tabs"><li class="tab active"><a href="#g_tab0-1">C++</a></li></ul><div class="tab-content"><div class="tab-pane active" id="g_tab0-1"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="keyword">int</span> a[N], tmp[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ms</span><span class="params">(<span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (lo &gt;= hi) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> mid = lo + hi &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    ms(lo, mid), ms(mid + <span class="number">1</span>, hi);</span><br><span class="line">    <span class="keyword">int</span> i = lo, j = mid + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> idx = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (; i &lt;= mid &amp;&amp; j &lt;= hi;) &#123;              <span class="comment">// 对于两段升序子数组，用双指针进行合并排序</span></span><br><span class="line">        <span class="keyword">if</span> (a[i] &lt;= a[j]) tmp[idx++] = a[i++];</span><br><span class="line">        <span class="keyword">else</span> tmp[idx++] = a[j++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果某一段较另一段提前完成，需要将另一段加入到已排序临时数组后面。注意另一段数组元素一定大于等于已排序的临时数组</span></span><br><span class="line">    <span class="keyword">for</span> (; i &lt;= mid;) tmp[idx++] = a[i++];</span><br><span class="line">    <span class="keyword">for</span> (; j &lt;= hi; ) tmp[idx++] = a[j++];</span><br><span class="line">    <span class="comment">// 将已排序的临时数组覆盖原数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> re = lo, t = <span class="number">0</span>; re &lt;= hi;) a[re++] = tmp[t++];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) <span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">    ms(<span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) <span class="built_in">cout</span> &lt;&lt; a[i] &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div></div><div class="note primary">            <p><strong>原题链接：</strong> <a href="https://www.acwing.com/problem/content/789/" target="_blank" rel="noopener">AcWing 787. 归并排序</a></p>          </div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;摘要：&lt;/strong&gt;&lt;br&gt;经典归并排序模板。&lt;/p&gt;
    
    </summary>
    
    
      <category term="指尖飞舞" scheme="https://accepted.org.cn/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/"/>
    
      <category term="算法" scheme="https://accepted.org.cn/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/%E7%AE%97%E6%B3%95/"/>
    
      <category term="AcWing" scheme="https://accepted.org.cn/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/%E7%AE%97%E6%B3%95/AcWing/"/>
    
      <category term="算法基础课" scheme="https://accepted.org.cn/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/%E7%AE%97%E6%B3%95/AcWing/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BE/"/>
    
      <category term="第一讲基础算法" scheme="https://accepted.org.cn/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/%E7%AE%97%E6%B3%95/AcWing/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BE/%E7%AC%AC%E4%B8%80%E8%AE%B2%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="https://accepted.org.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="排序" scheme="https://accepted.org.cn/tags/%E6%8E%92%E5%BA%8F/"/>
    
      <category term="归并排序" scheme="https://accepted.org.cn/tags/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/"/>
    
      <category term="AcWing" scheme="https://accepted.org.cn/tags/AcWing/"/>
    
  </entry>
  
</feed>
