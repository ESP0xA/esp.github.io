<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>VIRTUAL™ Labs</title>
  
  <subtitle>Create NtContainer for Virtual</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://ntifs.com/"/>
  <updated>2023-07-15T09:58:35.954Z</updated>
  <id>https://ntifs.com/</id>
  
  <author>
    <name>zxy</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>【AcWing算法基础】第三讲-搜索与图论-DFS AcWing 843. n-皇后问题</title>
    <link href="https://ntifs.com/2023/07/15/%E3%80%90AcWing%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E3%80%91%E7%AC%AC%E4%B8%89%E8%AE%B2-%E6%90%9C%E7%B4%A2%E4%B8%8E%E5%9B%BE%E8%AE%BA-DFS-AcWing-843-n-%E7%9A%87%E5%90%8E%E9%97%AE%E9%A2%98/"/>
    <id>https://ntifs.com/2023/07/15/%E3%80%90AcWing%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E3%80%91%E7%AC%AC%E4%B8%89%E8%AE%B2-%E6%90%9C%E7%B4%A2%E4%B8%8E%E5%9B%BE%E8%AE%BA-DFS-AcWing-843-n-%E7%9A%87%E5%90%8E%E9%97%AE%E9%A2%98/</id>
    <published>2023-07-15T09:00:08.000Z</published>
    <updated>2023-07-15T09:58:35.954Z</updated>
    
    <content type="html"><![CDATA[<p><strong>摘要：</strong><br>经典的DFS问题，n-皇后。</p><a id="more"></a><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>$n$−皇后问题是指将 $n$ 个皇后放在 $n \times n$ 的国际象棋棋盘上，使得皇后不能相互攻击到，即任意两个皇后都不能处于同一行、同一列或同一斜线上。</p><p><img src="https://cdn.acwing.com/media/article/image/2019/06/08/19_860e00c489-1_597ec77c49-8-queens.png" alt="n-queen"></p><p>现在给定整数 $n$，请你输出所有的满足条件的棋子摆法。</p><p><strong>输入格式</strong><br>共一行，包含整数 $n$。</p><p><strong>输出格式</strong><br>每个解决方案占 $n$ 行，每行输出一个长度为 $n$ 的字符串，用来表示完整的棋盘状态。</p><p>其中 <code>.</code> 表示某一个位置的方格状态为空，<code>Q</code> 表示某一个位置的方格上摆着皇后。</p><p>每个方案输出完成后，输出一个空行。</p><p>注意：行末不能有多余空格。</p><p>输出方案的顺序任意，只要不重复且没有遗漏即可。</p><p><strong>数据范围</strong><br>$1≤n≤9$</p><p><strong>输入样例：</strong><br>$4$</p><p><strong>输出样例：</strong></p><blockquote><p>.Q..<br>…Q<br>Q…<br>..Q.</p><p>..Q.<br>Q…<br>…Q<br>.Q..</p></blockquote><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><div class="tabs" id="g_tab0"><ul class="nav-tabs"><li class="tab active"><a href="#g_tab0-1">C++/行递归搜索</a></li><li class="tab"><a href="#g_tab0-2">C++/按每个格子放与不放枚举搜索</a></li><li class="tab"><a href="#g_tab0-3">Java</a></li></ul><div class="tab-content"><div class="tab-pane active" id="g_tab0-1"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * author: zxy</span></span><br><span class="line"><span class="comment"> * code at: 2023-7-15 17:18:56</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">bool</span> col[N], dg[N], ndg[N];</span><br><span class="line"><span class="keyword">char</span> g[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (r == n) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// finds a valid solution if overflow</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; g[i] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> c = <span class="number">0</span>; c &lt; n; ++c)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!col[c] &amp;&amp; !dg[c + r] &amp;&amp; !ndg[c - r + n])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// valid grid to put queen</span></span><br><span class="line">            g[r][c] = <span class="string">'Q'</span>;</span><br><span class="line">            col[c] = dg[c + r] = ndg[c - r + n] = <span class="literal">true</span>;</span><br><span class="line">            <span class="comment">// step into the next row</span></span><br><span class="line">            dfs(r + <span class="number">1</span>);</span><br><span class="line">            <span class="comment">// back track to restore context</span></span><br><span class="line">            col[c] = dg[c + r] = ndg[c - r + n] = <span class="literal">false</span>;</span><br><span class="line">            g[r][c] = <span class="string">'.'</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            g[i][j] = <span class="string">'.'</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    dfs(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="g_tab0-2"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">bool</span> row[N], col[N], dg[N], ndg[N];</span><br><span class="line"><span class="keyword">char</span> g[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> r, <span class="keyword">int</span> c, <span class="keyword">int</span> s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// the colums overflows, set to the next row</span></span><br><span class="line">    <span class="keyword">if</span> (c &gt;= n)</span><br><span class="line">    &#123;</span><br><span class="line">        c = <span class="number">0</span>;</span><br><span class="line">        ++r;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (r &gt;= n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (s &gt;= n) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// consider a valid solution</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; g[i] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        &#125;    </span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="comment">// try not put queen</span></span><br><span class="line">    g[r][c] = <span class="string">'.'</span>;</span><br><span class="line">    dfs(r, c + <span class="number">1</span>, s);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// try put queen</span></span><br><span class="line">    <span class="keyword">if</span> (!row[r] &amp;&amp; !col[c] &amp;&amp; !dg[r + c] &amp;&amp; !ndg[r - c + n])</span><br><span class="line">    &#123;</span><br><span class="line">        g[r][c] = <span class="string">'Q'</span>;</span><br><span class="line">        row[r] = col[c] = dg[r + c] = ndg[r - c + n] = <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">// step into next columns</span></span><br><span class="line">        dfs(r, c + <span class="number">1</span>, s + <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// back track to restore context</span></span><br><span class="line">        g[r][c] = <span class="string">'.'</span>;</span><br><span class="line">        row[r] = col[c] = dg[r + c] = ndg[r - c + n] = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            g[i][j] = <span class="string">'.'</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    dfs(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="g_tab0-3"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></div></div></div><h3 id="按行递归搜索"><a href="#按行递归搜索" class="headerlink" title="按行递归搜索"></a>按行递归搜索</h3><p>从第一行开始向右遍历放入第一个 <code>Q</code>，记下冲突位置， 即记下竖和两个斜对角占用，横冲突不需要考虑因为我们按行搜索，每一行只会放置一个 <code>Q</code>。</p><p>此时递归进入下一行，根据冲突记录找到不冲突的点，放置 <code>Q</code>。依次往下一行递归，当递归到某一行没有能够找到位置放置 <code>Q</code>，可以认为方案不合法。此时递归函数回溯。进行上一行，对下一个可能放置 <code>Q</code> 的位置进行尝试。</p><p>当递归到行越界的时候，可以认为该路径上的所有 <code>Q</code> 合法，输出方案。</p><p>需要注意的是记录两个对角线冲突状态时，我们使用一元二次方程 $r = c + d$ 和 $r = c - d$ 中截距 $d$ 来表示一条对角线，其中：</p><p>$d = r + c$</p><p>$d = r - c$</p><p>在数组中维护 $d$ 的值时，对于第二种情况，可能下标取到负值。由于 $r - c$ 最小可以取到 $-c$ 即 $-n$ 的位置，我们将整个 $d = r - c$ 向右偏移 $n$ 位，即可解决数组下标为负数的问题。</p><h3 id="按每个格子放与不放枚举搜索"><a href="#按每个格子放与不放枚举搜索" class="headerlink" title="按每个格子放与不放枚举搜索"></a>按每个格子放与不放枚举搜索</h3><p>思想是每个格子都尝试放与不放两种选择，从最后一个格子开始，作为放置 <code>Q</code> 的起点向后递归。不满足的话回溯到倒数第二个格子放置 <code>Q</code>，依次类推。</p><p>该方法存在大量重复尝试，每一个格子作为放置 <code>Q</code> 的起点向后递归的时候，都会和其他起点的路径存在重复。</p><p>对比按行递归搜索方法，该方法复杂度更高。</p><div class="note primary">            <p><strong>原题链接：</strong> <a href="https://www.acwing.com/problem/content/description/845/" target="_blank" rel="noopener">AcWing 843. n-皇后问题</a></p>          </div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;摘要：&lt;/strong&gt;&lt;br&gt;经典的DFS问题，n-皇后。&lt;/p&gt;
    
    </summary>
    
    
      <category term="指尖飞舞" scheme="https://ntifs.com/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/"/>
    
      <category term="算法" scheme="https://ntifs.com/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/%E7%AE%97%E6%B3%95/"/>
    
      <category term="AcWing" scheme="https://ntifs.com/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/%E7%AE%97%E6%B3%95/AcWing/"/>
    
      <category term="算法基础课" scheme="https://ntifs.com/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/%E7%AE%97%E6%B3%95/AcWing/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BE/"/>
    
      <category term="第三讲搜索与图论" scheme="https://ntifs.com/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/%E7%AE%97%E6%B3%95/AcWing/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BE/%E7%AC%AC%E4%B8%89%E8%AE%B2%E6%90%9C%E7%B4%A2%E4%B8%8E%E5%9B%BE%E8%AE%BA/"/>
    
    
      <category term="算法" scheme="https://ntifs.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="DFS" scheme="https://ntifs.com/tags/DFS/"/>
    
      <category term="AcWing" scheme="https://ntifs.com/tags/AcWing/"/>
    
  </entry>
  
  <entry>
    <title>【AcWing算法基础】第三讲-搜索与图论-DFS AcWing 842. 排列数字</title>
    <link href="https://ntifs.com/2023/07/15/%E3%80%90AcWing%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E3%80%91%E7%AC%AC%E4%B8%89%E8%AE%B2-%E6%90%9C%E7%B4%A2%E4%B8%8E%E5%9B%BE%E8%AE%BA-DFS-AcWing-842-%E6%8E%92%E5%88%97%E6%95%B0%E5%AD%97/"/>
    <id>https://ntifs.com/2023/07/15/%E3%80%90AcWing%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E3%80%91%E7%AC%AC%E4%B8%89%E8%AE%B2-%E6%90%9C%E7%B4%A2%E4%B8%8E%E5%9B%BE%E8%AE%BA-DFS-AcWing-842-%E6%8E%92%E5%88%97%E6%95%B0%E5%AD%97/</id>
    <published>2023-07-15T06:46:52.000Z</published>
    <updated>2023-07-15T10:00:44.356Z</updated>
    
    <content type="html"><![CDATA[<p><strong>摘要：</strong><br>DFS入门题。</p><a id="more"></a><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给定一个整数 $n$，将数字 $1∼n$ 排成一排，将会有很多种排列方法。</p><p>现在，请你按照字典序将所有的排列方法输出。</p><p><strong>输入格式</strong><br>共一行，包含一个整数 $n$。</p><p><strong>输出格式</strong><br>按字典序输出所有排列方案，每个方案占一行。</p><p><strong>数据范围</strong><br>$1≤n≤7$</p><p><strong>输入样例：</strong></p><blockquote><p>3</p></blockquote><p><strong>输出样例：</strong></p><blockquote><p>1 2 3<br>1 3 2<br>2 1 3<br>2 3 1<br>3 1 2<br>3 2 1</p></blockquote><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><div class="tabs" id="g_tab0"><ul class="nav-tabs"><li class="tab active"><a href="#g_tab0-1">C++</a></li><li class="tab"><a href="#g_tab0-2">Java</a></li></ul><div class="tab-content"><div class="tab-pane active" id="g_tab0-1"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> path[N];</span><br><span class="line"><span class="keyword">bool</span> st[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (u == n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// overflow</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) <span class="built_in">cout</span> &lt;&lt; path[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!st[i])</span><br><span class="line">        &#123;</span><br><span class="line">            path[u] = i;</span><br><span class="line">            st[i] = <span class="literal">true</span>;</span><br><span class="line">            dfs(u + <span class="number">1</span>);</span><br><span class="line">            st[i] = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    dfs(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="g_tab0-2"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></div></div></div><h3 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h3><p>本题核心思想是使用递归全量枚举暴搜。 </p><p>按照深度优先进行下一位数字的搜索操作。每搜索到一个节点，使用path数组记录节点值。当路径中记录的数字数量到达预计值的时候，输出路径并递归返回。</p><p>为了每个节点可以使用新的数字而不至于重复，将当前路径已经使用过的数字使用额外数组记下，在下一层调用的时候跳过已使用的数字。</p><p>需要注意的是，在递归回来的时候，需要将已被标记的当前入口节点使用状态重置。因为标记的目的是为了下一层跳过，那么从下一层递归回来当然需要还原。</p><p>另外，之所以回溯的时候，path不需要恢复现场，是因为后续的写入会直接将对应位置的值覆盖掉。</p><div class="note primary">            <p><strong>原题链接：</strong> <a href="https://www.acwing.com/problem/content/844/" target="_blank" rel="noopener">AcWing 842. 排列数字</a></p>          </div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;摘要：&lt;/strong&gt;&lt;br&gt;DFS入门题。&lt;/p&gt;
    
    </summary>
    
    
      <category term="指尖飞舞" scheme="https://ntifs.com/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/"/>
    
      <category term="算法" scheme="https://ntifs.com/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/%E7%AE%97%E6%B3%95/"/>
    
      <category term="AcWing" scheme="https://ntifs.com/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/%E7%AE%97%E6%B3%95/AcWing/"/>
    
      <category term="算法基础课" scheme="https://ntifs.com/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/%E7%AE%97%E6%B3%95/AcWing/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BE/"/>
    
      <category term="第三讲搜索与图论" scheme="https://ntifs.com/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/%E7%AE%97%E6%B3%95/AcWing/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BE/%E7%AC%AC%E4%B8%89%E8%AE%B2%E6%90%9C%E7%B4%A2%E4%B8%8E%E5%9B%BE%E8%AE%BA/"/>
    
    
      <category term="算法" scheme="https://ntifs.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="DFS" scheme="https://ntifs.com/tags/DFS/"/>
    
      <category term="AcWing" scheme="https://ntifs.com/tags/AcWing/"/>
    
  </entry>
  
  <entry>
    <title>【AcWing算法基础】第二讲-数据结构-哈希表 AcWing 841. 字符串哈希</title>
    <link href="https://ntifs.com/2023/07/10/%E3%80%90AcWing%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E3%80%91%E7%AC%AC%E4%BA%8C%E8%AE%B2-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%93%88%E5%B8%8C%E8%A1%A8-AcWing-841-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%93%88%E5%B8%8C/"/>
    <id>https://ntifs.com/2023/07/10/%E3%80%90AcWing%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E3%80%91%E7%AC%AC%E4%BA%8C%E8%AE%B2-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%93%88%E5%B8%8C%E8%A1%A8-AcWing-841-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%93%88%E5%B8%8C/</id>
    <published>2023-07-10T14:54:09.000Z</published>
    <updated>2023-07-12T13:41:59.337Z</updated>
    
    <content type="html"><![CDATA[<p><strong>摘要：</strong><br>字符串前缀哈希法。</p><a id="more"></a><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给定一个长度为 $n$ 的字符串，再给定 $m$ 个询问，每个询问包含四个整数 $l1,r1,l2,r2$，请你判断 $[l1,r1]$ 和 $[l2,r2]$ 这两个区间所包含的字符串子串是否完全相同。<br>字符串中只包含大小写英文字母和数字。</p><p><strong>输入格式</strong><br>第一行包含整数 $n$ 和 $m$，表示字符串长度和询问次数。</p><p>第二行包含一个长度为 $n$ 的字符串，字符串中只包含大小写英文字母和数字。</p><p>接下来 $m$ 行，每行包含四个整数 $l1,r1,l2,r2$，表示一次询问所涉及的两个区间。</p><p>注意，字符串的位置从 $1$ 开始编号。</p><p><strong>输出格式</strong><br>对于每个询问输出一个结果，如果两个字符串子串完全相同则输出 $Yes$，否则输出 $No$。</p><p>每个结果占一行。</p><p><strong>数据范围</strong><br>$1≤n,m≤10^5$</p><p><strong>输入样例：</strong></p><blockquote><p>8 3<br>aabbaabb<br>1 3 5 7<br>1 3 6 8<br>1 2 1 2</p></blockquote><p><strong>输出样例：</strong></p><blockquote><p>Yes<br>No<br>Yes</p></blockquote><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><div class="tabs" id="g_tab0"><ul class="nav-tabs"><li class="tab active"><a href="#g_tab0-1">C++</a></li><li class="tab"><a href="#g_tab0-2">Java</a></li></ul><div class="tab-content"><div class="tab-pane active" id="g_tab0-1"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">using</span> ull = <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="built_in">string</span> s;</span><br><span class="line"></span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> P_VAL = <span class="number">131</span>;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line">ull h[N], p[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">create_string_hash</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">    p[<span class="number">0</span>] = <span class="number">1</span>; h[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">    &#123;</span><br><span class="line">        p[i] = p[i - <span class="number">1</span>] * P_VAL;</span><br><span class="line">        h[i] = h[i - <span class="number">1</span>] * P_VAL + s[i - <span class="number">1</span>]; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// the unsigned long long value overflow will equivalent to the value mod max value of unsigned long long </span></span><br><span class="line"><span class="function">ull <span class="title">get_hash_val</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">false</span>) </span><br><span class="line">    &#123;</span><br><span class="line">        l = l ^ r;</span><br><span class="line">        r = l ^ r;</span><br><span class="line">        l = l ^ r;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> h[r] - h[l - <span class="number">1</span>] * p[r - l + <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; s;</span><br><span class="line">    create_string_hash();</span><br><span class="line">    <span class="keyword">for</span> (; m--;)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> l1, r1, l2, r2;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; l1 &gt;&gt; r1 &gt;&gt; l2 &gt;&gt; r2;</span><br><span class="line">        ull hash_val_1 = get_hash_val(l1, r1);</span><br><span class="line">        ull hash_val_2 = get_hash_val(l2, r2);</span><br><span class="line">        <span class="comment">//cout &lt;&lt; hash_val_1 &lt;&lt; " " &lt;&lt; hash_val_2 &lt;&lt; endl;</span></span><br><span class="line">        <span class="keyword">if</span> (hash_val_1 == hash_val_2) <span class="built_in">cout</span> &lt;&lt; <span class="string">"Yes"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; <span class="string">"No"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="g_tab0-2"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></div></div></div><h3 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h3><p>字符串前缀哈希法，本质就是不把字符串当字符串看待，而是把字符串看成一个 $P$ 进制的数。</p><p>假设有字符串 <code>12345678</code>， 我们把它看做一个 $P = 10$ 进制的数。</p><p>现在我们规定一个示例哈希算法为：每个字符的哈希值为当前字符减 <code>1</code> 这个字符得到的结果。</p><p>那么在整个字符串中，位于 $1$ 到 $8$ 区间内的字符串哈希值 $Hash(1, 8) = 12345678$.</p><p>下面我们研究子串的哈希关系。</p><p>位于 $1$ 到 $6$ 区间内的字符串哈希值 $Hash(1, 6) = 123456$.</p><p>显然位于 $7$ 到 $8$ 区间内的字符串哈希值:<br>$$Hash(7, 8) = 78 = 12345678 - 12345600 = 12345678 - 123456 \times 10^2$$<br>$$=$$<br>$$Hash(1, 8) - Hash(1, 6) \times 10^{8 - 7 + 1}$$</p><p>有结论：<br>对于一个 $P$ 进制字符串，它的 $l$ 到 $r$ 下标之间的子串哈希值满足如下公式：<br>$$Hash(l, r) = Hash(1, r) - Hash(1, l - 1) \times P^{r - l + 1}$$</p><p>在本题中，预处理前缀哈希数组 $h$，$h[i]$ 表示位于 $1$ 到 $i$ 之间的字符串哈希值。<br>根据上述结论有：</p><p>$$Hash(i, i) = Hash(1, i) - Hash(1, i - 1) \times P^{1}$$</p><p>其中 $Hash(i, i)$ 为第 $i$ 个字符的哈希值。<br>即 $h[i] = Hash(i, i) + h[i - 1] \times P$.</p><p><strong>小技巧</strong></p><blockquote><ol><li><p>根据经验，本题 $P$ 值 可以取值 $131$ 或 $13331$。</p></li><li><p>如果字符串超长，那么哈希得到的值会溢出，需要取模，我们使用 <code>unsigned long long</code> 溢出特性来自动对该类型最大值取模。</p></li></ol></blockquote><div class="note primary">            <p><strong>原题链接：</strong> <a href="https://www.acwing.com/problem/content/843/" target="_blank" rel="noopener">AcWing 841. 字符串哈希</a></p>          </div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;摘要：&lt;/strong&gt;&lt;br&gt;字符串前缀哈希法。&lt;/p&gt;
    
    </summary>
    
    
      <category term="指尖飞舞" scheme="https://ntifs.com/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/"/>
    
      <category term="算法" scheme="https://ntifs.com/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/%E7%AE%97%E6%B3%95/"/>
    
      <category term="AcWing" scheme="https://ntifs.com/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/%E7%AE%97%E6%B3%95/AcWing/"/>
    
      <category term="算法基础课" scheme="https://ntifs.com/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/%E7%AE%97%E6%B3%95/AcWing/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BE/"/>
    
      <category term="第二讲数据结构" scheme="https://ntifs.com/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/%E7%AE%97%E6%B3%95/AcWing/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BE/%E7%AC%AC%E4%BA%8C%E8%AE%B2%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="算法" scheme="https://ntifs.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="AcWing" scheme="https://ntifs.com/tags/AcWing/"/>
    
      <category term="字符串哈希" scheme="https://ntifs.com/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%93%88%E5%B8%8C/"/>
    
  </entry>
  
  <entry>
    <title>【AcWing算法基础】第二讲-数据结构-哈希表 AcWing 840. 模拟散列表</title>
    <link href="https://ntifs.com/2023/07/09/%E3%80%90AcWing%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E3%80%91%E7%AC%AC%E4%BA%8C%E8%AE%B2-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%93%88%E5%B8%8C%E8%A1%A8-AcWing-840-%E6%A8%A1%E6%8B%9F%E6%95%A3%E5%88%97%E8%A1%A8/"/>
    <id>https://ntifs.com/2023/07/09/%E3%80%90AcWing%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E3%80%91%E7%AC%AC%E4%BA%8C%E8%AE%B2-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%93%88%E5%B8%8C%E8%A1%A8-AcWing-840-%E6%A8%A1%E6%8B%9F%E6%95%A3%E5%88%97%E8%A1%A8/</id>
    <published>2023-07-08T16:27:30.000Z</published>
    <updated>2023-07-09T05:58:19.359Z</updated>
    
    <content type="html"><![CDATA[<p><strong>摘要：</strong><br>数组模拟哈希集合（哈希表），使用拉链法和开放寻址法处理冲突。</p><a id="more"></a><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>维护一个集合，支持如下几种操作：</p><ul><li>$I \quad x$，插入一个数 $x$；</li><li>$Q \quad x$，询问数 $x$ 是否在集合中出现过；</li></ul><p>现在要进行 $N$ 次操作，对于每个询问操作输出对应的结果。</p><p><strong>输入格式</strong><br>第一行包含整数 $N$，表示操作数量。<br>接下来 $N$ 行，每行包含一个操作指令，操作指令为 $I \quad $，$Q \quad x$ 中的一种。</p><p><strong>输出格式</strong><br>对于每个询问指令 $Q \quad x$，输出一个询问结果，如果 $x$ 在集合中出现过，则输出 $Yes$，否则输出 $No$。</p><p>每个结果占一行。</p><p><strong>数据范围</strong></p><ul><li>$1≤N≤10^5$</li><li>$−10^9≤x≤10^9$</li></ul><p><strong>输入样例：</strong></p><blockquote><p>5<br>I 1<br>I 2<br>I 3<br>Q 2<br>Q 5</p></blockquote><p><strong>输出样例：</strong></p><blockquote><p>Yes<br>No</p></blockquote><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><div class="tabs" id="g_tab0"><ul class="nav-tabs"><li class="tab active"><a href="#g_tab0-1">C++/拉链法</a></li><li class="tab"><a href="#g_tab0-2">C++/开放寻址法</a></li><li class="tab"><a href="#g_tab0-3">Java</a></li></ul><div class="tab-content"><div class="tab-pane active" id="g_tab0-1"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * author: zxy</span></span><br><span class="line"><span class="comment"> * code at: 2023-7-9 00:38:17</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __nullptr__ -1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> N = <span class="number">100003</span>;</span><br><span class="line"><span class="keyword">int</span> h[N], e[N], ne[N], idx;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">create_hash</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (x % N + N) % N;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> hash_val = create_hash(x);</span><br><span class="line">    <span class="comment">// inserts to linked list head</span></span><br><span class="line">    <span class="keyword">int</span> head = h[hash_val];</span><br><span class="line">    e[idx] = x;</span><br><span class="line">    ne[idx] = head;</span><br><span class="line">    <span class="comment">// updates head</span></span><br><span class="line">    h[hash_val] = idx;</span><br><span class="line">    ++idx;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">exist</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> hash_val = create_hash(x);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> ptr = h[hash_val]; ptr != __nullptr__; ptr = ne[ptr])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// exist entry in linked list</span></span><br><span class="line">        <span class="keyword">if</span> (e[ptr] == x) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// no entry in linked list or no value equals to x although x has the same hash val with each entry in linked list</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> ops;</span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="comment">// inits nullptr, using -1 as nullptr</span></span><br><span class="line">    <span class="built_in">memset</span>(h, __nullptr__, <span class="keyword">sizeof</span>(h));</span><br><span class="line">    <span class="built_in">memset</span>(ne, __nullptr__, <span class="keyword">sizeof</span>(ne));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (; n--;) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; ops &gt;&gt; x;</span><br><span class="line">        <span class="keyword">if</span> (ops == <span class="string">"I"</span>) </span><br><span class="line">        &#123;</span><br><span class="line">            insert(x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (ops == <span class="string">"Q"</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> res = exist(x);</span><br><span class="line">            <span class="keyword">if</span> (res) <span class="built_in">cout</span> &lt;&lt; <span class="string">"Yes"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; <span class="string">"No"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"UNSUPPORTED OPERATION"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="g_tab0-2"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * author: zxy</span></span><br><span class="line"><span class="comment"> * code at: 2023-7-9 00:22:20</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __unreachable__ 0x3f3f3f3f</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> N = <span class="number">200003</span>;</span><br><span class="line"><span class="keyword">int</span> h[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">create_hash</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (x % N + N) % N;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// returns the hash index of given value if value not in set</span></span><br><span class="line"><span class="comment">// or occupied location if in set</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> hash_val = create_hash(x);</span><br><span class="line">    <span class="keyword">for</span> (; h[hash_val] != __unreachable__ &amp;&amp; h[hash_val] != x ; ++hash_val)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (hash_val == N) hash_val = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> hash_val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> ops;</span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// inits h with each val equals to unreachable value</span></span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">0x3f</span>, <span class="keyword">sizeof</span>(h));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (; n--;)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; ops &gt;&gt; x;</span><br><span class="line">        <span class="keyword">int</span> hash_val = <span class="built_in">find</span>(x);</span><br><span class="line">        <span class="keyword">if</span> (ops == <span class="string">"I"</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            h[hash_val] = x;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (ops == <span class="string">"Q"</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (h[hash_val] == __unreachable__) <span class="built_in">cout</span> &lt;&lt; <span class="string">"No"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; <span class="string">"Yes"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"UNSUPPORTED OPERATION"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="g_tab0-3"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></div></div></div><h3 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h3><p>使用数组模拟集合，因为数字大小区间在 $−10^9≤x≤10^9$ 内，范围较大，需要对数字进行哈希处理，缩小到一个较小范围内。</p><p>哈希函数我们使用取模方式，对于负数，我们需要做如下处理：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> hash_val = (x % MOD + MOD) % MOD;</span><br></pre></td></tr></table></figure><p>不同的数哈希之后得到的值可能存在相同的情况，我们需要处理哈希冲突。有如下两种常见方式。</p><h4 id="拉链法"><a href="#拉链法" class="headerlink" title="拉链法"></a>拉链法</h4><p>使用一个单链表维护所有哈希值相同的数。模拟集合的数组长度选择比操作次数最大值大的最小质数，同时可以作为拉链法的哈希函数 $MOD$ 值。</p><p>集合数组值初始化为 $-1$，可以看成是空指针，集合数组存的值为单链表的头节点，对应单链表值数组 $e$ 的数组下标，单链表插入使用头插法。</p><p>单链表数据结构可以参考：<a href="https://ntifs.com/2020/11/12/【AcWing算法基础】第二讲-数据结构-单链表-AcWing-826-单链表/">AcWing 826. 单链表</a></p><p>判断存在性时，判断哈希值对应的数组存放链表头节点是否为空，或者非空情况遍历单链表逐个比较数值是否相等。</p><h4 id="开放寻址法"><a href="#开放寻址法" class="headerlink" title="开放寻址法"></a>开放寻址法</h4><p>如果哈希值对应数组被占用，则往后遍历找到新的地址，不断轮询尝试直到找到位置。</p><p>模拟集合的数组长度根据经验选择比操作次数最大值大2倍大的最小质数，同时可以作为开放寻址法的哈希函数 $MOD$ 值。</p><p>模拟集合数组存放数值，初始化为数值范围以外的 <code>0x3f3f3f3f</code>。</p><p>实现一个 $find$ 函数，判断 $hash$ 值对应的数是否存在，如果不存在说明该位置可以作为数的存放位置；如果存在则要判断是否被别的数值占用，如果被别的数值占用则向后遍历集合数组，直到找到一个满足条件的位置。</p><p>需要注意的是，我们初始化数值大小为操作数量最大值的 $2$ 倍还多，最坏的情况是每一个操作都不相同，这样我们依然有一倍的冗余，所以必然存在一个位置可以放数值。</p><div class="note primary">            <p><strong>原题链接：</strong> <a href="https://www.acwing.com/problem/content/description/842/" target="_blank" rel="noopener">AcWing 840. 模拟散列表</a></p>          </div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;摘要：&lt;/strong&gt;&lt;br&gt;数组模拟哈希集合（哈希表），使用拉链法和开放寻址法处理冲突。&lt;/p&gt;
    
    </summary>
    
    
      <category term="指尖飞舞" scheme="https://ntifs.com/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/"/>
    
      <category term="算法" scheme="https://ntifs.com/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/%E7%AE%97%E6%B3%95/"/>
    
      <category term="AcWing" scheme="https://ntifs.com/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/%E7%AE%97%E6%B3%95/AcWing/"/>
    
      <category term="算法基础课" scheme="https://ntifs.com/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/%E7%AE%97%E6%B3%95/AcWing/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BE/"/>
    
      <category term="第二讲数据结构" scheme="https://ntifs.com/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/%E7%AE%97%E6%B3%95/AcWing/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BE/%E7%AC%AC%E4%BA%8C%E8%AE%B2%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="算法" scheme="https://ntifs.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="哈希表" scheme="https://ntifs.com/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    
      <category term="AcWing" scheme="https://ntifs.com/tags/AcWing/"/>
    
  </entry>
  
  <entry>
    <title>【AcWing算法基础】第二讲-数据结构-堆 AcWing 839. 模拟堆</title>
    <link href="https://ntifs.com/2023/07/08/%E3%80%90AcWing%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E3%80%91%E7%AC%AC%E4%BA%8C%E8%AE%B2-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%A0%86-AcWing-839-%E6%A8%A1%E6%8B%9F%E5%A0%86/"/>
    <id>https://ntifs.com/2023/07/08/%E3%80%90AcWing%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E3%80%91%E7%AC%AC%E4%BA%8C%E8%AE%B2-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%A0%86-AcWing-839-%E6%A8%A1%E6%8B%9F%E5%A0%86/</id>
    <published>2023-07-07T16:51:33.000Z</published>
    <updated>2023-07-07T17:37:08.784Z</updated>
    
    <content type="html"><![CDATA[<p><strong>摘要：</strong><br>数组模拟堆。</p><a id="more"></a><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>维护一个集合，初始时集合为空，支持如下几种操作：</p><ul><li>$I \quad x$，插入一个数 $x$；</li><li>$PM$，输出当前集合中的最小值；</li><li>$DM$，删除当前集合中的最小值（数据保证此时的最小值唯一）；</li><li>$D \quad k$，删除第 $k$ 个插入的数；</li><li>$C \quad k \quad x$，修改第 $k$ 个插入的数，将其变为 $x$；<br>现在要进行 $N$ 次操作，对于所有第 $2$ 个操作，输出当前集合的最小值。</li></ul><p><strong>输入格式</strong><br>第一行包含整数 $N$。</p><p>接下来 $N$ 行，每行包含一个操作指令，操作指令为 $I \quad x$, $PM$, $DM$, $Dk$ 或 $C \quad k \quad x$ 中的一种。</p><p><strong>输入格式</strong><br>对于每个输出指令 $PM$，输出一个结果，表示当前集合中的最小值。</p><p>每个结果占一行。</p><p><strong>数据范围</strong></p><ul><li>$1≤N≤10^5$</li><li>$−10^9≤x≤10^9$</li></ul><p>数据保证合法。</p><p><strong>输入样例：</strong></p><blockquote><p>8<br>I -10<br>PM<br>I -10<br>D 1<br>C 2 8<br>I 6<br>PM<br>DM</p></blockquote><p><strong>输出样例：</strong></p><blockquote><p>-10<br>6</p></blockquote><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><div class="tabs" id="g_tab0"><ul class="nav-tabs"><li class="tab active"><a href="#g_tab0-1">C++</a></li><li class="tab"><a href="#g_tab0-2">Java</a></li></ul><div class="tab-content"><div class="tab-pane active" id="g_tab0-1"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * author: zxy</span></span><br><span class="line"><span class="comment"> * code at: 2023-7-8 01:37:00</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1000010</span>;</span><br><span class="line"><span class="keyword">int</span> h[N], ph[N], hp[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, idx;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">heap_swap</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> k1 = hp[u];</span><br><span class="line">    <span class="keyword">int</span> k2 = hp[i];</span><br><span class="line">    ph[k1] = i;</span><br><span class="line">    ph[k2] = u;</span><br><span class="line">    hp[u] = k2;</span><br><span class="line">    hp[i] = k1;</span><br><span class="line">    swap(h[u], h[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">heap_swap_1</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    swap(ph[hp[a]],ph[hp[b]]);</span><br><span class="line">    swap(hp[a], hp[b]);</span><br><span class="line">    swap(h[a], h[b]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">down</span><span class="params">(<span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> u = i;</span><br><span class="line">    <span class="keyword">if</span> (i * <span class="number">2</span> &lt;= idx &amp;&amp; h[i * <span class="number">2</span>] &lt; h[i]) u = i * <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (i * <span class="number">2</span> + <span class="number">1</span> &lt;= idx &amp;&amp; h[i * <span class="number">2</span> + <span class="number">1</span>] &lt; h[u]) u = i * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (u != i)</span><br><span class="line">    &#123;</span><br><span class="line">        heap_swap(u, i);</span><br><span class="line">        down(u);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">up</span><span class="params">(<span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (; i &gt;&gt; <span class="number">1</span> &amp;&amp; h[i &gt;&gt; <span class="number">1</span>] &gt; h[i];) </span><br><span class="line">    &#123;</span><br><span class="line">        heap_swap(i, i &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        i &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (; n--;)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">string</span> ops;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; ops;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> k, x;</span><br><span class="line">        <span class="keyword">if</span> (ops == <span class="string">"I"</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">static</span> <span class="keyword">int</span> insert_cnt = <span class="number">0</span>;</span><br><span class="line">            ++insert_cnt;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line">            h[++idx] = x;</span><br><span class="line">            ph[insert_cnt] = idx;</span><br><span class="line">            hp[idx] = insert_cnt;</span><br><span class="line">            up(idx);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (ops == <span class="string">"PM"</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; h[<span class="number">1</span>] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (ops == <span class="string">"DM"</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            heap_swap(<span class="number">1</span>, idx);</span><br><span class="line">            --idx;</span><br><span class="line">            down(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (ops == <span class="string">"D"</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; k;</span><br><span class="line">            <span class="keyword">int</span> k_idx = ph[k];</span><br><span class="line">            heap_swap(k_idx, idx);</span><br><span class="line">            --idx;</span><br><span class="line">            up(k_idx);</span><br><span class="line">            down(k_idx);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (ops == <span class="string">"C"</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; k &gt;&gt; x;</span><br><span class="line">            <span class="keyword">int</span> k_idx = ph[k];</span><br><span class="line">            h[k_idx] = x;</span><br><span class="line">            up(k_idx);</span><br><span class="line">            down(k_idx);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="g_tab0-2"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></div></div></div><h3 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h3><p>数组模拟堆，建堆逻辑见这篇文章：<a href="https://ntifs.com/2023/06/25/【AcWing算法基础】第二讲-数据结构-堆-AcWing-838-堆排序/">AcWing 838. 堆排序</a></p><p>相比较，本题额外需要支持删除和修改第k个插入的数。那么我们需要维护一个数据结构可以对应找到第 $k$ 个插入的数在堆数组中的位置。</p><p>我们用 $ph$ 数组维护该映射关系，<code>int u = ph[k]</code> 表示第 $k$ 个插入的数在堆数组 $h$ 中的下标为 $u$。</p><p>仔细思考不难发现，当我们交换堆数组中两个元素数值的位置时，如果用传统的 $swap$ 方法交换数组数值位置，会打乱第 $k$ 个插入数在下标K和堆数组数值下标的映射关系。所以交换时我们也必须要同时交换这个映射关系。</p><p>继续思考容易想到，在我们交换两个数插入次序和值下标映射关系时，需要知道两个值下标对应的 $k$ 是多少，因为我们交换函数的入参只有两个值在堆数组中的下标。那么我们需要维护一个数据结构可以根据堆数组数值下标找到其插入次序。</p><p>我们用 $hp$ 数组维护该映射关系，<code>int k = hp[u]</code> 表示堆数组下标为 $u$ 的数是第 $k$ 次插入的。</p><p>重构交换函数，逻辑是：</p><ol><li>先根据两个值在堆数组中的下标找到两个数分别是第几次插入的（用到未交换次序的 $hp$ 数组），再根据两者的插入次序交换其对应在堆数组中的下标，完成第一次 $ph$ 映射交换；</li><li>接着根据两个值在数组中的下标交换其对应的插入次序，完成第二次 $hp$ 映射交换；</li><li>进行堆数组数值交换。</li></ol><div class="note primary">            <p><strong>原题链接：</strong> <a href="https://www.acwing.com/problem/content/841/" target="_blank" rel="noopener">AcWing 839. 模拟堆</a></p>          </div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;摘要：&lt;/strong&gt;&lt;br&gt;数组模拟堆。&lt;/p&gt;
    
    </summary>
    
    
      <category term="指尖飞舞" scheme="https://ntifs.com/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/"/>
    
      <category term="算法" scheme="https://ntifs.com/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/%E7%AE%97%E6%B3%95/"/>
    
      <category term="AcWing" scheme="https://ntifs.com/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/%E7%AE%97%E6%B3%95/AcWing/"/>
    
      <category term="算法基础课" scheme="https://ntifs.com/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/%E7%AE%97%E6%B3%95/AcWing/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BE/"/>
    
      <category term="第二讲数据结构" scheme="https://ntifs.com/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/%E7%AE%97%E6%B3%95/AcWing/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BE/%E7%AC%AC%E4%BA%8C%E8%AE%B2%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="算法" scheme="https://ntifs.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="AcWing" scheme="https://ntifs.com/tags/AcWing/"/>
    
      <category term="堆" scheme="https://ntifs.com/tags/%E5%A0%86/"/>
    
  </entry>
  
  <entry>
    <title>【AcWing算法基础】第二讲-数据结构-堆 AcWing 838. 堆排序</title>
    <link href="https://ntifs.com/2023/06/25/%E3%80%90AcWing%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E3%80%91%E7%AC%AC%E4%BA%8C%E8%AE%B2-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%A0%86-AcWing-838-%E5%A0%86%E6%8E%92%E5%BA%8F/"/>
    <id>https://ntifs.com/2023/06/25/%E3%80%90AcWing%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E3%80%91%E7%AC%AC%E4%BA%8C%E8%AE%B2-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%A0%86-AcWing-838-%E5%A0%86%E6%8E%92%E5%BA%8F/</id>
    <published>2023-06-25T15:44:13.000Z</published>
    <updated>2023-07-07T16:58:47.486Z</updated>
    
    <content type="html"><![CDATA[<p><strong>摘要：</strong><br>堆排序模板题。</p><a id="more"></a><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>输入一个长度为 $n$ 的整数数列，从小到大输出前 $m$ 小的数。</p><p><strong>输入格式</strong><br>第一行包含整数 $n$ 和 $m$。</p><p>第二行包含 $n$ 个整数，表示整数数列。</p><p><strong>输出格式</strong><br>共一行，包含 $m$ 个整数，表示整数数列中前 $m$ 小的数。</p><p><strong>数据范围</strong></p><ul><li>$1≤m≤n≤10^5$</li><li>$1≤数列中元素≤10^9$</li></ul><p><strong>输入样例：</strong></p><blockquote><p>5 3<br>4 5 1 3 2</p></blockquote><p><strong>输出样例：</strong></p><blockquote><p>1 2 3</p></blockquote><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><div class="tabs" id="g_tab0"><ul class="nav-tabs"><li class="tab active"><a href="#g_tab0-1">C++</a></li><li class="tab"><a href="#g_tab0-2">Java</a></li></ul><div class="tab-content"><div class="tab-pane active" id="g_tab0-1"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, cnt;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e6</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> a[N];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">down</span><span class="params">(<span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> u = i;</span><br><span class="line">    <span class="keyword">if</span> (i * <span class="number">2</span> &lt;= cnt &amp;&amp; a[i * <span class="number">2</span>] &lt; a[u]) u = i * <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (i * <span class="number">2</span> + <span class="number">1</span> &lt;= cnt &amp;&amp; a[i * <span class="number">2</span> + <span class="number">1</span>] &lt; a[u]) u = i * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (u != i)</span><br><span class="line">    &#123;</span><br><span class="line">        swap(a[i], a[u]);</span><br><span class="line">        down(u);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span>  &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">    </span><br><span class="line">    cnt = n;</span><br><span class="line">    <span class="comment">// build tree</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = cnt / <span class="number">2</span>; i &gt; <span class="number">0</span>; -- i) </span><br><span class="line">    &#123;</span><br><span class="line">        down(i);    </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (; m--;)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> x = a[<span class="number">1</span>];</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">        <span class="keyword">int</span> leaf = a[cnt--];</span><br><span class="line">        a[<span class="number">1</span>] = leaf;</span><br><span class="line">        down(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="g_tab0-2"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></div></div></div><h3 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h3><p>建堆数据结构：使用数组维护一颗二叉树，从下标 $1$ 开始，$a[i]$ 表示第 $i$ 个节点，$a[i \times 2]$ 表示其左孩子，$a[i \times 2 + 1]$ 表示其右孩子。这样，$a[N]$ 的数组恰好可以表示一颗节点数为N的二叉树。</p><p>建堆过程：初始化输入的数组表示无序堆，从第一个存在孩子的节点 $a[k]$ 开始进行节点下沉操作，其中，$k = N \div 2$. 在数组中，$k$ 右边的数不可能有孩子节点，因为超出数组边界。对 $a[k]$ 节点下沉后，依次在数组中向左遍历，进行节点下沉。</p><p>节点下沉：把 $a[k]$ 节点和其左右孩子节点比较值大小，如果 $a[k]$ 比任意一个节点小，则进行数组元素交换，在树中表现为节点和比自己小的某一个孩子节点交换位置。反之，$a[k]$ 比所有孩子节点都大，则当前堆的子结构有序，节点位置不变。最终 $a[k]$ 会找到一个树中合适的位置，该位置满足节点值比两个孩子节点的值都小，且两个孩子节点和各自的孩子节点相比依然小。</p><p>删除节点：大根堆的堆顶最小，得到最小值后，需要删除根节点。删除的方式可以复用建堆时用到的节点下沉模式，即，将某一个子节点赋值给根节点，根节点执行节点下沉。这样根节点被覆盖，再下沉到合适的位置，就完成了删除操作。注意，选取某个子节点给根节点赋值的时候，可以选数组最后一个元素，再将最后一个元素弹出序列，已达到节点替换的效果。</p><p>值得注意的点：在节点下沉过程中，需要在三个节点中两两比较，我们使用两次比较完成。第一次得到两个节点的最小值，在将最小值和第三个节点比较。</p><div class="note primary">            <p><strong>原题链接：</strong> <a href="https://www.acwing.com/problem/content/840/" target="_blank" rel="noopener">AcWing 838. 堆排序</a></p>          </div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;摘要：&lt;/strong&gt;&lt;br&gt;堆排序模板题。&lt;/p&gt;
    
    </summary>
    
    
      <category term="指尖飞舞" scheme="https://ntifs.com/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/"/>
    
      <category term="算法" scheme="https://ntifs.com/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/%E7%AE%97%E6%B3%95/"/>
    
      <category term="AcWing" scheme="https://ntifs.com/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/%E7%AE%97%E6%B3%95/AcWing/"/>
    
      <category term="算法基础课" scheme="https://ntifs.com/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/%E7%AE%97%E6%B3%95/AcWing/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BE/"/>
    
      <category term="第二讲数据结构" scheme="https://ntifs.com/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/%E7%AE%97%E6%B3%95/AcWing/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BE/%E7%AC%AC%E4%BA%8C%E8%AE%B2%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="算法" scheme="https://ntifs.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="TopK" scheme="https://ntifs.com/tags/TopK/"/>
    
      <category term="AcWing" scheme="https://ntifs.com/tags/AcWing/"/>
    
      <category term="堆" scheme="https://ntifs.com/tags/%E5%A0%86/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 196. 删除重复的电子邮箱</title>
    <link href="https://ntifs.com/2022/09/18/LeetCode-196-%E5%88%A0%E9%99%A4%E9%87%8D%E5%A4%8D%E7%9A%84%E7%94%B5%E5%AD%90%E9%82%AE%E7%AE%B1/"/>
    <id>https://ntifs.com/2022/09/18/LeetCode-196-%E5%88%A0%E9%99%A4%E9%87%8D%E5%A4%8D%E7%9A%84%E7%94%B5%E5%AD%90%E9%82%AE%E7%AE%B1/</id>
    <published>2022-09-18T07:49:57.000Z</published>
    <updated>2023-07-04T14:06:51.134Z</updated>
    
    <content type="html"><![CDATA[<p><strong>摘要：</strong><br>考察字段值不唯一情况下的自连接（全排列映射）。</p><a id="more"></a><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p><a href="https://leetcode.cn/problems/delete-duplicate-emails/" target="_blank" rel="noopener">LeetCode 196. 删除重复的电子邮箱</a></p><h3 id="自连接"><a href="#自连接" class="headerlink" title="自连接"></a>自连接</h3><p>通过 <code>Email</code> 字段自连接，生成一张临时表。在这张表中，因为 <code>Email</code> 字段值存在重复，所以会存在交叉映射记录。<br>如对于表 <code>Person</code>:</p><table><thead><tr><th align="center">id</th><th align="center">Email</th></tr></thead><tbody><tr><td align="center">1</td><td align="center"><a href="mailto:john@example.com">john@example.com</a></td></tr><tr><td align="center">2</td><td align="center"><a href="mailto:bob@example.com">bob@example.com</a></td></tr><tr><td align="center">3</td><td align="center"><a href="mailto:john@example.com">john@example.com</a></td></tr></tbody></table><p>建立自连接:<br><code>select a.id, a.Email, b.id, b.Email from Person a inner join Person b on a.email = b.email;</code><br>后形成临时表：</p><table><thead><tr><th align="center">id</th><th align="center">Email</th><th align="center">id(1)</th><th align="center">Email(1)</th></tr></thead><tbody><tr><td align="center">1</td><td align="center"><a href="mailto:john@example.com">john@example.com</a></td><td align="center">1</td><td align="center"><a href="mailto:john@example.com">john@example.com</a></td></tr><tr><td align="center">3</td><td align="center"><a href="mailto:john@example.com">john@example.com</a></td><td align="center">1</td><td align="center"><a href="mailto:john@example.com">john@example.com</a></td></tr><tr><td align="center">2</td><td align="center"><a href="mailto:bob@example.com">bob@example.com</a></td><td align="center">2</td><td align="center"><a href="mailto:bob@example.com">bob@example.com</a></td></tr><tr><td align="center">1</td><td align="center"><a href="mailto:john@example.com">john@example.com</a></td><td align="center">3</td><td align="center"><a href="mailto:john@example.com">john@example.com</a></td></tr><tr><td align="center">3</td><td align="center"><a href="mailto:john@example.com">john@example.com</a></td><td align="center">3</td><td align="center"><a href="mailto:john@example.com">john@example.com</a></td></tr></tbody></table><p>由上可知，显然只有 <code>Email = bob@example.com</code> 的情况，两张表映射唯一。<br>而对于 <code>Email = john@example.com</code> 的情况，存在 $4$ 种全排列映射情况。</p><p>为了删除重复记录中 <code>id</code> 最大的记录，可以限定条件：<code>a.id &gt; b.id</code></p><div class="tabs" id="g_tab0"><ul class="nav-tabs"><li class="tab active"><a href="#g_tab0-1">MySQL</a></li></ul><div class="tab-content"><div class="tab-pane active" id="g_tab0-1"><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">delete a from Person as a</span><br><span class="line">inner join Person as b</span><br><span class="line">on a.email &#x3D; b.email and a.id &gt; b.id;</span><br></pre></td></tr></table></figure></div></div></div><div class="note primary">            <p><strong>原题链接：</strong> <a href="https://leetcode.cn/problems/delete-duplicate-emails/" target="_blank" rel="noopener">LeetCode 196. 删除重复的电子邮箱</a></p>          </div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;摘要：&lt;/strong&gt;&lt;br&gt;考察字段值不唯一情况下的自连接（全排列映射）。&lt;/p&gt;
    
    </summary>
    
    
      <category term="指尖飞舞" scheme="https://ntifs.com/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/"/>
    
      <category term="数据库" scheme="https://ntifs.com/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="MySQL" scheme="https://ntifs.com/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/"/>
    
    
      <category term="LeetCode" scheme="https://ntifs.com/tags/LeetCode/"/>
    
      <category term="MySQL" scheme="https://ntifs.com/tags/MySQL/"/>
    
      <category term="数据库" scheme="https://ntifs.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>【AcWing算法基础】第二讲-数据结构-并查集 AcWing 836. 合并集合</title>
    <link href="https://ntifs.com/2022/09/18/%E3%80%90AcWing%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E3%80%91%E7%AC%AC%E4%BA%8C%E8%AE%B2-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%B9%B6%E6%9F%A5%E9%9B%86-AcWing-836-%E5%90%88%E5%B9%B6%E9%9B%86%E5%90%88/"/>
    <id>https://ntifs.com/2022/09/18/%E3%80%90AcWing%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E3%80%91%E7%AC%AC%E4%BA%8C%E8%AE%B2-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%B9%B6%E6%9F%A5%E9%9B%86-AcWing-836-%E5%90%88%E5%B9%B6%E9%9B%86%E5%90%88/</id>
    <published>2022-09-18T06:51:54.000Z</published>
    <updated>2023-07-04T14:06:51.134Z</updated>
    
    <content type="html"><![CDATA[<p><strong>摘要：</strong><br>并查集模板题。</p><a id="more"></a><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>一共有 $n$ 个数，编号是 $1∼n$，最开始每个数各自在一个集合中。</p><p>现在要进行 $m$ 个操作，操作共有两种：</p><ol><li><code>M a b</code>，将编号为 $a$ 和 $b$ 的两个数所在的集合合并，如果两个数已经在同一个集合中，则忽略这个操作；</li><li><code>Q a b</code>，询问编号为 $a$ 和 $b$ 的两个数是否在同一个集合中；</li></ol><p><strong>输入格式</strong><br>第一行输入整数 $n$ 和 $m$。</p><p>接下来 $m$ 行，每行包含一个操作指令，指令为 <code>M a b</code> 或 <code>Q a b</code> 中的一种。</p><p><strong>输出格式</strong><br>对于每个询问指令 <code>Q a b</code>，都要输出一个结果，如果 $a$ 和 $b$ 在同一集合内，则输出 <code>Yes</code>，否则输出 <code>No</code>。</p><p>每个结果占一行。</p><p><strong>数据范围</strong><br>$1≤n,m≤10^5$</p><p><strong>输入样例：</strong></p><blockquote><p>4 5<br>M 1 2<br>M 3 4<br>Q 1 2<br>Q 1 3<br>Q 3 4</p></blockquote><p><strong>输出样例：</strong></p><blockquote><p>Yes<br>No<br>Yes</p></blockquote><hr><h3 id="并查集-Union-Find"><a href="#并查集-Union-Find" class="headerlink" title="并查集/Union-Find"></a>并查集/Union-Find</h3><p>并查集用于解决两个不相交集合 <strong>Disjoint Set</strong> 的合并 <strong>Union</strong>，以及查询两个数是否在同一集合中 <strong>Find</strong> 的问题。<br>并查集可以以 $O(1)$ 的时间复杂度合并两个不相交集合，以及近乎 $O(1)$ 的时间复杂度查询两个数是否在同一集合中。</p><p>核心思想：</p><ol><li>维护一个森林 <strong>Forest</strong>，森林中每个节点保存该节点的父节点值。每棵树表示一个集合。</li><li>合并两个集合 <strong>Union</strong>：找到两个集合所对应的树根节点，将其中一棵树的根节点作为另一棵树根节点的子节点。本质上是合并两颗多叉树。</li><li>查找两个数是否在同一集合 <strong>Find</strong>：分别查找两个数对应森林节点的树根节点，判断根节点是否相同。</li></ol><p>路径压缩优化 <strong>Path Compression</strong>：</p><blockquote><p>在实现 <strong>Find</strong> 时，需要根据当前数在树中自底向上找到父节点直到树根。<br>可以在这个过程中压缩路径，即，找到根节点后，将路径中的每个节点的父节点指向根节点。</p></blockquote><p>实现：</p><div class="tabs" id="g_tab0"><ul class="nav-tabs"><li class="tab active"><a href="#g_tab0-1">C++</a></li></ul><div class="tab-content"><div class="tab-pane active" id="g_tab0-1"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, a, b;</span><br><span class="line"><span class="keyword">char</span> ops;</span><br><span class="line"><span class="keyword">int</span> parent[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init_forest</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) parent[i] = i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (parent[x] != x) parent[x] = <span class="built_in">find</span>(parent[x]);</span><br><span class="line">    <span class="keyword">return</span> parent[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>)-&gt;sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    init_forest();</span><br><span class="line">    <span class="keyword">for</span> (; m--, <span class="built_in">cin</span> &gt;&gt; ops &gt;&gt; a &gt;&gt; b;) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (ops == <span class="string">'M'</span>) </span><br><span class="line">        &#123;</span><br><span class="line">            parent[<span class="built_in">find</span>(a)] = <span class="built_in">find</span>(b);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">find</span>(a) == <span class="built_in">find</span>(b)) <span class="built_in">cout</span> &lt;&lt; <span class="string">"Yes"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; <span class="string">"No"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div></div><ol><li>我们令 <code>parent[x] = x</code> 定义 <code>x</code> 为根节点。</li><li>注意在实现 <code>find</code> 函数找根节点时，我们的做法是自底向上递归处理，在递归过程中如果发现当前节点不为根节点的话，就将当前节点的父节点通过递归的方式指向根节点。</li></ol><div class="note primary">            <p><strong>原题链接：</strong> <a href="https://www.acwing.com/problem/content/838/" target="_blank" rel="noopener">AcWing 836. 合并集合</a></p>          </div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;摘要：&lt;/strong&gt;&lt;br&gt;并查集模板题。&lt;/p&gt;
    
    </summary>
    
    
      <category term="指尖飞舞" scheme="https://ntifs.com/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/"/>
    
      <category term="算法" scheme="https://ntifs.com/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/%E7%AE%97%E6%B3%95/"/>
    
      <category term="AcWing" scheme="https://ntifs.com/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/%E7%AE%97%E6%B3%95/AcWing/"/>
    
      <category term="算法基础课" scheme="https://ntifs.com/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/%E7%AE%97%E6%B3%95/AcWing/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BE/"/>
    
      <category term="第二讲数据结构" scheme="https://ntifs.com/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/%E7%AE%97%E6%B3%95/AcWing/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BE/%E7%AC%AC%E4%BA%8C%E8%AE%B2%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="算法" scheme="https://ntifs.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="树" scheme="https://ntifs.com/tags/%E6%A0%91/"/>
    
      <category term="AcWing" scheme="https://ntifs.com/tags/AcWing/"/>
    
      <category term="并查集" scheme="https://ntifs.com/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    
      <category term="Union-Find" scheme="https://ntifs.com/tags/Union-Find/"/>
    
      <category term="路径压缩" scheme="https://ntifs.com/tags/%E8%B7%AF%E5%BE%84%E5%8E%8B%E7%BC%A9/"/>
    
  </entry>
  
  <entry>
    <title>语言的魅力</title>
    <link href="https://ntifs.com/2022/09/17/%E8%AF%AD%E8%A8%80%E7%9A%84%E9%AD%85%E5%8A%9B/"/>
    <id>https://ntifs.com/2022/09/17/%E8%AF%AD%E8%A8%80%E7%9A%84%E9%AD%85%E5%8A%9B/</id>
    <published>2022-09-17T15:01:25.000Z</published>
    <updated>2023-07-04T14:06:51.120Z</updated>
    
    <content type="html"><![CDATA[<p><strong>摘要：</strong></p><a id="more"></a><ol><li>不知道为啥我觉得他不帅，但真要挑毛病也挑不出来</li><li><h3 id><a href="#" class="headerlink" title></a></h3></li></ol><div class="tabs" id="g_tab0"><ul class="nav-tabs"><li class="tab active"><a href="#g_tab0-1">C++</a></li><li class="tab"><a href="#g_tab0-2">Java</a></li></ul><div class="tab-content"><div class="tab-pane active" id="g_tab0-1"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="g_tab0-2"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></div></div></div><div class="note primary">            <p><strong>原题链接：</strong> <a href></a></p>          </div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;摘要：&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>LeetCode 184. 部门工资最高的员工</title>
    <link href="https://ntifs.com/2022/09/17/LeetCode-184-%E9%83%A8%E9%97%A8%E5%B7%A5%E8%B5%84%E6%9C%80%E9%AB%98%E7%9A%84%E5%91%98%E5%B7%A5/"/>
    <id>https://ntifs.com/2022/09/17/LeetCode-184-%E9%83%A8%E9%97%A8%E5%B7%A5%E8%B5%84%E6%9C%80%E9%AB%98%E7%9A%84%E5%91%98%E5%B7%A5/</id>
    <published>2022-09-17T03:32:22.000Z</published>
    <updated>2023-07-04T14:06:51.120Z</updated>
    
    <content type="html"><![CDATA[<p><strong>摘要：</strong><br>考察GROUP BY、多表联查、多字段 IN 查询。</p><a id="more"></a><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p><a href="https://leetcode.cn/problems/department-highest-salary/" target="_blank" rel="noopener">LeetCode 184. 部门工资最高的员工</a></p><h3 id="GROUP-BY-临时表-多表联查"><a href="#GROUP-BY-临时表-多表联查" class="headerlink" title="GROUP BY + 临时表 + 多表联查"></a>GROUP BY + 临时表 + 多表联查</h3><div class="tabs" id="g_tab0"><ul class="nav-tabs"><li class="tab active"><a href="#g_tab0-1">MySQL</a></li></ul><div class="tab-content"><div class="tab-pane active" id="g_tab0-1"><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">select d.name as Department, e.name as Employee, e.salary as Salary</span><br><span class="line">from </span><br><span class="line">(</span><br><span class="line">select e.departmentId, max(e.salary) as salary</span><br><span class="line">from Employee as e</span><br><span class="line">group by e.departmentId</span><br><span class="line">) as temp</span><br><span class="line">left join Employee as e </span><br><span class="line">on e.departmentId &#x3D; temp.departmentId</span><br><span class="line">and e.salary &#x3D; temp.salary</span><br><span class="line">left join Department as d </span><br><span class="line">on e.departmentId &#x3D; d.id;</span><br></pre></td></tr></table></figure></div></div></div><p>对 <code>Employee</code> 表 <code>departmentId</code> 字段分组查询最高薪资作为临时表。<br>使用该临时表关联 <code>Employee</code> 查到每个 <code>departmentId</code> 和 最高薪资对应员工信息。<br>同时关联 <code>Department</code> 表查询部门信息。</p><p>左连接的使用：临时表来自于 <code>Employee</code> 表，所以左连接查询右表一定存在值。<br>临时表左连接 <code>Department</code> 表查询部门信息时，右表可能存在空值，我们可以允许。</p><h3 id="GROUP-BY-IN-临时表"><a href="#GROUP-BY-IN-临时表" class="headerlink" title="GROUP BY + IN + 临时表"></a>GROUP BY + IN + 临时表</h3><div class="tabs" id="g_tab0"><ul class="nav-tabs"><li class="tab active"><a href="#g_tab0-1">MySQL</a></li></ul><div class="tab-content"><div class="tab-pane active" id="g_tab0-1"><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">select d.name as Department, e.name as Employee, e.salary as Salary</span><br><span class="line">from Employee as e</span><br><span class="line">left join Department as d </span><br><span class="line">on e.departmentId &#x3D; d.id</span><br><span class="line">where (e.departmentId, e.salary) in</span><br><span class="line">(</span><br><span class="line">    select departmentId, max(salary) as salary</span><br><span class="line">    from Employee </span><br><span class="line">    group by departmentId</span><br><span class="line">);</span><br></pre></td></tr></table></figure></div></div></div><p>先关联 <code>Employee</code> 和 <code>Department</code> 两张表组合成一张大表，再使用 <code>IN</code> 条件限定范围。<br>使用 <code>GROUP BY</code> 对 <code>Employee</code> 表按照 <code>DepartmentId</code> 分组求最大薪资划定限定范围。</p><p>有趣的是多字段 <code>IN</code> 的使用。</p><div class="note primary">            <p><strong>原题链接：</strong> <a href="https://leetcode.cn/problems/department-highest-salary/" target="_blank" rel="noopener">LeetCode 184. 部门工资最高的员工</a></p>          </div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;摘要：&lt;/strong&gt;&lt;br&gt;考察GROUP BY、多表联查、多字段 IN 查询。&lt;/p&gt;
    
    </summary>
    
    
      <category term="指尖飞舞" scheme="https://ntifs.com/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/"/>
    
      <category term="数据库" scheme="https://ntifs.com/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="MySQL" scheme="https://ntifs.com/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/"/>
    
    
      <category term="LeetCode" scheme="https://ntifs.com/tags/LeetCode/"/>
    
      <category term="MySQL" scheme="https://ntifs.com/tags/MySQL/"/>
    
      <category term="数据库" scheme="https://ntifs.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>【AcWing算法基础】第二讲-数据结构-Trie AcWing 143. 最大异或对</title>
    <link href="https://ntifs.com/2022/09/16/%E3%80%90AcWing%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E3%80%91%E7%AC%AC%E4%BA%8C%E8%AE%B2-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-Trie-AcWing-143-%E6%9C%80%E5%A4%A7%E5%BC%82%E6%88%96%E5%AF%B9/"/>
    <id>https://ntifs.com/2022/09/16/%E3%80%90AcWing%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E3%80%91%E7%AC%AC%E4%BA%8C%E8%AE%B2-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-Trie-AcWing-143-%E6%9C%80%E5%A4%A7%E5%BC%82%E6%88%96%E5%AF%B9/</id>
    <published>2022-09-16T13:50:45.000Z</published>
    <updated>2023-07-04T14:06:51.119Z</updated>
    
    <content type="html"><![CDATA[<p><strong>摘要：</strong><br>Trie字典树不仅可以存储字符串，也可以存储二进制数，所以理论上Trie可以存储任意信息。</p><a id="more"></a><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>在给定的 $N$ 个整数 $A_1，A_2……A_N$ 中选出两个进行 $xor$（异或）运算，得到的结果最大是多少？</p><p><strong>输入格式</strong><br>第一行输入一个整数 $N$。</p><p>第二行输入 $N$ 个整数 $A_1～A_N$。</p><p><strong>输出格式</strong><br>输出一个整数表示答案。</p><p><strong>数据范围</strong><br>$1≤N≤10^5$,</p><p>$0≤A_i&lt;2^{31}$</p><p><strong>输入样例：</strong></p><blockquote><p>3<br>1 2 3</p></blockquote><p><strong>输出样例：</strong></p><blockquote><p>3</p></blockquote><hr><h3 id="Trie"><a href="#Trie" class="headerlink" title="Trie"></a>Trie</h3><p>暴力做法是遍历数组，对每个数，在剩余数中遍历找到和它异或最大的值。</p><p>可以对遍历找到最大异或值的步骤进行优化。</p><p>如果不考虑最大异或值的取值范围，某个数最大异或值，一定是其二进制每一位都不同的数。然而在这里取值范围是所有其他的数。</p><p>对该数二进制从左到右，我们在剩余数中找到一个数，使得其对应位的二进制值不同，如果没有则取相同。</p><p>可以使用 <code>Trie</code> 实现。构建 <code>Trie</code> 时，将每个数的二进制位从根节点开始插入。<br>查询某个数的最大异或值时，从根节点查找，如果存在二进制值相反的节点则选择该节点，不存在则选择二进制值相同的节点。</p><div class="tabs" id="g_tab0"><ul class="nav-tabs"><li class="tab active"><a href="#g_tab0-1">C++</a></li></ul><div class="tab-content"><div class="tab-pane active" id="g_tab0-1"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">using</span> ll = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100009</span>;</span><br><span class="line"><span class="keyword">int</span> n, numbers[N];</span><br><span class="line"><span class="keyword">int</span> trie[<span class="number">31</span> * N][<span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> idx;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build_trie</span><span class="params">(<span class="keyword">int</span> &amp;num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> p = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">30</span>; ~i; --i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> u = num &gt;&gt; i &amp; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (!trie[p][u]) trie[p][u] = ++idx;</span><br><span class="line">        p = trie[p][u];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">query</span><span class="params">(<span class="keyword">int</span> &amp;num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> p = <span class="number">0</span>;</span><br><span class="line">    ll target = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">30</span>; ~i; --i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> u = num &gt;&gt; i &amp; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (trie[p][!u]) </span><br><span class="line">        &#123;</span><br><span class="line">            target = (target &lt;&lt; <span class="number">1</span>) + !u;</span><br><span class="line">            p = trie[p][!u];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">        &#123;</span><br><span class="line">            target = (target &lt;&lt; <span class="number">1</span>) + u;</span><br><span class="line">            p = trie[p][u];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> target;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>)-&gt;sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) <span class="built_in">cin</span> &gt;&gt; numbers[i];</span><br><span class="line">    </span><br><span class="line">    ll res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> cur = numbers[i];</span><br><span class="line">        build_trie(cur);</span><br><span class="line">        res = <span class="built_in">max</span>(res, query(cur) ^ cur);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; res &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div></div><p>我们选择的是先对每个数拆分成二进制构建 <code>Trie</code>，再对每个数从 <code>Trie</code> 中查询最大异或值。<br>注意下 <code>Trie</code> 数组取值，因为最多 $10^5$ 个数，每个数最多 $31$ 位，所以数组行最多 $10^5 \times 31$，因为每个节点只存在两种值，$0$ 和 $1$，所以数组列为 $2$.</p><div class="note primary">            <p><strong>原题链接：</strong> <a href="https://www.acwing.com/problem/content/description/145/" target="_blank" rel="noopener">AcWing 143. 最大异或对</a></p>          </div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;摘要：&lt;/strong&gt;&lt;br&gt;Trie字典树不仅可以存储字符串，也可以存储二进制数，所以理论上Trie可以存储任意信息。&lt;/p&gt;
    
    </summary>
    
    
      <category term="指尖飞舞" scheme="https://ntifs.com/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/"/>
    
      <category term="算法" scheme="https://ntifs.com/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/%E7%AE%97%E6%B3%95/"/>
    
      <category term="AcWing" scheme="https://ntifs.com/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/%E7%AE%97%E6%B3%95/AcWing/"/>
    
      <category term="算法基础课" scheme="https://ntifs.com/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/%E7%AE%97%E6%B3%95/AcWing/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BE/"/>
    
      <category term="第二讲数据结构" scheme="https://ntifs.com/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/%E7%AE%97%E6%B3%95/AcWing/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BE/%E7%AC%AC%E4%BA%8C%E8%AE%B2%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="算法" scheme="https://ntifs.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="AcWing" scheme="https://ntifs.com/tags/AcWing/"/>
    
      <category term="字典树" scheme="https://ntifs.com/tags/%E5%AD%97%E5%85%B8%E6%A0%91/"/>
    
      <category term="Trie" scheme="https://ntifs.com/tags/Trie/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 183. 从不订购的客户</title>
    <link href="https://ntifs.com/2022/09/16/LeetCode-183-%E4%BB%8E%E4%B8%8D%E8%AE%A2%E8%B4%AD%E7%9A%84%E5%AE%A2%E6%88%B7/"/>
    <id>https://ntifs.com/2022/09/16/LeetCode-183-%E4%BB%8E%E4%B8%8D%E8%AE%A2%E8%B4%AD%E7%9A%84%E5%AE%A2%E6%88%B7/</id>
    <published>2022-09-16T09:20:21.000Z</published>
    <updated>2023-07-04T14:06:51.101Z</updated>
    
    <content type="html"><![CDATA[<p><strong>摘要：</strong><br>NOT IN子查询、左连接的使用。</p><a id="more"></a><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p><a href="https://leetcode.cn/problems/customers-who-never-order/" target="_blank" rel="noopener">LeetCode 183. 从不订购的客户</a></p><h3 id="NOT-IN-子查询"><a href="#NOT-IN-子查询" class="headerlink" title="NOT IN 子查询"></a>NOT IN 子查询</h3><div class="tabs" id="g_tab0"><ul class="nav-tabs"><li class="tab active"><a href="#g_tab0-1">MySQL</a></li></ul><div class="tab-content"><div class="tab-pane active" id="g_tab0-1"><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">select Name as Customers from Customers </span><br><span class="line">where Id not in </span><br><span class="line">(</span><br><span class="line">    select distinct(CustomerId) from Orders</span><br><span class="line">);</span><br></pre></td></tr></table></figure></div></div></div><p>从客户表中查询所有不在订单表中的 <code>Id</code>，可以使用 <code>NOT IN</code> 子查询。</p><h3 id="左连接"><a href="#左连接" class="headerlink" title="左连接"></a>左连接</h3><div class="tabs" id="g_tab0"><ul class="nav-tabs"><li class="tab active"><a href="#g_tab0-1">MySQL</a></li></ul><div class="tab-content"><div class="tab-pane active" id="g_tab0-1"><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">select Name as Customers from Customers as c </span><br><span class="line">left join Orders as o </span><br><span class="line">on c.Id &#x3D; o.CustomerId</span><br><span class="line">where o.CustomerId is null;</span><br></pre></td></tr></table></figure></div></div></div><p>根据左连接的特性，将两表连接，如果右表字段值不存在，则左表对应字段值保留，右表对应字段值为 <code>null</code>.</p><div class="note primary">            <p><strong>原题链接：</strong> <a href="https://leetcode.cn/problems/customers-who-never-order/" target="_blank" rel="noopener">LeetCode 183. 从不订购的客户</a></p>          </div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;摘要：&lt;/strong&gt;&lt;br&gt;NOT IN子查询、左连接的使用。&lt;/p&gt;
    
    </summary>
    
    
      <category term="指尖飞舞" scheme="https://ntifs.com/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/"/>
    
      <category term="数据库" scheme="https://ntifs.com/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="MySQL" scheme="https://ntifs.com/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/"/>
    
    
      <category term="LeetCode" scheme="https://ntifs.com/tags/LeetCode/"/>
    
      <category term="MySQL" scheme="https://ntifs.com/tags/MySQL/"/>
    
      <category term="数据库" scheme="https://ntifs.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>MySQL妙妙屋</title>
    <link href="https://ntifs.com/2022/09/16/MySQL%E5%A6%99%E5%A6%99%E5%B1%8B/"/>
    <id>https://ntifs.com/2022/09/16/MySQL%E5%A6%99%E5%A6%99%E5%B1%8B/</id>
    <published>2022-09-16T07:24:41.000Z</published>
    <updated>2023-07-04T14:06:51.101Z</updated>
    
    <content type="html"><![CDATA[<p><strong>摘要：</strong><br>记录MySQL零碎知识。</p><a id="more"></a><h4 id="1-MySQL语句执行顺序"><a href="#1-MySQL语句执行顺序" class="headerlink" title="1. MySQL语句执行顺序"></a>1. MySQL语句执行顺序</h4><p>顺口溜：</p><blockquote><p>哪里 <code>WHERE</code> 组队 <code>GROUP BY</code> 有 <code>HAVING</code> 顺序 <code>ORDER BY</code> 限制 <code>LIMIT</code></p></blockquote><p>从一个非常聪明的小伙伴那里学来，可以说是非常绝绝子了。<br>注意包括但不仅限于 <code>FROM</code> <code>ON</code> <code>JOIN</code> 这种虚表创建的基础语句当然优先级最高。</p><h4 id="2-对-GROUP-BY-的理解"><a href="#2-对-GROUP-BY-的理解" class="headerlink" title="2. 对 GROUP BY 的理解"></a>2. 对 GROUP BY 的理解</h4><h5 id="GROUP-BY-单个字段"><a href="#GROUP-BY-单个字段" class="headerlink" title="GROUP BY 单个字段"></a>GROUP BY 单个字段</h5><p>对于每条记录合并分组，确保该字段每组值唯一，构建虚表。<br>对于虚表中的每条记录，该字段对应值是唯一的，而其他所有字段值则分别构成容器（不去重）。因为其他字段可能存在重复，所以使用 SELECT 查询虚表时，只能使用聚合函数如 <code>SUM</code>, <code>AVG</code>等等对容器进行操作。<br>举例：对于数据库 <code>name_table</code></p><table><thead><tr><th align="center">id</th><th align="center">name</th></tr></thead><tbody><tr><td align="center">1</td><td align="center">a</td></tr><tr><td align="center">2</td><td align="center">b</td></tr><tr><td align="center">3</td><td align="center">b</td></tr></tbody></table><p>执行 <code>GROUP BY name</code> 后形成虚表 <code>name_table_virtual</code></p><table><thead><tr><th align="center">id</th><th align="center">name</th></tr></thead><tbody><tr><td align="center">1</td><td align="center">a</td></tr><tr><td align="center">2, 3</td><td align="center">b</td></tr></tbody></table><p>对虚表执行 <code>SELECT</code> 筛选操作：<br><code>SELECT COUNT(id) as cnt, name from name_table GROUP BY name WHERE name = &#39;b&#39;;</code></p><p>结果：</p><table><thead><tr><th align="center">cnt</th><th align="center">name</th></tr></thead><tbody><tr><td align="center">2</td><td align="center">b</td></tr></tbody></table><p>注意，这里如果执行 <code>COUNT(name)</code> 数量依旧是 <code>2</code>，因为虽然被 <code>GROUP BY</code> 的字段在虚表中值唯一，但是记录依然是两条。<br><code>COUNT</code> 计算的是记录数量而不是值数量。</p><h4 id="GROUP-BY-多个字段"><a href="#GROUP-BY-多个字段" class="headerlink" title="GROUP BY 多个字段"></a>GROUP BY 多个字段</h4><p>对于每条记录合并分组，确保该多个字段看成一个整体后每组值唯一，构建虚表。<br>对于虚表中的每条记录，改多个字段构成一个整体后，值唯一。而其他所有字段值则分别构成容器（不去重）。因为其他字段可能存在重复，所以使用 <code>SELECT</code> 查询虚表时，只能使用聚合函数如 <code>SUM</code>, <code>AVG</code>等等对容器进行操作。</p><p>举例：对于数据库 <code>info_table</code></p><table><thead><tr><th align="center">id</th><th align="center">name</th><th align="center">title</th></tr></thead><tbody><tr><td align="center">1</td><td align="center">a</td><td align="center">m</td></tr><tr><td align="center">2</td><td align="center">b</td><td align="center">n</td></tr><tr><td align="center">3</td><td align="center">a</td><td align="center">m</td></tr></tbody></table><p>执行 <code>GROUP BY name, title</code> 后形成虚表 <code>info_table_virtual</code></p><table><thead><tr><th align="center">id</th><th align="center">name</th><th align="center">title</th></tr></thead><tbody><tr><td align="center">1,3</td><td align="center">a</td><td align="center">m</td></tr><tr><td align="center">2</td><td align="center">b</td><td align="center">n</td></tr></tbody></table><p>对虚表执行 <code>SELECT</code> 筛选操作：<br><code>SELECT COUNT(id) as cnt, name, title from info_table GROUP BY name, title;</code></p><p>结果：</p><table><thead><tr><th align="center">cnt</th><th align="center">name</th><th>title</th></tr></thead><tbody><tr><td align="center">2</td><td align="center">a</td><td>m</td></tr><tr><td align="center">1</td><td align="center">b</td><td>n</td></tr></tbody></table><h4 id="3-TODO"><a href="#3-TODO" class="headerlink" title="3. TODO"></a>3. TODO</h4>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;摘要：&lt;/strong&gt;&lt;br&gt;记录MySQL零碎知识。&lt;/p&gt;
    
    </summary>
    
    
      <category term="指尖飞舞" scheme="https://ntifs.com/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/"/>
    
      <category term="数据库" scheme="https://ntifs.com/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="MySQL" scheme="https://ntifs.com/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/"/>
    
    
      <category term="MySQL" scheme="https://ntifs.com/tags/MySQL/"/>
    
      <category term="数据库" scheme="https://ntifs.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 182. 查找重复的电子邮箱</title>
    <link href="https://ntifs.com/2022/09/16/LeetCode-182-%E6%9F%A5%E6%89%BE%E9%87%8D%E5%A4%8D%E7%9A%84%E7%94%B5%E5%AD%90%E9%82%AE%E7%AE%B1/"/>
    <id>https://ntifs.com/2022/09/16/LeetCode-182-%E6%9F%A5%E6%89%BE%E9%87%8D%E5%A4%8D%E7%9A%84%E7%94%B5%E5%AD%90%E9%82%AE%E7%AE%B1/</id>
    <published>2022-09-16T02:38:09.000Z</published>
    <updated>2023-07-04T14:06:51.101Z</updated>
    
    <content type="html"><![CDATA[<p><strong>摘要：</strong><br>考查自连接、GROUP BY、临时表、HAVING子句的使用。</p><a id="more"></a><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p><a href="https://leetcode.cn/problems/duplicate-emails/" target="_blank" rel="noopener">LeetCode 182. 查找重复的电子邮箱</a></p><h3 id="自连接"><a href="#自连接" class="headerlink" title="自连接"></a>自连接</h3><div class="tabs" id="g_tab0"><ul class="nav-tabs"><li class="tab active"><a href="#g_tab0-1">MySQL</a></li></ul><div class="tab-content"><div class="tab-pane active" id="g_tab0-1"><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># Write your MySQL query statement below</span><br><span class="line"></span><br><span class="line">select distinct(a.Email) from Person a inner join Person b </span><br><span class="line">on a.Email &#x3D; b.Email </span><br><span class="line">and a.id !&#x3D; b.id</span><br></pre></td></tr></table></figure></div></div></div><p>使用自连接，因为要找到重复 <code>Email</code>，故可以把 <code>Email</code> 作为连接条件。另外要确保 <code>Id</code> 不同。</p><h3 id="GROUP-BY-临时表"><a href="#GROUP-BY-临时表" class="headerlink" title="GROUP BY + 临时表"></a>GROUP BY + 临时表</h3><div class="tabs" id="g_tab0"><ul class="nav-tabs"><li class="tab active"><a href="#g_tab0-1">MySQL</a></li></ul><div class="tab-content"><div class="tab-pane active" id="g_tab0-1"><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">select temp.email as Email from</span><br><span class="line">(</span><br><span class="line">select Email as email, count(Email) as count from Person </span><br><span class="line">group by Email</span><br><span class="line">) as temp </span><br><span class="line">where temp.count &gt; 1;</span><br></pre></td></tr></table></figure></div></div></div><p>我们的目的是查找重复邮箱，很显然可以想到使用 <code>GROUP BY</code> 对 <code>Email</code> 字段进行合并分组。<code>GROUP BY</code> 后相同 <code>Email</code> 会合并为一组，每组包括所有不同 <code>Id</code>。我们给 <code>Id</code> 计数可得每组数量。<br>将上述操作作为一个子查询生成一张临时表，从该表中选择查询即可得到我们想要的结果。</p><h3 id="GROUP-BY-HAVING-子句"><a href="#GROUP-BY-HAVING-子句" class="headerlink" title="GROUP BY + HAVING 子句"></a>GROUP BY + HAVING 子句</h3><p>我们分组之后可以不借助临时表而是直接使用 <code>HAVING</code> 子句对分组后的状态进行筛选查询:</p><div class="tabs" id="g_tab0"><ul class="nav-tabs"><li class="tab active"><a href="#g_tab0-1">MySQL</a></li></ul><div class="tab-content"><div class="tab-pane active" id="g_tab0-1"><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">select p.Email</span><br><span class="line">from Person as p</span><br><span class="line">group by p.Email </span><br><span class="line">having count(p.id) &gt; 1;</span><br></pre></td></tr></table></figure></div></div></div><div class="note primary">            <p><strong>原题链接：</strong> <a href="https://leetcode.cn/problems/duplicate-emails/" target="_blank" rel="noopener">LeetCode 182. 查找重复的电子邮箱</a></p>          </div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;摘要：&lt;/strong&gt;&lt;br&gt;考查自连接、GROUP BY、临时表、HAVING子句的使用。&lt;/p&gt;
    
    </summary>
    
    
      <category term="指尖飞舞" scheme="https://ntifs.com/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/"/>
    
      <category term="数据库" scheme="https://ntifs.com/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="MySQL" scheme="https://ntifs.com/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/"/>
    
    
      <category term="LeetCode" scheme="https://ntifs.com/tags/LeetCode/"/>
    
      <category term="MySQL" scheme="https://ntifs.com/tags/MySQL/"/>
    
      <category term="数据库" scheme="https://ntifs.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 181. 超过经理收入的员工</title>
    <link href="https://ntifs.com/2022/09/15/LeetCode-181-%E8%B6%85%E8%BF%87%E7%BB%8F%E7%90%86%E6%94%B6%E5%85%A5%E7%9A%84%E5%91%98%E5%B7%A5/"/>
    <id>https://ntifs.com/2022/09/15/LeetCode-181-%E8%B6%85%E8%BF%87%E7%BB%8F%E7%90%86%E6%94%B6%E5%85%A5%E7%9A%84%E5%91%98%E5%B7%A5/</id>
    <published>2022-09-15T15:54:44.000Z</published>
    <updated>2023-07-04T14:06:51.101Z</updated>
    
    <content type="html"><![CDATA[<p><strong>摘要：</strong><br>依然是自连接查询题。</p><a id="more"></a><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p><a href="https://leetcode.cn/problems/employees-earning-more-than-their-managers/" target="_blank" rel="noopener">LeetCode 181. 超过经理收入的员工</a></p><h3 id="自连接"><a href="#自连接" class="headerlink" title="自连接"></a>自连接</h3><div class="tabs" id="g_tab0"><ul class="nav-tabs"><li class="tab active"><a href="#g_tab0-1">MySQL</a></li></ul><div class="tab-content"><div class="tab-pane active" id="g_tab0-1"><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">select </span><br><span class="line">a.name as Employee</span><br><span class="line">from Employee a</span><br><span class="line">inner join Employee b</span><br><span class="line">where a.managerId &#x3D; b.id</span><br><span class="line">and a.salary &gt; b.salary;</span><br></pre></td></tr></table></figure></div></div></div><p>因为要用每一项的managerId查询对应薪水，不难想到使用自连接查询，将连接条件设置为id和managerId。使得同一张表的每条记录的id和managerId形成映射关系。</p><div class="note primary">            <p><strong>原题链接：</strong> <a href="https://leetcode.cn/problems/employees-earning-more-than-their-managers/" target="_blank" rel="noopener">LeetCode 181. 超过经理收入的员工</a></p>          </div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;摘要：&lt;/strong&gt;&lt;br&gt;依然是自连接查询题。&lt;/p&gt;
    
    </summary>
    
    
      <category term="指尖飞舞" scheme="https://ntifs.com/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/"/>
    
      <category term="数据库" scheme="https://ntifs.com/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="MySQL" scheme="https://ntifs.com/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/"/>
    
    
      <category term="LeetCode" scheme="https://ntifs.com/tags/LeetCode/"/>
    
      <category term="MySQL" scheme="https://ntifs.com/tags/MySQL/"/>
    
      <category term="数据库" scheme="https://ntifs.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 180. 连续出现的数字</title>
    <link href="https://ntifs.com/2022/09/15/LeetCode-180-%E8%BF%9E%E7%BB%AD%E5%87%BA%E7%8E%B0%E7%9A%84%E6%95%B0%E5%AD%97/"/>
    <id>https://ntifs.com/2022/09/15/LeetCode-180-%E8%BF%9E%E7%BB%AD%E5%87%BA%E7%8E%B0%E7%9A%84%E6%95%B0%E5%AD%97/</id>
    <published>2022-09-15T12:24:28.000Z</published>
    <updated>2023-07-04T14:06:51.101Z</updated>
    
    <content type="html"><![CDATA[<p><strong>摘要：</strong><br>自连接查询。</p><a id="more"></a><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p><a href="https://leetcode.cn/problems/consecutive-numbers/" target="_blank" rel="noopener">LeetCode 180. 连续出现的数字</a></p><h3 id="自连接"><a href="#自连接" class="headerlink" title="自连接"></a>自连接</h3><div class="tabs" id="g_tab0"><ul class="nav-tabs"><li class="tab active"><a href="#g_tab0-1">MySQL</a></li></ul><div class="tab-content"><div class="tab-pane active" id="g_tab0-1"><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">select distinct(a.num) as ConsecutiveNums from</span><br><span class="line">Logs a,</span><br><span class="line">Logs b,</span><br><span class="line">Logs c</span><br><span class="line">where</span><br><span class="line">a.num &#x3D; b.num and b.num &#x3D; c.num</span><br><span class="line">and a.id &#x3D; b.id - 1</span><br><span class="line">and b.id &#x3D; c.id - 1;</span><br></pre></td></tr></table></figure></div></div></div><p>连续出现三次以上，则主键连续，且值相等。不难想到使用自连接。<br>注意，考虑到同一个值可能存在多个连续片段，所以我们使用 <code>distinct</code> 关键字。</p><div class="note primary">            <p><strong>原题链接：</strong> <a href="https://leetcode.cn/problems/consecutive-numbers/" target="_blank" rel="noopener">LeetCode 180. 连续出现的数字</a></p>          </div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;摘要：&lt;/strong&gt;&lt;br&gt;自连接查询。&lt;/p&gt;
    
    </summary>
    
    
      <category term="指尖飞舞" scheme="https://ntifs.com/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/"/>
    
      <category term="数据库" scheme="https://ntifs.com/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="MySQL" scheme="https://ntifs.com/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/"/>
    
    
      <category term="LeetCode" scheme="https://ntifs.com/tags/LeetCode/"/>
    
      <category term="MySQL" scheme="https://ntifs.com/tags/MySQL/"/>
    
      <category term="数据库" scheme="https://ntifs.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 178. 分数排名</title>
    <link href="https://ntifs.com/2022/09/15/LeetCode-178-%E5%88%86%E6%95%B0%E6%8E%92%E5%90%8D/"/>
    <id>https://ntifs.com/2022/09/15/LeetCode-178-%E5%88%86%E6%95%B0%E6%8E%92%E5%90%8D/</id>
    <published>2022-09-15T10:55:16.000Z</published>
    <updated>2023-07-04T14:06:51.101Z</updated>
    
    <content type="html"><![CDATA[<p><strong>摘要：</strong><br>rank类函数使用。</p><a id="more"></a><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p><a href="https://leetcode.cn/problems/rank-scores/" target="_blank" rel="noopener">LeetCode 178. 分数排名</a></p><h3 id="rank类函数"><a href="#rank类函数" class="headerlink" title="rank类函数"></a>rank类函数</h3><div class="tabs" id="g_tab0"><ul class="nav-tabs"><li class="tab active"><a href="#g_tab0-1">MySQL</a></li></ul><div class="tab-content"><div class="tab-pane active" id="g_tab0-1"><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select score,</span><br><span class="line">dense_rank() over (order by score desc) as &#39;rank&#39;</span><br><span class="line">from Scores;</span><br></pre></td></tr></table></figure></div></div></div><p>使用稠密rank函数 <code>dense_rank() over</code> 对 <code>score</code> 字段设置 <code>rank</code>，字段相同值 <code>rank</code> 相同（稠密）。<br>函数后括号中指定设置 <code>rank</code> 所必须的字段排序。</p><div class="note primary">            <p><strong>原题链接：</strong> <a href="https://leetcode.cn/problems/rank-scores/" target="_blank" rel="noopener">LeetCode 178. 分数排名</a></p>          </div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;摘要：&lt;/strong&gt;&lt;br&gt;rank类函数使用。&lt;/p&gt;
    
    </summary>
    
    
      <category term="指尖飞舞" scheme="https://ntifs.com/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/"/>
    
      <category term="数据库" scheme="https://ntifs.com/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="MySQL" scheme="https://ntifs.com/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/"/>
    
    
      <category term="LeetCode" scheme="https://ntifs.com/tags/LeetCode/"/>
    
      <category term="MySQL" scheme="https://ntifs.com/tags/MySQL/"/>
    
      <category term="数据库" scheme="https://ntifs.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>【AcWing算法基础】第二讲-数据结构-Trie AcWing 835. Trie字符串统计</title>
    <link href="https://ntifs.com/2022/09/07/%E3%80%90AcWing%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E3%80%91%E7%AC%AC%E4%BA%8C%E8%AE%B2-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-Trie-AcWing-835-Trie%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%BB%9F%E8%AE%A1/"/>
    <id>https://ntifs.com/2022/09/07/%E3%80%90AcWing%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E3%80%91%E7%AC%AC%E4%BA%8C%E8%AE%B2-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-Trie-AcWing-835-Trie%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%BB%9F%E8%AE%A1/</id>
    <published>2022-09-07T02:56:22.000Z</published>
    <updated>2023-07-04T14:06:51.100Z</updated>
    
    <content type="html"><![CDATA[<p><strong>摘要：</strong><br>Trie模板题</p><a id="more"></a><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>维护一个字符串集合，支持两种操作：</p><p><code>I</code> <code>x</code> 向集合中插入一个字符串 <code>x</code>；<br><code>Q</code> <code>x</code> 询问一个字符串在集合中出现了多少次。<br>共有 $N$ 个操作，输入的字符串总长度不超过 $10^5$，字符串仅包含小写英文字母。</p><p><strong>输入格式</strong><br>第一行包含整数 $N$，表示操作数。</p><p>接下来 $N$ 行，每行包含一个操作指令，指令为 <code>I</code> <code>x</code> 或 <code>Q</code> <code>x</code> 中的一种。</p><p><strong>输出格式</strong><br>对于每个询问指令 <code>Q</code> <code>x</code>，都要输出一个整数作为结果，表示 <code>x</code> 在集合中出现的次数。</p><p>每个结果占一行。</p><p><strong>数据范围</strong><br>$1 ≤ N ≤ 2 \times 10^4$</p><p><strong>输入样例：</strong></p><blockquote><p>5<br>I abc<br>Q abc<br>Q ab<br>I ab<br>Q ab</p></blockquote><p><strong>输出样例：</strong></p><blockquote><p>1<br>0<br>1</p></blockquote><hr><h3 id="Trie字典树"><a href="#Trie字典树" class="headerlink" title="Trie字典树"></a>Trie字典树</h3><p>使用二维数组构建前缀树，每一个树节点对应二维数组中唯一的行，每行长度 $26$ 对应 $26$ 字母。<br><code>son</code> 数组存放当前节点子节点所在行数。<br>当一个字符串插入到前缀树中时，使用统计数组 <code>cnt</code> 记录当前跟节点对应的字符串数量。<br>使用 <code>idx</code> 记录对全部节点计数，当新的结点出现时，可以知道用二维数组哪一行表示新的节点。</p><div class="tabs" id="g_tab0"><ul class="nav-tabs"><li class="tab active"><a href="#g_tab0-1">C++</a></li></ul><div class="tab-content"><div class="tab-pane active" id="g_tab0-1"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"bits/stdc++.h"</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> son[N][<span class="number">26</span>], cnt[N], idx;</span><br><span class="line"></span><br><span class="line"><span class="comment">// son buffer -&gt; stores the row of child node </span></span><br><span class="line"><span class="comment">// a d c    a d e</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">build_trie</span><span class="params">(<span class="built_in">string</span> &amp;s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> p = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, len = s.<span class="built_in">size</span>(); i &lt; len; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> c = s[i] - <span class="string">'a'</span>;</span><br><span class="line">        <span class="keyword">if</span> (!son[p][c]) son[p][c] = ++idx;</span><br><span class="line">        p = son[p][c];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 以p行结束(叶子节点的"子节点"行)的字符串计数</span></span><br><span class="line">    cnt[p]++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="built_in">string</span> &amp;s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> p = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, len = s.<span class="built_in">size</span>(); i &lt; len; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> c = s[i] - <span class="string">'a'</span>;</span><br><span class="line">        <span class="keyword">if</span> (!son[p][c]) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        p = son[p][c];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cnt[p];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>)-&gt;sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">string</span> t; <span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line">    <span class="built_in">string</span> ops, s;</span><br><span class="line">    <span class="keyword">for</span> (; <span class="built_in">cin</span> &gt;&gt; ops, <span class="built_in">cin</span> &gt;&gt; s;) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ops == <span class="string">"I"</span>) build_trie(s);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (ops == <span class="string">"Q"</span>) <span class="built_in">cout</span> &lt;&lt; query(s) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div></div><div class="note primary">            <p><strong>原题链接：</strong> <a href="https://www.acwing.com/problem/content/837/" target="_blank" rel="noopener">AcWing 835. Trie字符串统计</a></p>          </div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;摘要：&lt;/strong&gt;&lt;br&gt;Trie模板题&lt;/p&gt;
    
    </summary>
    
    
      <category term="指尖飞舞" scheme="https://ntifs.com/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/"/>
    
      <category term="算法" scheme="https://ntifs.com/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/%E7%AE%97%E6%B3%95/"/>
    
      <category term="AcWing" scheme="https://ntifs.com/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/%E7%AE%97%E6%B3%95/AcWing/"/>
    
      <category term="算法基础课" scheme="https://ntifs.com/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/%E7%AE%97%E6%B3%95/AcWing/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BE/"/>
    
      <category term="第二讲数据结构" scheme="https://ntifs.com/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/%E7%AE%97%E6%B3%95/AcWing/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BE/%E7%AC%AC%E4%BA%8C%E8%AE%B2%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="算法" scheme="https://ntifs.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="AcWing" scheme="https://ntifs.com/tags/AcWing/"/>
    
      <category term="字典树" scheme="https://ntifs.com/tags/%E5%AD%97%E5%85%B8%E6%A0%91/"/>
    
      <category term="Trie" scheme="https://ntifs.com/tags/Trie/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 177. 第N高的薪水</title>
    <link href="https://ntifs.com/2022/04/08/LeetCode-177-%E7%AC%ACN%E9%AB%98%E7%9A%84%E8%96%AA%E6%B0%B4/"/>
    <id>https://ntifs.com/2022/04/08/LeetCode-177-%E7%AC%ACN%E9%AB%98%E7%9A%84%E8%96%AA%E6%B0%B4/</id>
    <published>2022-04-08T03:34:55.000Z</published>
    <updated>2023-07-04T14:06:51.070Z</updated>
    
    <content type="html"><![CDATA[<p><strong>摘要：</strong><br>数据库TopK问题，各种情况和对应方法。</p><a id="more"></a><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p><a href="https://leetcode-cn.com/problems/nth-highest-salary/" target="_blank" rel="noopener">LeetCode 177. 第N高的薪水</a></p><h3 id="单表查询"><a href="#单表查询" class="headerlink" title="单表查询"></a>单表查询</h3><div class="tabs" id="g_tab0"><ul class="nav-tabs"><li class="tab active"><a href="#g_tab0-1">MySQL</a></li></ul><div class="tab-content"><div class="tab-pane active" id="g_tab0-1"><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">CREATE FUNCTION getNthHighestSalary(N INT) RETURNS INT</span><br><span class="line">BEGIN</span><br><span class="line">  set N :&#x3D; N - 1;</span><br><span class="line">  RETURN (</span><br><span class="line">      # Write your MySQL query statement below.</span><br><span class="line">      select SALARY from Employee</span><br><span class="line">      group by SALARY</span><br><span class="line">      order by SALARY desc</span><br><span class="line">      limit 1 offset n</span><br><span class="line">  );</span><br><span class="line">END</span><br></pre></td></tr></table></figure></div></div></div><p>将所有数据按照salary分组，并按照salary由高到低排序。<br>再选取一条数据。<br>又因为我们需要从最高开始第 $N$ 高数据，根据 <code>offset</code> 使用规则，需要偏移 $N - 1$ 位。<br>因为 <code>offset</code> 后面不能跟表达式，只可以跟变量或数字，所以需要提前将 $N$ 设为 $N - 1$.</p><p>该方法效率中等。</p><h3 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h3><div class="tabs" id="g_tab0"><ul class="nav-tabs"><li class="tab active"><a href="#g_tab0-1">MySQL</a></li></ul><div class="tab-content"><div class="tab-pane active" id="g_tab0-1"><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">CREATE FUNCTION getNthHighestSalary(N INT) RETURNS INT</span><br><span class="line">BEGIN</span><br><span class="line">  RETURN (</span><br><span class="line">      # Write your MySQL query statement below.</span><br><span class="line">      SELECT </span><br><span class="line">          DISTINCT e.salary</span><br><span class="line">      FROM </span><br><span class="line">          employee e</span><br><span class="line">      WHERE </span><br><span class="line">          (SELECT count(DISTINCT salary) FROM employee WHERE salary&gt;e.salary) &#x3D; N-1</span><br><span class="line">  );</span><br><span class="line">END</span><br></pre></td></tr></table></figure></div></div></div><p>这个方法目前无法理解，主要是子查询中的 where条件。</p><div class="note primary">            <p><strong>原题链接：</strong> <a href="https://leetcode-cn.com/problems/nth-highest-salary/" target="_blank" rel="noopener">LeetCode 177. 第N高的薪水</a></p>          </div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;摘要：&lt;/strong&gt;&lt;br&gt;数据库TopK问题，各种情况和对应方法。&lt;/p&gt;
    
    </summary>
    
    
      <category term="指尖飞舞" scheme="https://ntifs.com/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/"/>
    
      <category term="数据库" scheme="https://ntifs.com/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="MySQL" scheme="https://ntifs.com/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/"/>
    
    
      <category term="LeetCode" scheme="https://ntifs.com/tags/LeetCode/"/>
    
      <category term="TopK" scheme="https://ntifs.com/tags/TopK/"/>
    
      <category term="排序" scheme="https://ntifs.com/tags/%E6%8E%92%E5%BA%8F/"/>
    
      <category term="MySQL" scheme="https://ntifs.com/tags/MySQL/"/>
    
      <category term="数据库" scheme="https://ntifs.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="窗口函数" scheme="https://ntifs.com/tags/%E7%AA%97%E5%8F%A3%E5%87%BD%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 176. 第二高的薪水</title>
    <link href="https://ntifs.com/2022/04/08/LeetCode-176-%E7%AC%AC%E4%BA%8C%E9%AB%98%E7%9A%84%E8%96%AA%E6%B0%B4/"/>
    <id>https://ntifs.com/2022/04/08/LeetCode-176-%E7%AC%AC%E4%BA%8C%E9%AB%98%E7%9A%84%E8%96%AA%E6%B0%B4/</id>
    <published>2022-04-08T03:27:08.000Z</published>
    <updated>2023-07-04T14:06:51.070Z</updated>
    
    <content type="html"><![CDATA[<p><strong>摘要：</strong><br>数据库TopK问题</p><a id="more"></a><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p><a href="https://leetcode-cn.com/problems/second-highest-salary/" target="_blank" rel="noopener">LeetCode 176. 第二高的薪水</a></p><h3 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h3><div class="tabs" id="g_tab0"><ul class="nav-tabs"><li class="tab active"><a href="#g_tab0-1">MySQL</a></li></ul><div class="tab-content"><div class="tab-pane active" id="g_tab0-1"><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">select</span><br><span class="line">(</span><br><span class="line">select distinct</span><br><span class="line">salary from Employee</span><br><span class="line">order by salary desc</span><br><span class="line">limit 1 offset 1</span><br><span class="line">) as SecondHighestSalary;</span><br></pre></td></tr></table></figure></div></div></div><p>对于子查询：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">select distinct</span><br><span class="line">salary from Employee</span><br><span class="line">order by salary desc</span><br><span class="line">limit 1 offset 1</span><br></pre></td></tr></table></figure><p>将查询产生一个临时数据集，当数据库总行数 &lt;= 1时，由于偏移的作用，将产生一个空集。<br>使用第二次查询可以查到null值，满足题目要求。</p><div class="note primary">            <p><strong>原题链接：</strong> <a href="https://leetcode-cn.com/problems/second-highest-salary/" target="_blank" rel="noopener">LeetCode 176. 第二高的薪水</a></p>          </div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;摘要：&lt;/strong&gt;&lt;br&gt;数据库TopK问题&lt;/p&gt;
    
    </summary>
    
    
      <category term="指尖飞舞" scheme="https://ntifs.com/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/"/>
    
      <category term="数据库" scheme="https://ntifs.com/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="MySQL" scheme="https://ntifs.com/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/"/>
    
    
      <category term="LeetCode" scheme="https://ntifs.com/tags/LeetCode/"/>
    
      <category term="TopK" scheme="https://ntifs.com/tags/TopK/"/>
    
      <category term="MySQL" scheme="https://ntifs.com/tags/MySQL/"/>
    
      <category term="数据库" scheme="https://ntifs.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
</feed>
