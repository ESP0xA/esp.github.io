<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>计算复杂性实验室</title>
  
  <subtitle>the virtual labs for virtual</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://ntifs.com/"/>
  <updated>2023-09-03T12:04:57.776Z</updated>
  <id>https://ntifs.com/</id>
  
  <author>
    <name>zxy</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>《1984》读书笔记</title>
    <link href="https://ntifs.com/2023/09/03/%E3%80%8A1984%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    <id>https://ntifs.com/2023/09/03/%E3%80%8A1984%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</id>
    <published>2023-09-03T11:12:36.000Z</published>
    <updated>2023-09-03T12:04:57.776Z</updated>
    
    <content type="html"><![CDATA[<p><strong>摘要：</strong><br>记录《1984》书中觉得写得不错的地方。</p><a id="more"></a><ul><li><p>这种酒的味道像硝酸一样，喝下去时就像后脑勺挨了一橡皮棍似的。</p></li><li></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;摘要：&lt;/strong&gt;&lt;br&gt;记录《1984》书中觉得写得不错的地方。&lt;/p&gt;
    
    </summary>
    
    
      <category term="生活" scheme="https://ntifs.com/categories/%E7%94%9F%E6%B4%BB/"/>
    
      <category term="读书" scheme="https://ntifs.com/categories/%E7%94%9F%E6%B4%BB/%E8%AF%BB%E4%B9%A6/"/>
    
    
      <category term="读书" scheme="https://ntifs.com/tags/%E8%AF%BB%E4%B9%A6/"/>
    
  </entry>
  
  <entry>
    <title>【AcWing算法基础】第三讲-搜索与图论-树与图的深度优先遍历 AcWing 846. 树的重心</title>
    <link href="https://ntifs.com/2023/09/02/%E3%80%90AcWing%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E3%80%91%E7%AC%AC%E4%B8%89%E8%AE%B2-%E6%90%9C%E7%B4%A2%E4%B8%8E%E5%9B%BE%E8%AE%BA-%E6%A0%91%E4%B8%8E%E5%9B%BE%E7%9A%84%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86-AcWing-846-%E6%A0%91%E7%9A%84%E9%87%8D%E5%BF%83/"/>
    <id>https://ntifs.com/2023/09/02/%E3%80%90AcWing%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E3%80%91%E7%AC%AC%E4%B8%89%E8%AE%B2-%E6%90%9C%E7%B4%A2%E4%B8%8E%E5%9B%BE%E8%AE%BA-%E6%A0%91%E4%B8%8E%E5%9B%BE%E7%9A%84%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86-AcWing-846-%E6%A0%91%E7%9A%84%E9%87%8D%E5%BF%83/</id>
    <published>2023-09-02T09:23:08.000Z</published>
    <updated>2023-09-11T15:07:38.363Z</updated>
    
    <content type="html"><![CDATA[<p><strong>摘要：</strong><br>使用邻接表建图并递归遍历图。</p><a id="more"></a><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给定一颗树，树中包含 $n$ 个结点（编号 $1∼n$）和 $n−1$ 条无向边。</p><p>请你找到树的重心，并输出将重心删除后，剩余各个连通块中点数的最大值。</p><p>重心定义：重心是指树中的一个结点，如果将这个点删除后，剩余各个连通块中点数的最大值最小，那么这个节点被称为树的重心。</p><p><strong>输入格式</strong><br>第一行包含整数 $n$，表示树的结点数。</p><p>接下来 $n−1$ 行，每行包含两个整数 $a$ 和 $b$，表示点 $a$ 和点 $b$ 之间存在一条边。</p><p><strong>输出格式</strong><br>输出一个整数 $m$，表示将重心删除后，剩余各个连通块中点数的最大值。</p><p><strong>数据范围</strong><br>$1≤n≤10^5$</p><p><strong>输入样例</strong></p><blockquote><p>9<br>1 2<br>1 7<br>1 4<br>2 8<br>2 5<br>4 3<br>3 9<br>4 6</p></blockquote><p><strong>输出样例：</strong></p><blockquote><p>4</p></blockquote><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><div class="tabs" id="g_tab0"><ul class="nav-tabs"><li class="tab active"><a href="#g_tab0-1">C++</a></li><li class="tab"><a href="#g_tab0-2">Java</a></li></ul><div class="tab-content"><div class="tab-pane active" id="g_tab0-1"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * author: zxy</span></span><br><span class="line"><span class="comment"> * code at: 2023-9-2 17:28:21</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __nullptr__ -1</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">2</span> * N;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> h[N], e[M], ne[M], idx;</span><br><span class="line"><span class="keyword">bool</span> st[N];</span><br><span class="line"><span class="keyword">int</span> res = M;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">link</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = b, ne[idx] = h[a], h[a] = idx++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> node_val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    st[node_val] = <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">// all_child_cnt: all child points cnt of current node</span></span><br><span class="line">    <span class="comment">// max_child_cnt: max child points cnt of current node</span></span><br><span class="line">    <span class="keyword">int</span> max_child_cnt = <span class="number">0</span>, all_child_cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = h[node_val]; i != <span class="number">-1</span>; i = ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> child_val = e[i];</span><br><span class="line">        <span class="keyword">if</span> (st[child_val]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">int</span> one_child_cnt = dfs(child_val);</span><br><span class="line">        max_child_cnt = <span class="built_in">max</span>(max_child_cnt, one_child_cnt);</span><br><span class="line">        all_child_cnt += one_child_cnt;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// when all childs processed or no child processed, returns </span></span><br><span class="line">    <span class="comment">// compares the max child point cnt with remain node cnt(parent nodes)</span></span><br><span class="line">    <span class="keyword">int</span> max_cnt_of_all_parts = <span class="built_in">max</span>(max_child_cnt, n - all_child_cnt - <span class="number">1</span>);</span><br><span class="line">    res = <span class="built_in">min</span>(res, max_cnt_of_all_parts);</span><br><span class="line">    <span class="keyword">return</span> all_child_cnt + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(h, __nullptr__, <span class="keyword">sizeof</span> h);</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> cnt = n - <span class="number">1</span>; cnt--;) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> a, b;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b;</span><br><span class="line">        link(a, b), link(b, a);</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; res &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="g_tab0-2"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></div></div></div><h3 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h3><p>我们使用邻接表构建。如图：<br><img src="/2023/09/02/%E3%80%90AcWing%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E3%80%91%E7%AC%AC%E4%B8%89%E8%AE%B2-%E6%90%9C%E7%B4%A2%E4%B8%8E%E5%9B%BE%E8%AE%BA-%E6%A0%91%E4%B8%8E%E5%9B%BE%E7%9A%84%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86-AcWing-846-%E6%A0%91%E7%9A%84%E9%87%8D%E5%BF%83/adjacency_list.jpg" alt="demo"><br>维护一个数组，下标表示图中每个节点的值，数组每个下标对应一个链表结构，维护下标节点的所有相邻节点。</p><p>本题建图的过程中，对于每组节点 $a,b$，我们分别以 $a$ 为起点构建到 $b$ 的边，以及以 $b$ 为起点构建到 $a$ 的边。在该过程中会分别在 $a$ 和 $b$ 的下标处使用头插法向链表中插入 $b$ 和 $a$。</p><p>根据题目描述，存在一个节点，去除之后剩余各部分节点数的最大值最小。求这个节点以及最小的连通块节点数量。</p><p>核心思想是对每个节点求解一遍去除自身节点后的剩余连通块最大值，并相互比较取最小值。</p><p>使用DFS遍历图，对于某节点 $a$，我们的遍历顺序是为其每个孩子节点进行一次向下递归搜索。当从遍历到达叶子结点后开始回溯，在回溯过程中，可以得到回溯经过的节点的所有孩子节点数量，并向上返回。最终回到节点 $a$ 时，我们可以得到所有直系孩子连通块的节点数量，并比较得出最大值。</p><p>值得注意的是，对于该节点 $a$，它的所有直接连通块除了所有孩子连通块外，还有父连通块。因为我们知道所有节点数量，故可简单使用总数减去所有孩子连通块节点总数得到父连通块的节点数量。</p><p>这样，对于节点 $a$，我们知道了所有连通块的节点数量，可以取最大值，并维护起来，方便与其他节点进行比较，取最小值即可。</p><p>另外，代码开数组时，注意下标取值范围。节点数范围为 $1≤n≤10^5$，建图过程中，对于$a,b$ 两点会分别连接 $a$ 到 $b$ 和 $b$ 到 $a$。<br>在该过程中，$h$ 数组下标对应 $a$ 和 $b$ 及其他节点的值，范围始终在 $n$ 内，所以 $h$ 数组大小取 $10^5 + 10$ 即可；<br>然而 $e$ 数组和 $ne$ 数组下标对应 $idx$，因为每两点构建两次边，所以 $idx$ 一直向后递增总数翻倍，故 $e$ 和 $ne$ 的下标范围取 $2$ 倍的 $10^5 + 10$.</p><p><code>dfs(1)</code>表示从1号点开始搜，我们可以从任意一个点开始搜。</p><div class="note primary">            <p><strong>原题链接：</strong> <a href="https://www.acwing.com/problem/content/848/" target="_blank" rel="noopener">AcWing 846. 树的重心</a></p>          </div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;摘要：&lt;/strong&gt;&lt;br&gt;使用邻接表建图并递归遍历图。&lt;/p&gt;
    
    </summary>
    
    
      <category term="指尖飞舞" scheme="https://ntifs.com/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/"/>
    
      <category term="算法" scheme="https://ntifs.com/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/%E7%AE%97%E6%B3%95/"/>
    
      <category term="AcWing" scheme="https://ntifs.com/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/%E7%AE%97%E6%B3%95/AcWing/"/>
    
      <category term="算法基础课" scheme="https://ntifs.com/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/%E7%AE%97%E6%B3%95/AcWing/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BE/"/>
    
      <category term="第三讲搜索与图论" scheme="https://ntifs.com/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/%E7%AE%97%E6%B3%95/AcWing/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BE/%E7%AC%AC%E4%B8%89%E8%AE%B2%E6%90%9C%E7%B4%A2%E4%B8%8E%E5%9B%BE%E8%AE%BA/"/>
    
    
      <category term="算法" scheme="https://ntifs.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="DFS" scheme="https://ntifs.com/tags/DFS/"/>
    
      <category term="AcWing" scheme="https://ntifs.com/tags/AcWing/"/>
    
      <category term="图论" scheme="https://ntifs.com/tags/%E5%9B%BE%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>【AcWing算法基础】第三讲-搜索与图论-BFS AcWing 845. 八数码</title>
    <link href="https://ntifs.com/2023/08/27/%E3%80%90AcWing%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E3%80%91%E7%AC%AC%E4%B8%89%E8%AE%B2-%E6%90%9C%E7%B4%A2%E4%B8%8E%E5%9B%BE%E8%AE%BA-BFS-AcWing-845-%E5%85%AB%E6%95%B0%E7%A0%81/"/>
    <id>https://ntifs.com/2023/08/27/%E3%80%90AcWing%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E3%80%91%E7%AC%AC%E4%B8%89%E8%AE%B2-%E6%90%9C%E7%B4%A2%E4%B8%8E%E5%9B%BE%E8%AE%BA-BFS-AcWing-845-%E5%85%AB%E6%95%B0%E7%A0%81/</id>
    <published>2023-08-27T15:47:32.000Z</published>
    <updated>2023-08-27T16:47:12.194Z</updated>
    
    <content type="html"><![CDATA[<p><strong>摘要：</strong><br>BFS方法解决以抽象状态变化为基础的搜索问题。</p><a id="more"></a><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>在一个 $3 \times 3$ 的网格中，$1∼8$ 这 $8$ 个数字和一个 <code>x</code> 恰好不重不漏地分布在这 $3 \times 3$ 的网格中。</p><p>例如：</p><blockquote><p>1 2 3<br>x 4 6<br>7 5 8</p></blockquote><p>在游戏过程中，可以把 <code>x</code> 与其上、下、左、右四个方向之一的数字交换（如果存在）。</p><p>我们的目的是通过交换，使得网格变为如下排列（称为正确排列）：</p><blockquote><p>1 2 3<br>4 5 6<br>7 8 x</p></blockquote><p>例如，示例中图形就可以通过让 <code>x</code> 先后与右、下、右三个方向的数字交换成功得到正确排列。</p><p>交换过程如下：</p><blockquote><p>1 2 3<br>x 4 6<br>7 5 8</p></blockquote><p>to</p><blockquote><p>1 2 3<br>4 x 6<br>7 5 8</p></blockquote><p>to</p><blockquote><p>1 2 3<br>4 5 6<br>7 x 8</p></blockquote><p>to</p><blockquote><p>1 2 3<br>4 5 6<br>7 8 x</p></blockquote><p>现在，给你一个初始网格，请你求出得到正确排列至少需要进行多少次交换。</p><p><strong>输入格式</strong><br>输入占一行，将 $3 \times 3$ 的初始网格描绘出来。</p><p>例如，如果初始网格如下所示：</p><blockquote><p>1 2 3<br>x 4 6<br>7 5 8 </p></blockquote><p>则输入为：<code>1 2 3 x 4 6 7 5 8</code></p><p><strong>输出格式</strong><br>输出占一行，包含一个整数，表示最少交换次数。</p><p>如果不存在解决方案，则输出 $−1$。</p><p><strong>输入样例：</strong></p><blockquote><p>2 3 4 1 5 x 7 6 8</p></blockquote><p><strong>输出样例</strong></p><blockquote><p>19</p></blockquote><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><div class="tabs" id="g_tab0"><ul class="nav-tabs"><li class="tab active"><a href="#g_tab0-1">C++</a></li><li class="tab"><a href="#g_tab0-2">Java</a></li></ul><div class="tab-content"><div class="tab-pane active" id="g_tab0-1"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * author: zxy</span></span><br><span class="line"><span class="comment"> * code at: 2023-8-27 11:59:50</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; d;</span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="built_in">string</span>&gt; q;</span><br><span class="line"><span class="keyword">int</span> dr[<span class="number">4</span>] = &#123;<span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>&#125;, dc[<span class="number">4</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> res = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">(<span class="built_in">string</span> graph)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    q.push(graph);</span><br><span class="line">    d[graph] = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">string</span> final_graph = <span class="string">"12345678x"</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (; q.<span class="built_in">size</span>(); )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">string</span> cur = q.front();</span><br><span class="line">        q.pop();</span><br><span class="line">        <span class="keyword">int</span> distance = d[cur];</span><br><span class="line">        <span class="keyword">if</span> (cur == final_graph)</span><br><span class="line">        &#123;</span><br><span class="line">            res = distance;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> pos = cur.<span class="built_in">find</span>(<span class="string">'x'</span>);</span><br><span class="line">        <span class="keyword">int</span> r = pos / <span class="number">3</span>, c = pos % <span class="number">3</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++ i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> ner = r + dr[i], nec = c + dc[i];</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (ner &gt;= <span class="number">0</span> &amp;&amp; ner &lt; <span class="number">3</span> &amp;&amp; nec &gt;= <span class="number">0</span> &amp;&amp; nec &lt; <span class="number">3</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> ne_pos = ner * <span class="number">3</span> + nec;</span><br><span class="line">                <span class="comment">// creates virtual node move</span></span><br><span class="line">                swap(cur[pos], cur[ne_pos]);</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span> (d[cur] == <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    q.push(cur);</span><br><span class="line">                    d[cur] = distance + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                swap(cur[pos], cur[ne_pos]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> start;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">char</span> c; <span class="built_in">cin</span> &gt;&gt; c; start += c);</span><br><span class="line">    bfs(start);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; res &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="g_tab0-2"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></div></div></div><h3 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h3><p>仔细阅读题目可以看出这道题涉及到方格状态的演变，状态不断叠加直到产生正确的结果。这和在棋盘上从某点到某点的搜索过程类似。</p><p>在使用BFS搜索棋盘从某点到某点的路径时，点的一次移动可视为状态的一次变化。在此处BFS的思想体现在点向四个方向移动进行搜索尝试直到找到路径。</p><p>而本题可将从当前地图状态到 $x$ 与周围的某个数字发生一次位置交换后的状态视为状态的一次变化。注意这里和上述路径搜索不同的地方在于状态的变化。此处为地图的当前布局到移动数字后的一次布局，而上述路径搜索则很直观地体现在点的移动。</p><p>我们使用BFS思想不断尝试 $x$ 周围的点与 $x$ 进行交换，直到找到目标状态。</p><p>在使用BFS前，我们思考如何将棋盘的一个布局视为BFS的一个虚拟节点。以及如何存放状态变化过程中进行的次数。</p><p>我们可将矩阵按行拆分拼成一行，转化为字符串，将某个字符串视为一个节点，每一次状态变化后，将字符串放入队列。<br>我们可维护一个哈希表，key为矩阵字符串，value为状态转移过程中进行的次数。</p><p>本题有个小技巧：$m \times n$ 的矩阵中某点 $x$ 的横纵坐标 $r, c$ 可以看成将矩阵按行排成一行后，$x$ 的下标 $i$ 进行如下处理：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> r = i / m;</span><br><span class="line"><span class="keyword">int</span> c = i % m;</span><br></pre></td></tr></table></figure><p>相反：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = r * m + c;</span><br></pre></td></tr></table></figure><div class="note primary">            <p><strong>原题链接：</strong> <a href="https://www.acwing.com/problem/content/847/" target="_blank" rel="noopener">AcWing 845. 八数码</a></p>          </div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;摘要：&lt;/strong&gt;&lt;br&gt;BFS方法解决以抽象状态变化为基础的搜索问题。&lt;/p&gt;
    
    </summary>
    
    
      <category term="指尖飞舞" scheme="https://ntifs.com/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/"/>
    
      <category term="算法" scheme="https://ntifs.com/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/%E7%AE%97%E6%B3%95/"/>
    
      <category term="AcWing" scheme="https://ntifs.com/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/%E7%AE%97%E6%B3%95/AcWing/"/>
    
      <category term="算法基础课" scheme="https://ntifs.com/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/%E7%AE%97%E6%B3%95/AcWing/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BE/"/>
    
      <category term="第三讲搜索与图论" scheme="https://ntifs.com/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/%E7%AE%97%E6%B3%95/AcWing/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BE/%E7%AC%AC%E4%B8%89%E8%AE%B2%E6%90%9C%E7%B4%A2%E4%B8%8E%E5%9B%BE%E8%AE%BA/"/>
    
    
      <category term="算法" scheme="https://ntifs.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="BFS" scheme="https://ntifs.com/tags/BFS/"/>
    
      <category term="AcWing" scheme="https://ntifs.com/tags/AcWing/"/>
    
  </entry>
  
  <entry>
    <title>【AcWing算法基础】第三讲-搜索与图论-BFS AcWing 844. 走迷宫</title>
    <link href="https://ntifs.com/2023/08/24/%E3%80%90AcWing%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E3%80%91%E7%AC%AC%E4%B8%89%E8%AE%B2-%E6%90%9C%E7%B4%A2%E4%B8%8E%E5%9B%BE%E8%AE%BA-BFS-AcWing-844-%E8%B5%B0%E8%BF%B7%E5%AE%AB/"/>
    <id>https://ntifs.com/2023/08/24/%E3%80%90AcWing%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E3%80%91%E7%AC%AC%E4%B8%89%E8%AE%B2-%E6%90%9C%E7%B4%A2%E4%B8%8E%E5%9B%BE%E8%AE%BA-BFS-AcWing-844-%E8%B5%B0%E8%BF%B7%E5%AE%AB/</id>
    <published>2023-08-24T15:45:43.000Z</published>
    <updated>2023-08-27T15:47:59.230Z</updated>
    
    <content type="html"><![CDATA[<p><strong>摘要：</strong><br>BFS模板题，边权恒为1的最短路搜索。</p><a id="more"></a><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给定一个 $n \times m$ 的二维整数数组，用来表示一个迷宫，数组中只包含 $0$ 或 $1$，其中 $0$ 表示可以走的路，$1$ 表示不可通过的墙壁。</p><p>最初，有一个人位于左上角 $(1,1)$ 处，已知该人每次可以向上、下、左、右任意一个方向移动一个位置。</p><p>请问，该人从左上角移动至右下角 $(n,m)$ 处，至少需要移动多少次。</p><p>数据保证 $(1,1)$ 处和 $(n,m)$ 处的数字为 $0$，且一定至少存在一条通路。</p><p><strong>输入格式</strong><br>第一行包含两个整数 $n$ 和 $m$。</p><p>接下来 $n$ 行，每行包含 $m$ 个整数（$0$ 或 $1$），表示完整的二维数组迷宫。</p><p><strong>输出格式</strong><br>输出一个整数，表示从左上角移动至右下角的最少移动次数。</p><p><strong>数据范围</strong><br>$1≤n,m≤100$</p><p><strong>输入样例：</strong></p><blockquote><p>5 5<br>0 1 0 0 0<br>0 1 0 1 0<br>0 0 0 0 0<br>0 1 1 1 0<br>0 0 0 1 0</p></blockquote><p><strong>输出样例：</strong></p><blockquote><p>8</p></blockquote><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><div class="tabs" id="g_tab0"><ul class="nav-tabs"><li class="tab active"><a href="#g_tab0-1">C++</a></li><li class="tab"><a href="#g_tab0-2">Java</a></li></ul><div class="tab-content"><div class="tab-pane active" id="g_tab0-1"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * author: zxy</span></span><br><span class="line"><span class="comment"> * code at: 2023-8-24 23:51:52</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">vec2_t</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> r, c;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">110</span>;</span><br><span class="line"><span class="keyword">int</span> g[N][N];</span><br><span class="line"><span class="keyword">int</span> d[N][N];</span><br><span class="line"><span class="keyword">vec2_t</span> q[N * N];</span><br><span class="line"><span class="keyword">int</span> hh = <span class="number">0</span>, tt = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">int</span> dr[<span class="number">4</span>] = &#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> dc[<span class="number">4</span>] = &#123;<span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> r = <span class="number">0</span>; r &lt; n; ++ r)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> c = <span class="number">0</span>; c &lt; m; ++ c)</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; g[r][c];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">memset</span>(d, <span class="number">-1</span>, <span class="keyword">sizeof</span> d);</span><br><span class="line">    q[++tt] = &#123;<span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">    d[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (; hh &lt;= tt;)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">vec2_t</span> cur = q[hh++];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> ne_r = cur.r + dr[i];</span><br><span class="line">            <span class="keyword">int</span> ne_c = cur.c + dc[i];</span><br><span class="line">            <span class="keyword">if</span> (ne_r &gt;= <span class="number">0</span> &amp;&amp; ne_r &lt; n &amp;&amp; ne_c &gt;= <span class="number">0</span> &amp;&amp; ne_c &lt; m &amp;&amp; g[ne_r][ne_c] == <span class="number">0</span> &amp;&amp; d[ne_r][ne_c] == <span class="number">-1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                q[++tt] = &#123;ne_r, ne_c&#125;;</span><br><span class="line">                d[ne_r][ne_c] = d[cur.r][cur.c] + <span class="number">1</span>;                </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; d[n - <span class="number">1</span>][m - <span class="number">1</span>] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="g_tab0-2"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></div></div></div><h3 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h3><p>使用BFS思想遍历图中所有节点, 因为图中边权为 $1$，所以BFS可以拿到最短路径。<br>将每一个节点的下一层节点入队，并记录下一层所有可用节点的步长。<br>搜索注意判断可达点的条件，可以利用步长数组判断是否已达。</p><div class="note primary">            <p><strong>原题链接：</strong> <a href="https://www.acwing.com/problem/content/description/846/" target="_blank" rel="noopener">AcWing 844. 走迷宫</a></p>          </div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;摘要：&lt;/strong&gt;&lt;br&gt;BFS模板题，边权恒为1的最短路搜索。&lt;/p&gt;
    
    </summary>
    
    
      <category term="指尖飞舞" scheme="https://ntifs.com/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/"/>
    
      <category term="算法" scheme="https://ntifs.com/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/%E7%AE%97%E6%B3%95/"/>
    
      <category term="AcWing" scheme="https://ntifs.com/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/%E7%AE%97%E6%B3%95/AcWing/"/>
    
      <category term="算法基础课" scheme="https://ntifs.com/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/%E7%AE%97%E6%B3%95/AcWing/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BE/"/>
    
      <category term="第三讲搜索与图论" scheme="https://ntifs.com/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/%E7%AE%97%E6%B3%95/AcWing/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BE/%E7%AC%AC%E4%B8%89%E8%AE%B2%E6%90%9C%E7%B4%A2%E4%B8%8E%E5%9B%BE%E8%AE%BA/"/>
    
    
      <category term="算法" scheme="https://ntifs.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="BFS" scheme="https://ntifs.com/tags/BFS/"/>
    
      <category term="AcWing" scheme="https://ntifs.com/tags/AcWing/"/>
    
  </entry>
  
  <entry>
    <title>Hexo搜索结果不完全问题修复记录</title>
    <link href="https://ntifs.com/2023/07/16/Hexo%E6%90%9C%E7%B4%A2%E7%BB%93%E6%9E%9C%E4%B8%8D%E5%AE%8C%E5%85%A8%E9%97%AE%E9%A2%98%E4%BF%AE%E5%A4%8D%E8%AE%B0%E5%BD%95/"/>
    <id>https://ntifs.com/2023/07/16/Hexo%E6%90%9C%E7%B4%A2%E7%BB%93%E6%9E%9C%E4%B8%8D%E5%AE%8C%E5%85%A8%E9%97%AE%E9%A2%98%E4%BF%AE%E5%A4%8D%E8%AE%B0%E5%BD%95/</id>
    <published>2023-07-15T16:42:13.000Z</published>
    <updated>2023-07-15T17:19:23.554Z</updated>
    
    <content type="html"><![CDATA[<p><strong>摘要：</strong><br>修复Hexo搜索问题。</p><a id="more"></a><h3 id="问题表现"><a href="#问题表现" class="headerlink" title="问题表现"></a>问题表现</h3><p>搜索功能只能搜索到部分文章，进过尝试发现在某个时间点后的文章内容不可被搜到。</p><h3 id="问题排查"><a href="#问题排查" class="headerlink" title="问题排查"></a>问题排查</h3><p>经过网络搜索发现可以通过在线访问网站的search.xml文件判断问题。</p><ol><li>访问<a href="https://ntifs.com/search.xml">https://ntifs.com/search.xml</a></li><li>发现如下报错<br><img src="/2023/07/16/Hexo%E6%90%9C%E7%B4%A2%E7%BB%93%E6%9E%9C%E4%B8%8D%E5%AE%8C%E5%85%A8%E9%97%AE%E9%A2%98%E4%BF%AE%E5%A4%8D%E8%AE%B0%E5%BD%95/1.jpg" alt="1"></li><li>直接定位错误问题出现 <a href="https://ntifs.com/search.xml">https://ntifs.com/search.xml</a> 这个url返回内容的第2114行，定位到错误发生在文章：<code>记录一下自己把hexo博客环境从Windows迁移到Mac的过程</code> 中。</li><li>vscode打开本地文章发现如下错误字符<br><img src="/2023/07/16/Hexo%E6%90%9C%E7%B4%A2%E7%BB%93%E6%9E%9C%E4%B8%8D%E5%AE%8C%E5%85%A8%E9%97%AE%E9%A2%98%E4%BF%AE%E5%A4%8D%E8%AE%B0%E5%BD%95/2.jpg" alt="2"></li><li>删除错误字符，重新部署验证，本来在这篇文章之前都不可被搜索，之后都可以。经过验证发现全站内容均可搜到：<br><img src="/2023/07/16/Hexo%E6%90%9C%E7%B4%A2%E7%BB%93%E6%9E%9C%E4%B8%8D%E5%AE%8C%E5%85%A8%E9%97%AE%E9%A2%98%E4%BF%AE%E5%A4%8D%E8%AE%B0%E5%BD%95/3.jpg" alt="3"></li></ol><p><strong>参考文章</strong></p><blockquote><p><a href="https://www.sqlsec.com/2017/12/hexosearch.html#%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90-1" target="_blank" rel="noopener">Hexo 博客无法搜索的终极解决方法</a><br><a href="http://ponder.work/2021/10/11/hexo-local-search-not-complete-fix/" target="_blank" rel="noopener">hexo 站内搜索内容不完全问题修复</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;摘要：&lt;/strong&gt;&lt;br&gt;修复Hexo搜索问题。&lt;/p&gt;
    
    </summary>
    
    
      <category term="不亦乐乎" scheme="https://ntifs.com/categories/%E4%B8%8D%E4%BA%A6%E4%B9%90%E4%B9%8E/"/>
    
      <category term="博客" scheme="https://ntifs.com/categories/%E4%B8%8D%E4%BA%A6%E4%B9%90%E4%B9%8E/%E5%8D%9A%E5%AE%A2/"/>
    
    
      <category term="博客" scheme="https://ntifs.com/tags/%E5%8D%9A%E5%AE%A2/"/>
    
      <category term="Hexo" scheme="https://ntifs.com/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>【AcWing算法基础】第三讲-搜索与图论-DFS AcWing 843. n-皇后问题</title>
    <link href="https://ntifs.com/2023/07/15/%E3%80%90AcWing%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E3%80%91%E7%AC%AC%E4%B8%89%E8%AE%B2-%E6%90%9C%E7%B4%A2%E4%B8%8E%E5%9B%BE%E8%AE%BA-DFS-AcWing-843-n-%E7%9A%87%E5%90%8E%E9%97%AE%E9%A2%98/"/>
    <id>https://ntifs.com/2023/07/15/%E3%80%90AcWing%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E3%80%91%E7%AC%AC%E4%B8%89%E8%AE%B2-%E6%90%9C%E7%B4%A2%E4%B8%8E%E5%9B%BE%E8%AE%BA-DFS-AcWing-843-n-%E7%9A%87%E5%90%8E%E9%97%AE%E9%A2%98/</id>
    <published>2023-07-15T09:00:08.000Z</published>
    <updated>2023-08-24T15:57:53.190Z</updated>
    
    <content type="html"><![CDATA[<p><strong>摘要：</strong><br>经典的DFS问题，n-皇后。</p><a id="more"></a><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>$n$−皇后问题是指将 $n$ 个皇后放在 $n \times n$ 的国际象棋棋盘上，使得皇后不能相互攻击到，即任意两个皇后都不能处于同一行、同一列或同一斜线上。</p><p><img src="https://cdn.acwing.com/media/article/image/2019/06/08/19_860e00c489-1_597ec77c49-8-queens.png" alt="n-queen"></p><p>现在给定整数 $n$，请你输出所有的满足条件的棋子摆法。</p><p><strong>输入格式</strong><br>共一行，包含整数 $n$。</p><p><strong>输出格式</strong><br>每个解决方案占 $n$ 行，每行输出一个长度为 $n$ 的字符串，用来表示完整的棋盘状态。</p><p>其中 <code>.</code> 表示某一个位置的方格状态为空，<code>Q</code> 表示某一个位置的方格上摆着皇后。</p><p>每个方案输出完成后，输出一个空行。</p><p>注意：行末不能有多余空格。</p><p>输出方案的顺序任意，只要不重复且没有遗漏即可。</p><p><strong>数据范围</strong><br>$1≤n≤9$</p><p><strong>输入样例：</strong><br>$4$</p><p><strong>输出样例：</strong></p><blockquote><p>.Q..<br>…Q<br>Q…<br>..Q.</p><p>..Q.<br>Q…<br>…Q<br>.Q..</p></blockquote><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><div class="tabs" id="g_tab0"><ul class="nav-tabs"><li class="tab active"><a href="#g_tab0-1">C++/行递归搜索</a></li><li class="tab"><a href="#g_tab0-2">C++/按每个格子放与不放枚举搜索</a></li><li class="tab"><a href="#g_tab0-3">Java</a></li></ul><div class="tab-content"><div class="tab-pane active" id="g_tab0-1"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * author: zxy</span></span><br><span class="line"><span class="comment"> * code at: 2023-7-15 17:18:56</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">bool</span> col[N], dg[N], ndg[N];</span><br><span class="line"><span class="keyword">char</span> g[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (r == n) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// finds a valid solution if overflow</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; g[i] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> c = <span class="number">0</span>; c &lt; n; ++c)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!col[c] &amp;&amp; !dg[c + r] &amp;&amp; !ndg[c - r + n])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// valid grid to put queen</span></span><br><span class="line">            g[r][c] = <span class="string">'Q'</span>;</span><br><span class="line">            col[c] = dg[c + r] = ndg[c - r + n] = <span class="literal">true</span>;</span><br><span class="line">            <span class="comment">// step into the next row</span></span><br><span class="line">            dfs(r + <span class="number">1</span>);</span><br><span class="line">            <span class="comment">// back track to restore context</span></span><br><span class="line">            col[c] = dg[c + r] = ndg[c - r + n] = <span class="literal">false</span>;</span><br><span class="line">            g[r][c] = <span class="string">'.'</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            g[i][j] = <span class="string">'.'</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    dfs(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="g_tab0-2"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">bool</span> row[N], col[N], dg[N], ndg[N];</span><br><span class="line"><span class="keyword">char</span> g[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> r, <span class="keyword">int</span> c, <span class="keyword">int</span> s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// the colums overflows, set to the next row</span></span><br><span class="line">    <span class="keyword">if</span> (c &gt;= n)</span><br><span class="line">    &#123;</span><br><span class="line">        c = <span class="number">0</span>;</span><br><span class="line">        ++r;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (r &gt;= n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (s &gt;= n) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// consider a valid solution</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; g[i] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        &#125;    </span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="comment">// try not put queen</span></span><br><span class="line">    g[r][c] = <span class="string">'.'</span>;</span><br><span class="line">    dfs(r, c + <span class="number">1</span>, s);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// try put queen</span></span><br><span class="line">    <span class="keyword">if</span> (!row[r] &amp;&amp; !col[c] &amp;&amp; !dg[r + c] &amp;&amp; !ndg[r - c + n])</span><br><span class="line">    &#123;</span><br><span class="line">        g[r][c] = <span class="string">'Q'</span>;</span><br><span class="line">        row[r] = col[c] = dg[r + c] = ndg[r - c + n] = <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">// step into next columns</span></span><br><span class="line">        dfs(r, c + <span class="number">1</span>, s + <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// back track to restore context</span></span><br><span class="line">        g[r][c] = <span class="string">'.'</span>;</span><br><span class="line">        row[r] = col[c] = dg[r + c] = ndg[r - c + n] = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            g[i][j] = <span class="string">'.'</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    dfs(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="g_tab0-3"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></div></div></div><h3 id="按行递归搜索"><a href="#按行递归搜索" class="headerlink" title="按行递归搜索"></a>按行递归搜索</h3><p>从第一行开始向右遍历放入第一个 <code>Q</code>，记下冲突位置， 即记下竖和两个斜对角占用，横冲突不需要考虑因为我们按行搜索，每一行只会放置一个 <code>Q</code>。</p><p>此时递归进入下一行，根据冲突记录找到不冲突的点，放置 <code>Q</code>。依次往下一行递归，当递归到某一行没有能够找到位置放置 <code>Q</code>，可以认为方案不合法。此时递归函数回溯。进行上一行，对下一个可能放置 <code>Q</code> 的位置进行尝试。</p><p>当递归到行越界的时候，可以认为该路径上的所有 <code>Q</code> 合法，输出方案。</p><p>需要注意的是记录两个对角线冲突状态时，我们使用一元二次方程 $r = c + d$ 和 $r = c - d$ 中截距 $d$ 来表示一条对角线，其中：</p><p>$d = r + c$</p><p>$d = r - c$</p><p>在数组中维护 $d$ 的值时，对于第二种情况，可能下标取到负值。由于 $r - c$ 最小可以取到 $-c$ 即 $-n$ 的位置，我们将整个 $d = r - c$ 向右偏移 $n$ 位，即可解决数组下标为负数的问题。</p><h3 id="按每个格子放与不放枚举搜索"><a href="#按每个格子放与不放枚举搜索" class="headerlink" title="按每个格子放与不放枚举搜索"></a>按每个格子放与不放枚举搜索</h3><p>思想是每个格子都尝试放与不放两种选择，从最后一个格子开始，作为放置 <code>Q</code> 的起点向后递归。不满足的话回溯到倒数第二个格子放置 <code>Q</code>，依次类推。</p><p>该方法存在大量重复尝试，每一个格子作为放置 <code>Q</code> 的起点向后递归的时候，都会和其他起点的路径存在重复。</p><p>对比按行递归搜索方法，该方法复杂度更高。</p><div class="note primary">            <p><strong>原题链接：</strong> <a href="https://www.acwing.com/problem/content/description/845/" target="_blank" rel="noopener">AcWing 843. n-皇后问题</a></p>          </div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;摘要：&lt;/strong&gt;&lt;br&gt;经典的DFS问题，n-皇后。&lt;/p&gt;
    
    </summary>
    
    
      <category term="指尖飞舞" scheme="https://ntifs.com/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/"/>
    
      <category term="算法" scheme="https://ntifs.com/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/%E7%AE%97%E6%B3%95/"/>
    
      <category term="AcWing" scheme="https://ntifs.com/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/%E7%AE%97%E6%B3%95/AcWing/"/>
    
      <category term="算法基础课" scheme="https://ntifs.com/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/%E7%AE%97%E6%B3%95/AcWing/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BE/"/>
    
      <category term="第三讲搜索与图论" scheme="https://ntifs.com/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/%E7%AE%97%E6%B3%95/AcWing/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BE/%E7%AC%AC%E4%B8%89%E8%AE%B2%E6%90%9C%E7%B4%A2%E4%B8%8E%E5%9B%BE%E8%AE%BA/"/>
    
    
      <category term="算法" scheme="https://ntifs.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="DFS" scheme="https://ntifs.com/tags/DFS/"/>
    
      <category term="AcWing" scheme="https://ntifs.com/tags/AcWing/"/>
    
  </entry>
  
  <entry>
    <title>【AcWing算法基础】第三讲-搜索与图论-DFS AcWing 842. 排列数字</title>
    <link href="https://ntifs.com/2023/07/15/%E3%80%90AcWing%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E3%80%91%E7%AC%AC%E4%B8%89%E8%AE%B2-%E6%90%9C%E7%B4%A2%E4%B8%8E%E5%9B%BE%E8%AE%BA-DFS-AcWing-842-%E6%8E%92%E5%88%97%E6%95%B0%E5%AD%97/"/>
    <id>https://ntifs.com/2023/07/15/%E3%80%90AcWing%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E3%80%91%E7%AC%AC%E4%B8%89%E8%AE%B2-%E6%90%9C%E7%B4%A2%E4%B8%8E%E5%9B%BE%E8%AE%BA-DFS-AcWing-842-%E6%8E%92%E5%88%97%E6%95%B0%E5%AD%97/</id>
    <published>2023-07-15T06:46:52.000Z</published>
    <updated>2023-07-15T10:00:44.356Z</updated>
    
    <content type="html"><![CDATA[<p><strong>摘要：</strong><br>DFS入门题。</p><a id="more"></a><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给定一个整数 $n$，将数字 $1∼n$ 排成一排，将会有很多种排列方法。</p><p>现在，请你按照字典序将所有的排列方法输出。</p><p><strong>输入格式</strong><br>共一行，包含一个整数 $n$。</p><p><strong>输出格式</strong><br>按字典序输出所有排列方案，每个方案占一行。</p><p><strong>数据范围</strong><br>$1≤n≤7$</p><p><strong>输入样例：</strong></p><blockquote><p>3</p></blockquote><p><strong>输出样例：</strong></p><blockquote><p>1 2 3<br>1 3 2<br>2 1 3<br>2 3 1<br>3 1 2<br>3 2 1</p></blockquote><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><div class="tabs" id="g_tab0"><ul class="nav-tabs"><li class="tab active"><a href="#g_tab0-1">C++</a></li><li class="tab"><a href="#g_tab0-2">Java</a></li></ul><div class="tab-content"><div class="tab-pane active" id="g_tab0-1"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> path[N];</span><br><span class="line"><span class="keyword">bool</span> st[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (u == n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// overflow</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) <span class="built_in">cout</span> &lt;&lt; path[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!st[i])</span><br><span class="line">        &#123;</span><br><span class="line">            path[u] = i;</span><br><span class="line">            st[i] = <span class="literal">true</span>;</span><br><span class="line">            dfs(u + <span class="number">1</span>);</span><br><span class="line">            st[i] = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    dfs(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="g_tab0-2"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></div></div></div><h3 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h3><p>本题核心思想是使用递归全量枚举暴搜。 </p><p>按照深度优先进行下一位数字的搜索操作。每搜索到一个节点，使用path数组记录节点值。当路径中记录的数字数量到达预计值的时候，输出路径并递归返回。</p><p>为了每个节点可以使用新的数字而不至于重复，将当前路径已经使用过的数字使用额外数组记下，在下一层调用的时候跳过已使用的数字。</p><p>需要注意的是，在递归回来的时候，需要将已被标记的当前入口节点使用状态重置。因为标记的目的是为了下一层跳过，那么从下一层递归回来当然需要还原。</p><p>另外，之所以回溯的时候，path不需要恢复现场，是因为后续的写入会直接将对应位置的值覆盖掉。</p><div class="note primary">            <p><strong>原题链接：</strong> <a href="https://www.acwing.com/problem/content/844/" target="_blank" rel="noopener">AcWing 842. 排列数字</a></p>          </div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;摘要：&lt;/strong&gt;&lt;br&gt;DFS入门题。&lt;/p&gt;
    
    </summary>
    
    
      <category term="指尖飞舞" scheme="https://ntifs.com/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/"/>
    
      <category term="算法" scheme="https://ntifs.com/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/%E7%AE%97%E6%B3%95/"/>
    
      <category term="AcWing" scheme="https://ntifs.com/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/%E7%AE%97%E6%B3%95/AcWing/"/>
    
      <category term="算法基础课" scheme="https://ntifs.com/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/%E7%AE%97%E6%B3%95/AcWing/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BE/"/>
    
      <category term="第三讲搜索与图论" scheme="https://ntifs.com/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/%E7%AE%97%E6%B3%95/AcWing/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BE/%E7%AC%AC%E4%B8%89%E8%AE%B2%E6%90%9C%E7%B4%A2%E4%B8%8E%E5%9B%BE%E8%AE%BA/"/>
    
    
      <category term="算法" scheme="https://ntifs.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="DFS" scheme="https://ntifs.com/tags/DFS/"/>
    
      <category term="AcWing" scheme="https://ntifs.com/tags/AcWing/"/>
    
  </entry>
  
  <entry>
    <title>【AcWing算法基础】第二讲-数据结构-哈希表 AcWing 841. 字符串哈希</title>
    <link href="https://ntifs.com/2023/07/10/%E3%80%90AcWing%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E3%80%91%E7%AC%AC%E4%BA%8C%E8%AE%B2-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%93%88%E5%B8%8C%E8%A1%A8-AcWing-841-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%93%88%E5%B8%8C/"/>
    <id>https://ntifs.com/2023/07/10/%E3%80%90AcWing%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E3%80%91%E7%AC%AC%E4%BA%8C%E8%AE%B2-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%93%88%E5%B8%8C%E8%A1%A8-AcWing-841-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%93%88%E5%B8%8C/</id>
    <published>2023-07-10T14:54:09.000Z</published>
    <updated>2023-07-12T13:41:59.337Z</updated>
    
    <content type="html"><![CDATA[<p><strong>摘要：</strong><br>字符串前缀哈希法。</p><a id="more"></a><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给定一个长度为 $n$ 的字符串，再给定 $m$ 个询问，每个询问包含四个整数 $l1,r1,l2,r2$，请你判断 $[l1,r1]$ 和 $[l2,r2]$ 这两个区间所包含的字符串子串是否完全相同。<br>字符串中只包含大小写英文字母和数字。</p><p><strong>输入格式</strong><br>第一行包含整数 $n$ 和 $m$，表示字符串长度和询问次数。</p><p>第二行包含一个长度为 $n$ 的字符串，字符串中只包含大小写英文字母和数字。</p><p>接下来 $m$ 行，每行包含四个整数 $l1,r1,l2,r2$，表示一次询问所涉及的两个区间。</p><p>注意，字符串的位置从 $1$ 开始编号。</p><p><strong>输出格式</strong><br>对于每个询问输出一个结果，如果两个字符串子串完全相同则输出 $Yes$，否则输出 $No$。</p><p>每个结果占一行。</p><p><strong>数据范围</strong><br>$1≤n,m≤10^5$</p><p><strong>输入样例：</strong></p><blockquote><p>8 3<br>aabbaabb<br>1 3 5 7<br>1 3 6 8<br>1 2 1 2</p></blockquote><p><strong>输出样例：</strong></p><blockquote><p>Yes<br>No<br>Yes</p></blockquote><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><div class="tabs" id="g_tab0"><ul class="nav-tabs"><li class="tab active"><a href="#g_tab0-1">C++</a></li><li class="tab"><a href="#g_tab0-2">Java</a></li></ul><div class="tab-content"><div class="tab-pane active" id="g_tab0-1"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">using</span> ull = <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="built_in">string</span> s;</span><br><span class="line"></span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> P_VAL = <span class="number">131</span>;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line">ull h[N], p[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">create_string_hash</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">    p[<span class="number">0</span>] = <span class="number">1</span>; h[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">    &#123;</span><br><span class="line">        p[i] = p[i - <span class="number">1</span>] * P_VAL;</span><br><span class="line">        h[i] = h[i - <span class="number">1</span>] * P_VAL + s[i - <span class="number">1</span>]; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// the unsigned long long value overflow will equivalent to the value mod max value of unsigned long long </span></span><br><span class="line"><span class="function">ull <span class="title">get_hash_val</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">false</span>) </span><br><span class="line">    &#123;</span><br><span class="line">        l = l ^ r;</span><br><span class="line">        r = l ^ r;</span><br><span class="line">        l = l ^ r;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> h[r] - h[l - <span class="number">1</span>] * p[r - l + <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; s;</span><br><span class="line">    create_string_hash();</span><br><span class="line">    <span class="keyword">for</span> (; m--;)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> l1, r1, l2, r2;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; l1 &gt;&gt; r1 &gt;&gt; l2 &gt;&gt; r2;</span><br><span class="line">        ull hash_val_1 = get_hash_val(l1, r1);</span><br><span class="line">        ull hash_val_2 = get_hash_val(l2, r2);</span><br><span class="line">        <span class="comment">//cout &lt;&lt; hash_val_1 &lt;&lt; " " &lt;&lt; hash_val_2 &lt;&lt; endl;</span></span><br><span class="line">        <span class="keyword">if</span> (hash_val_1 == hash_val_2) <span class="built_in">cout</span> &lt;&lt; <span class="string">"Yes"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; <span class="string">"No"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="g_tab0-2"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></div></div></div><h3 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h3><p>字符串前缀哈希法，本质就是不把字符串当字符串看待，而是把字符串看成一个 $P$ 进制的数。</p><p>假设有字符串 <code>12345678</code>， 我们把它看做一个 $P = 10$ 进制的数。</p><p>现在我们规定一个示例哈希算法为：每个字符的哈希值为当前字符减 <code>1</code> 这个字符得到的结果。</p><p>那么在整个字符串中，位于 $1$ 到 $8$ 区间内的字符串哈希值 $Hash(1, 8) = 12345678$.</p><p>下面我们研究子串的哈希关系。</p><p>位于 $1$ 到 $6$ 区间内的字符串哈希值 $Hash(1, 6) = 123456$.</p><p>显然位于 $7$ 到 $8$ 区间内的字符串哈希值:<br>$$Hash(7, 8) = 78 = 12345678 - 12345600 = 12345678 - 123456 \times 10^2$$<br>$$=$$<br>$$Hash(1, 8) - Hash(1, 6) \times 10^{8 - 7 + 1}$$</p><p>有结论：<br>对于一个 $P$ 进制字符串，它的 $l$ 到 $r$ 下标之间的子串哈希值满足如下公式：<br>$$Hash(l, r) = Hash(1, r) - Hash(1, l - 1) \times P^{r - l + 1}$$</p><p>在本题中，预处理前缀哈希数组 $h$，$h[i]$ 表示位于 $1$ 到 $i$ 之间的字符串哈希值。<br>根据上述结论有：</p><p>$$Hash(i, i) = Hash(1, i) - Hash(1, i - 1) \times P^{1}$$</p><p>其中 $Hash(i, i)$ 为第 $i$ 个字符的哈希值。<br>即 $h[i] = Hash(i, i) + h[i - 1] \times P$.</p><p><strong>小技巧</strong></p><blockquote><ol><li><p>根据经验，本题 $P$ 值 可以取值 $131$ 或 $13331$。</p></li><li><p>如果字符串超长，那么哈希得到的值会溢出，需要取模，我们使用 <code>unsigned long long</code> 溢出特性来自动对该类型最大值取模。</p></li></ol></blockquote><div class="note primary">            <p><strong>原题链接：</strong> <a href="https://www.acwing.com/problem/content/843/" target="_blank" rel="noopener">AcWing 841. 字符串哈希</a></p>          </div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;摘要：&lt;/strong&gt;&lt;br&gt;字符串前缀哈希法。&lt;/p&gt;
    
    </summary>
    
    
      <category term="指尖飞舞" scheme="https://ntifs.com/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/"/>
    
      <category term="算法" scheme="https://ntifs.com/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/%E7%AE%97%E6%B3%95/"/>
    
      <category term="AcWing" scheme="https://ntifs.com/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/%E7%AE%97%E6%B3%95/AcWing/"/>
    
      <category term="算法基础课" scheme="https://ntifs.com/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/%E7%AE%97%E6%B3%95/AcWing/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BE/"/>
    
      <category term="第二讲数据结构" scheme="https://ntifs.com/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/%E7%AE%97%E6%B3%95/AcWing/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BE/%E7%AC%AC%E4%BA%8C%E8%AE%B2%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="算法" scheme="https://ntifs.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="AcWing" scheme="https://ntifs.com/tags/AcWing/"/>
    
      <category term="字符串哈希" scheme="https://ntifs.com/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%93%88%E5%B8%8C/"/>
    
  </entry>
  
  <entry>
    <title>【AcWing算法基础】第二讲-数据结构-哈希表 AcWing 840. 模拟散列表</title>
    <link href="https://ntifs.com/2023/07/09/%E3%80%90AcWing%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E3%80%91%E7%AC%AC%E4%BA%8C%E8%AE%B2-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%93%88%E5%B8%8C%E8%A1%A8-AcWing-840-%E6%A8%A1%E6%8B%9F%E6%95%A3%E5%88%97%E8%A1%A8/"/>
    <id>https://ntifs.com/2023/07/09/%E3%80%90AcWing%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E3%80%91%E7%AC%AC%E4%BA%8C%E8%AE%B2-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%93%88%E5%B8%8C%E8%A1%A8-AcWing-840-%E6%A8%A1%E6%8B%9F%E6%95%A3%E5%88%97%E8%A1%A8/</id>
    <published>2023-07-08T16:27:30.000Z</published>
    <updated>2023-07-09T05:58:19.359Z</updated>
    
    <content type="html"><![CDATA[<p><strong>摘要：</strong><br>数组模拟哈希集合（哈希表），使用拉链法和开放寻址法处理冲突。</p><a id="more"></a><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>维护一个集合，支持如下几种操作：</p><ul><li>$I \quad x$，插入一个数 $x$；</li><li>$Q \quad x$，询问数 $x$ 是否在集合中出现过；</li></ul><p>现在要进行 $N$ 次操作，对于每个询问操作输出对应的结果。</p><p><strong>输入格式</strong><br>第一行包含整数 $N$，表示操作数量。<br>接下来 $N$ 行，每行包含一个操作指令，操作指令为 $I \quad $，$Q \quad x$ 中的一种。</p><p><strong>输出格式</strong><br>对于每个询问指令 $Q \quad x$，输出一个询问结果，如果 $x$ 在集合中出现过，则输出 $Yes$，否则输出 $No$。</p><p>每个结果占一行。</p><p><strong>数据范围</strong></p><ul><li>$1≤N≤10^5$</li><li>$−10^9≤x≤10^9$</li></ul><p><strong>输入样例：</strong></p><blockquote><p>5<br>I 1<br>I 2<br>I 3<br>Q 2<br>Q 5</p></blockquote><p><strong>输出样例：</strong></p><blockquote><p>Yes<br>No</p></blockquote><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><div class="tabs" id="g_tab0"><ul class="nav-tabs"><li class="tab active"><a href="#g_tab0-1">C++/拉链法</a></li><li class="tab"><a href="#g_tab0-2">C++/开放寻址法</a></li><li class="tab"><a href="#g_tab0-3">Java</a></li></ul><div class="tab-content"><div class="tab-pane active" id="g_tab0-1"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * author: zxy</span></span><br><span class="line"><span class="comment"> * code at: 2023-7-9 00:38:17</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __nullptr__ -1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> N = <span class="number">100003</span>;</span><br><span class="line"><span class="keyword">int</span> h[N], e[N], ne[N], idx;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">create_hash</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (x % N + N) % N;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> hash_val = create_hash(x);</span><br><span class="line">    <span class="comment">// inserts to linked list head</span></span><br><span class="line">    <span class="keyword">int</span> head = h[hash_val];</span><br><span class="line">    e[idx] = x;</span><br><span class="line">    ne[idx] = head;</span><br><span class="line">    <span class="comment">// updates head</span></span><br><span class="line">    h[hash_val] = idx;</span><br><span class="line">    ++idx;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">exist</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> hash_val = create_hash(x);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> ptr = h[hash_val]; ptr != __nullptr__; ptr = ne[ptr])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// exist entry in linked list</span></span><br><span class="line">        <span class="keyword">if</span> (e[ptr] == x) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// no entry in linked list or no value equals to x although x has the same hash val with each entry in linked list</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> ops;</span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="comment">// inits nullptr, using -1 as nullptr</span></span><br><span class="line">    <span class="built_in">memset</span>(h, __nullptr__, <span class="keyword">sizeof</span>(h));</span><br><span class="line">    <span class="built_in">memset</span>(ne, __nullptr__, <span class="keyword">sizeof</span>(ne));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (; n--;) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; ops &gt;&gt; x;</span><br><span class="line">        <span class="keyword">if</span> (ops == <span class="string">"I"</span>) </span><br><span class="line">        &#123;</span><br><span class="line">            insert(x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (ops == <span class="string">"Q"</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> res = exist(x);</span><br><span class="line">            <span class="keyword">if</span> (res) <span class="built_in">cout</span> &lt;&lt; <span class="string">"Yes"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; <span class="string">"No"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"UNSUPPORTED OPERATION"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="g_tab0-2"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * author: zxy</span></span><br><span class="line"><span class="comment"> * code at: 2023-7-9 00:22:20</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __unreachable__ 0x3f3f3f3f</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> N = <span class="number">200003</span>;</span><br><span class="line"><span class="keyword">int</span> h[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">create_hash</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (x % N + N) % N;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// returns the hash index of given value if value not in set</span></span><br><span class="line"><span class="comment">// or occupied location if in set</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> hash_val = create_hash(x);</span><br><span class="line">    <span class="keyword">for</span> (; h[hash_val] != __unreachable__ &amp;&amp; h[hash_val] != x ; ++hash_val)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (hash_val == N) hash_val = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> hash_val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> ops;</span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// inits h with each val equals to unreachable value</span></span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">0x3f</span>, <span class="keyword">sizeof</span>(h));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (; n--;)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; ops &gt;&gt; x;</span><br><span class="line">        <span class="keyword">int</span> hash_val = <span class="built_in">find</span>(x);</span><br><span class="line">        <span class="keyword">if</span> (ops == <span class="string">"I"</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            h[hash_val] = x;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (ops == <span class="string">"Q"</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (h[hash_val] == __unreachable__) <span class="built_in">cout</span> &lt;&lt; <span class="string">"No"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; <span class="string">"Yes"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"UNSUPPORTED OPERATION"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="g_tab0-3"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></div></div></div><h3 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h3><p>使用数组模拟集合，因为数字大小区间在 $−10^9≤x≤10^9$ 内，范围较大，需要对数字进行哈希处理，缩小到一个较小范围内。</p><p>哈希函数我们使用取模方式，对于负数，我们需要做如下处理：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> hash_val = (x % MOD + MOD) % MOD;</span><br></pre></td></tr></table></figure><p>不同的数哈希之后得到的值可能存在相同的情况，我们需要处理哈希冲突。有如下两种常见方式。</p><h4 id="拉链法"><a href="#拉链法" class="headerlink" title="拉链法"></a>拉链法</h4><p>使用一个单链表维护所有哈希值相同的数。模拟集合的数组长度选择比操作次数最大值大的最小质数，同时可以作为拉链法的哈希函数 $MOD$ 值。</p><p>集合数组值初始化为 $-1$，可以看成是空指针，集合数组存的值为单链表的头节点，对应单链表值数组 $e$ 的数组下标，单链表插入使用头插法。</p><p>单链表数据结构可以参考：<a href="https://ntifs.com/2020/11/12/【AcWing算法基础】第二讲-数据结构-单链表-AcWing-826-单链表/">AcWing 826. 单链表</a></p><p>判断存在性时，判断哈希值对应的数组存放链表头节点是否为空，或者非空情况遍历单链表逐个比较数值是否相等。</p><h4 id="开放寻址法"><a href="#开放寻址法" class="headerlink" title="开放寻址法"></a>开放寻址法</h4><p>如果哈希值对应数组被占用，则往后遍历找到新的地址，不断轮询尝试直到找到位置。</p><p>模拟集合的数组长度根据经验选择比操作次数最大值大2倍大的最小质数，同时可以作为开放寻址法的哈希函数 $MOD$ 值。</p><p>模拟集合数组存放数值，初始化为数值范围以外的 <code>0x3f3f3f3f</code>。</p><p>实现一个 $find$ 函数，判断 $hash$ 值对应的数是否存在，如果不存在说明该位置可以作为数的存放位置；如果存在则要判断是否被别的数值占用，如果被别的数值占用则向后遍历集合数组，直到找到一个满足条件的位置。</p><p>需要注意的是，我们初始化数值大小为操作数量最大值的 $2$ 倍还多，最坏的情况是每一个操作都不相同，这样我们依然有一倍的冗余，所以必然存在一个位置可以放数值。</p><div class="note primary">            <p><strong>原题链接：</strong> <a href="https://www.acwing.com/problem/content/description/842/" target="_blank" rel="noopener">AcWing 840. 模拟散列表</a></p>          </div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;摘要：&lt;/strong&gt;&lt;br&gt;数组模拟哈希集合（哈希表），使用拉链法和开放寻址法处理冲突。&lt;/p&gt;
    
    </summary>
    
    
      <category term="指尖飞舞" scheme="https://ntifs.com/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/"/>
    
      <category term="算法" scheme="https://ntifs.com/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/%E7%AE%97%E6%B3%95/"/>
    
      <category term="AcWing" scheme="https://ntifs.com/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/%E7%AE%97%E6%B3%95/AcWing/"/>
    
      <category term="算法基础课" scheme="https://ntifs.com/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/%E7%AE%97%E6%B3%95/AcWing/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BE/"/>
    
      <category term="第二讲数据结构" scheme="https://ntifs.com/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/%E7%AE%97%E6%B3%95/AcWing/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BE/%E7%AC%AC%E4%BA%8C%E8%AE%B2%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="算法" scheme="https://ntifs.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="哈希表" scheme="https://ntifs.com/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    
      <category term="AcWing" scheme="https://ntifs.com/tags/AcWing/"/>
    
  </entry>
  
  <entry>
    <title>【AcWing算法基础】第二讲-数据结构-堆 AcWing 839. 模拟堆</title>
    <link href="https://ntifs.com/2023/07/08/%E3%80%90AcWing%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E3%80%91%E7%AC%AC%E4%BA%8C%E8%AE%B2-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%A0%86-AcWing-839-%E6%A8%A1%E6%8B%9F%E5%A0%86/"/>
    <id>https://ntifs.com/2023/07/08/%E3%80%90AcWing%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E3%80%91%E7%AC%AC%E4%BA%8C%E8%AE%B2-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%A0%86-AcWing-839-%E6%A8%A1%E6%8B%9F%E5%A0%86/</id>
    <published>2023-07-07T16:51:33.000Z</published>
    <updated>2023-07-07T17:37:08.784Z</updated>
    
    <content type="html"><![CDATA[<p><strong>摘要：</strong><br>数组模拟堆。</p><a id="more"></a><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>维护一个集合，初始时集合为空，支持如下几种操作：</p><ul><li>$I \quad x$，插入一个数 $x$；</li><li>$PM$，输出当前集合中的最小值；</li><li>$DM$，删除当前集合中的最小值（数据保证此时的最小值唯一）；</li><li>$D \quad k$，删除第 $k$ 个插入的数；</li><li>$C \quad k \quad x$，修改第 $k$ 个插入的数，将其变为 $x$；<br>现在要进行 $N$ 次操作，对于所有第 $2$ 个操作，输出当前集合的最小值。</li></ul><p><strong>输入格式</strong><br>第一行包含整数 $N$。</p><p>接下来 $N$ 行，每行包含一个操作指令，操作指令为 $I \quad x$, $PM$, $DM$, $Dk$ 或 $C \quad k \quad x$ 中的一种。</p><p><strong>输入格式</strong><br>对于每个输出指令 $PM$，输出一个结果，表示当前集合中的最小值。</p><p>每个结果占一行。</p><p><strong>数据范围</strong></p><ul><li>$1≤N≤10^5$</li><li>$−10^9≤x≤10^9$</li></ul><p>数据保证合法。</p><p><strong>输入样例：</strong></p><blockquote><p>8<br>I -10<br>PM<br>I -10<br>D 1<br>C 2 8<br>I 6<br>PM<br>DM</p></blockquote><p><strong>输出样例：</strong></p><blockquote><p>-10<br>6</p></blockquote><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><div class="tabs" id="g_tab0"><ul class="nav-tabs"><li class="tab active"><a href="#g_tab0-1">C++</a></li><li class="tab"><a href="#g_tab0-2">Java</a></li></ul><div class="tab-content"><div class="tab-pane active" id="g_tab0-1"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * author: zxy</span></span><br><span class="line"><span class="comment"> * code at: 2023-7-8 01:37:00</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1000010</span>;</span><br><span class="line"><span class="keyword">int</span> h[N], ph[N], hp[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, idx;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">heap_swap</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> k1 = hp[u];</span><br><span class="line">    <span class="keyword">int</span> k2 = hp[i];</span><br><span class="line">    ph[k1] = i;</span><br><span class="line">    ph[k2] = u;</span><br><span class="line">    hp[u] = k2;</span><br><span class="line">    hp[i] = k1;</span><br><span class="line">    swap(h[u], h[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">heap_swap_1</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    swap(ph[hp[a]],ph[hp[b]]);</span><br><span class="line">    swap(hp[a], hp[b]);</span><br><span class="line">    swap(h[a], h[b]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">down</span><span class="params">(<span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> u = i;</span><br><span class="line">    <span class="keyword">if</span> (i * <span class="number">2</span> &lt;= idx &amp;&amp; h[i * <span class="number">2</span>] &lt; h[i]) u = i * <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (i * <span class="number">2</span> + <span class="number">1</span> &lt;= idx &amp;&amp; h[i * <span class="number">2</span> + <span class="number">1</span>] &lt; h[u]) u = i * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (u != i)</span><br><span class="line">    &#123;</span><br><span class="line">        heap_swap(u, i);</span><br><span class="line">        down(u);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">up</span><span class="params">(<span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (; i &gt;&gt; <span class="number">1</span> &amp;&amp; h[i &gt;&gt; <span class="number">1</span>] &gt; h[i];) </span><br><span class="line">    &#123;</span><br><span class="line">        heap_swap(i, i &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        i &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (; n--;)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">string</span> ops;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; ops;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> k, x;</span><br><span class="line">        <span class="keyword">if</span> (ops == <span class="string">"I"</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">static</span> <span class="keyword">int</span> insert_cnt = <span class="number">0</span>;</span><br><span class="line">            ++insert_cnt;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line">            h[++idx] = x;</span><br><span class="line">            ph[insert_cnt] = idx;</span><br><span class="line">            hp[idx] = insert_cnt;</span><br><span class="line">            up(idx);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (ops == <span class="string">"PM"</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; h[<span class="number">1</span>] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (ops == <span class="string">"DM"</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            heap_swap(<span class="number">1</span>, idx);</span><br><span class="line">            --idx;</span><br><span class="line">            down(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (ops == <span class="string">"D"</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; k;</span><br><span class="line">            <span class="keyword">int</span> k_idx = ph[k];</span><br><span class="line">            heap_swap(k_idx, idx);</span><br><span class="line">            --idx;</span><br><span class="line">            up(k_idx);</span><br><span class="line">            down(k_idx);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (ops == <span class="string">"C"</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; k &gt;&gt; x;</span><br><span class="line">            <span class="keyword">int</span> k_idx = ph[k];</span><br><span class="line">            h[k_idx] = x;</span><br><span class="line">            up(k_idx);</span><br><span class="line">            down(k_idx);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="g_tab0-2"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></div></div></div><h3 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h3><p>数组模拟堆，建堆逻辑见这篇文章：<a href="https://ntifs.com/2023/06/25/【AcWing算法基础】第二讲-数据结构-堆-AcWing-838-堆排序/">AcWing 838. 堆排序</a></p><p>相比较，本题额外需要支持删除和修改第k个插入的数。那么我们需要维护一个数据结构可以对应找到第 $k$ 个插入的数在堆数组中的位置。</p><p>我们用 $ph$ 数组维护该映射关系，<code>int u = ph[k]</code> 表示第 $k$ 个插入的数在堆数组 $h$ 中的下标为 $u$。</p><p>仔细思考不难发现，当我们交换堆数组中两个元素数值的位置时，如果用传统的 $swap$ 方法交换数组数值位置，会打乱第 $k$ 个插入数在下标K和堆数组数值下标的映射关系。所以交换时我们也必须要同时交换这个映射关系。</p><p>继续思考容易想到，在我们交换两个数插入次序和值下标映射关系时，需要知道两个值下标对应的 $k$ 是多少，因为我们交换函数的入参只有两个值在堆数组中的下标。那么我们需要维护一个数据结构可以根据堆数组数值下标找到其插入次序。</p><p>我们用 $hp$ 数组维护该映射关系，<code>int k = hp[u]</code> 表示堆数组下标为 $u$ 的数是第 $k$ 次插入的。</p><p>重构交换函数，逻辑是：</p><ol><li>先根据两个值在堆数组中的下标找到两个数分别是第几次插入的（用到未交换次序的 $hp$ 数组），再根据两者的插入次序交换其对应在堆数组中的下标，完成第一次 $ph$ 映射交换；</li><li>接着根据两个值在数组中的下标交换其对应的插入次序，完成第二次 $hp$ 映射交换；</li><li>进行堆数组数值交换。</li></ol><div class="note primary">            <p><strong>原题链接：</strong> <a href="https://www.acwing.com/problem/content/841/" target="_blank" rel="noopener">AcWing 839. 模拟堆</a></p>          </div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;摘要：&lt;/strong&gt;&lt;br&gt;数组模拟堆。&lt;/p&gt;
    
    </summary>
    
    
      <category term="指尖飞舞" scheme="https://ntifs.com/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/"/>
    
      <category term="算法" scheme="https://ntifs.com/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/%E7%AE%97%E6%B3%95/"/>
    
      <category term="AcWing" scheme="https://ntifs.com/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/%E7%AE%97%E6%B3%95/AcWing/"/>
    
      <category term="算法基础课" scheme="https://ntifs.com/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/%E7%AE%97%E6%B3%95/AcWing/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BE/"/>
    
      <category term="第二讲数据结构" scheme="https://ntifs.com/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/%E7%AE%97%E6%B3%95/AcWing/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BE/%E7%AC%AC%E4%BA%8C%E8%AE%B2%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="算法" scheme="https://ntifs.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="AcWing" scheme="https://ntifs.com/tags/AcWing/"/>
    
      <category term="堆" scheme="https://ntifs.com/tags/%E5%A0%86/"/>
    
  </entry>
  
  <entry>
    <title>【AcWing算法基础】第二讲-数据结构-堆 AcWing 838. 堆排序</title>
    <link href="https://ntifs.com/2023/06/25/%E3%80%90AcWing%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E3%80%91%E7%AC%AC%E4%BA%8C%E8%AE%B2-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%A0%86-AcWing-838-%E5%A0%86%E6%8E%92%E5%BA%8F/"/>
    <id>https://ntifs.com/2023/06/25/%E3%80%90AcWing%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E3%80%91%E7%AC%AC%E4%BA%8C%E8%AE%B2-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%A0%86-AcWing-838-%E5%A0%86%E6%8E%92%E5%BA%8F/</id>
    <published>2023-06-25T15:44:13.000Z</published>
    <updated>2023-07-07T16:58:47.486Z</updated>
    
    <content type="html"><![CDATA[<p><strong>摘要：</strong><br>堆排序模板题。</p><a id="more"></a><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>输入一个长度为 $n$ 的整数数列，从小到大输出前 $m$ 小的数。</p><p><strong>输入格式</strong><br>第一行包含整数 $n$ 和 $m$。</p><p>第二行包含 $n$ 个整数，表示整数数列。</p><p><strong>输出格式</strong><br>共一行，包含 $m$ 个整数，表示整数数列中前 $m$ 小的数。</p><p><strong>数据范围</strong></p><ul><li>$1≤m≤n≤10^5$</li><li>$1≤数列中元素≤10^9$</li></ul><p><strong>输入样例：</strong></p><blockquote><p>5 3<br>4 5 1 3 2</p></blockquote><p><strong>输出样例：</strong></p><blockquote><p>1 2 3</p></blockquote><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><div class="tabs" id="g_tab0"><ul class="nav-tabs"><li class="tab active"><a href="#g_tab0-1">C++</a></li><li class="tab"><a href="#g_tab0-2">Java</a></li></ul><div class="tab-content"><div class="tab-pane active" id="g_tab0-1"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, cnt;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e6</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> a[N];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">down</span><span class="params">(<span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> u = i;</span><br><span class="line">    <span class="keyword">if</span> (i * <span class="number">2</span> &lt;= cnt &amp;&amp; a[i * <span class="number">2</span>] &lt; a[u]) u = i * <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (i * <span class="number">2</span> + <span class="number">1</span> &lt;= cnt &amp;&amp; a[i * <span class="number">2</span> + <span class="number">1</span>] &lt; a[u]) u = i * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (u != i)</span><br><span class="line">    &#123;</span><br><span class="line">        swap(a[i], a[u]);</span><br><span class="line">        down(u);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span>  &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">    </span><br><span class="line">    cnt = n;</span><br><span class="line">    <span class="comment">// build tree</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = cnt / <span class="number">2</span>; i &gt; <span class="number">0</span>; -- i) </span><br><span class="line">    &#123;</span><br><span class="line">        down(i);    </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (; m--;)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> x = a[<span class="number">1</span>];</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">        <span class="keyword">int</span> leaf = a[cnt--];</span><br><span class="line">        a[<span class="number">1</span>] = leaf;</span><br><span class="line">        down(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="g_tab0-2"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></div></div></div><h3 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h3><p>建堆数据结构：使用数组维护一颗二叉树，从下标 $1$ 开始，$a[i]$ 表示第 $i$ 个节点，$a[i \times 2]$ 表示其左孩子，$a[i \times 2 + 1]$ 表示其右孩子。这样，$a[N]$ 的数组恰好可以表示一颗节点数为N的二叉树。</p><p>建堆过程：初始化输入的数组表示无序堆，从第一个存在孩子的节点 $a[k]$ 开始进行节点下沉操作，其中，$k = N \div 2$. 在数组中，$k$ 右边的数不可能有孩子节点，因为超出数组边界。对 $a[k]$ 节点下沉后，依次在数组中向左遍历，进行节点下沉。</p><p>节点下沉：把 $a[k]$ 节点和其左右孩子节点比较值大小，如果 $a[k]$ 比任意一个节点小，则进行数组元素交换，在树中表现为节点和比自己小的某一个孩子节点交换位置。反之，$a[k]$ 比所有孩子节点都大，则当前堆的子结构有序，节点位置不变。最终 $a[k]$ 会找到一个树中合适的位置，该位置满足节点值比两个孩子节点的值都小，且两个孩子节点和各自的孩子节点相比依然小。</p><p>删除节点：大根堆的堆顶最小，得到最小值后，需要删除根节点。删除的方式可以复用建堆时用到的节点下沉模式，即，将某一个子节点赋值给根节点，根节点执行节点下沉。这样根节点被覆盖，再下沉到合适的位置，就完成了删除操作。注意，选取某个子节点给根节点赋值的时候，可以选数组最后一个元素，再将最后一个元素弹出序列，已达到节点替换的效果。</p><p>值得注意的点：在节点下沉过程中，需要在三个节点中两两比较，我们使用两次比较完成。第一次得到两个节点的最小值，在将最小值和第三个节点比较。</p><div class="note primary">            <p><strong>原题链接：</strong> <a href="https://www.acwing.com/problem/content/840/" target="_blank" rel="noopener">AcWing 838. 堆排序</a></p>          </div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;摘要：&lt;/strong&gt;&lt;br&gt;堆排序模板题。&lt;/p&gt;
    
    </summary>
    
    
      <category term="指尖飞舞" scheme="https://ntifs.com/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/"/>
    
      <category term="算法" scheme="https://ntifs.com/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/%E7%AE%97%E6%B3%95/"/>
    
      <category term="AcWing" scheme="https://ntifs.com/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/%E7%AE%97%E6%B3%95/AcWing/"/>
    
      <category term="算法基础课" scheme="https://ntifs.com/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/%E7%AE%97%E6%B3%95/AcWing/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BE/"/>
    
      <category term="第二讲数据结构" scheme="https://ntifs.com/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/%E7%AE%97%E6%B3%95/AcWing/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BE/%E7%AC%AC%E4%BA%8C%E8%AE%B2%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="算法" scheme="https://ntifs.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="TopK" scheme="https://ntifs.com/tags/TopK/"/>
    
      <category term="AcWing" scheme="https://ntifs.com/tags/AcWing/"/>
    
      <category term="堆" scheme="https://ntifs.com/tags/%E5%A0%86/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 196. 删除重复的电子邮箱</title>
    <link href="https://ntifs.com/2022/09/18/LeetCode-196-%E5%88%A0%E9%99%A4%E9%87%8D%E5%A4%8D%E7%9A%84%E7%94%B5%E5%AD%90%E9%82%AE%E7%AE%B1/"/>
    <id>https://ntifs.com/2022/09/18/LeetCode-196-%E5%88%A0%E9%99%A4%E9%87%8D%E5%A4%8D%E7%9A%84%E7%94%B5%E5%AD%90%E9%82%AE%E7%AE%B1/</id>
    <published>2022-09-18T07:49:57.000Z</published>
    <updated>2023-07-04T14:06:51.134Z</updated>
    
    <content type="html"><![CDATA[<p><strong>摘要：</strong><br>考察字段值不唯一情况下的自连接（全排列映射）。</p><a id="more"></a><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p><a href="https://leetcode.cn/problems/delete-duplicate-emails/" target="_blank" rel="noopener">LeetCode 196. 删除重复的电子邮箱</a></p><h3 id="自连接"><a href="#自连接" class="headerlink" title="自连接"></a>自连接</h3><p>通过 <code>Email</code> 字段自连接，生成一张临时表。在这张表中，因为 <code>Email</code> 字段值存在重复，所以会存在交叉映射记录。<br>如对于表 <code>Person</code>:</p><table><thead><tr><th align="center">id</th><th align="center">Email</th></tr></thead><tbody><tr><td align="center">1</td><td align="center"><a href="mailto:john@example.com">john@example.com</a></td></tr><tr><td align="center">2</td><td align="center"><a href="mailto:bob@example.com">bob@example.com</a></td></tr><tr><td align="center">3</td><td align="center"><a href="mailto:john@example.com">john@example.com</a></td></tr></tbody></table><p>建立自连接:<br><code>select a.id, a.Email, b.id, b.Email from Person a inner join Person b on a.email = b.email;</code><br>后形成临时表：</p><table><thead><tr><th align="center">id</th><th align="center">Email</th><th align="center">id(1)</th><th align="center">Email(1)</th></tr></thead><tbody><tr><td align="center">1</td><td align="center"><a href="mailto:john@example.com">john@example.com</a></td><td align="center">1</td><td align="center"><a href="mailto:john@example.com">john@example.com</a></td></tr><tr><td align="center">3</td><td align="center"><a href="mailto:john@example.com">john@example.com</a></td><td align="center">1</td><td align="center"><a href="mailto:john@example.com">john@example.com</a></td></tr><tr><td align="center">2</td><td align="center"><a href="mailto:bob@example.com">bob@example.com</a></td><td align="center">2</td><td align="center"><a href="mailto:bob@example.com">bob@example.com</a></td></tr><tr><td align="center">1</td><td align="center"><a href="mailto:john@example.com">john@example.com</a></td><td align="center">3</td><td align="center"><a href="mailto:john@example.com">john@example.com</a></td></tr><tr><td align="center">3</td><td align="center"><a href="mailto:john@example.com">john@example.com</a></td><td align="center">3</td><td align="center"><a href="mailto:john@example.com">john@example.com</a></td></tr></tbody></table><p>由上可知，显然只有 <code>Email = bob@example.com</code> 的情况，两张表映射唯一。<br>而对于 <code>Email = john@example.com</code> 的情况，存在 $4$ 种全排列映射情况。</p><p>为了删除重复记录中 <code>id</code> 最大的记录，可以限定条件：<code>a.id &gt; b.id</code></p><div class="tabs" id="g_tab0"><ul class="nav-tabs"><li class="tab active"><a href="#g_tab0-1">MySQL</a></li></ul><div class="tab-content"><div class="tab-pane active" id="g_tab0-1"><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">delete a from Person as a</span><br><span class="line">inner join Person as b</span><br><span class="line">on a.email &#x3D; b.email and a.id &gt; b.id;</span><br></pre></td></tr></table></figure></div></div></div><div class="note primary">            <p><strong>原题链接：</strong> <a href="https://leetcode.cn/problems/delete-duplicate-emails/" target="_blank" rel="noopener">LeetCode 196. 删除重复的电子邮箱</a></p>          </div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;摘要：&lt;/strong&gt;&lt;br&gt;考察字段值不唯一情况下的自连接（全排列映射）。&lt;/p&gt;
    
    </summary>
    
    
      <category term="指尖飞舞" scheme="https://ntifs.com/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/"/>
    
      <category term="数据库" scheme="https://ntifs.com/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="MySQL" scheme="https://ntifs.com/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/"/>
    
    
      <category term="LeetCode" scheme="https://ntifs.com/tags/LeetCode/"/>
    
      <category term="MySQL" scheme="https://ntifs.com/tags/MySQL/"/>
    
      <category term="数据库" scheme="https://ntifs.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>【AcWing算法基础】第二讲-数据结构-并查集 AcWing 836. 合并集合</title>
    <link href="https://ntifs.com/2022/09/18/%E3%80%90AcWing%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E3%80%91%E7%AC%AC%E4%BA%8C%E8%AE%B2-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%B9%B6%E6%9F%A5%E9%9B%86-AcWing-836-%E5%90%88%E5%B9%B6%E9%9B%86%E5%90%88/"/>
    <id>https://ntifs.com/2022/09/18/%E3%80%90AcWing%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E3%80%91%E7%AC%AC%E4%BA%8C%E8%AE%B2-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%B9%B6%E6%9F%A5%E9%9B%86-AcWing-836-%E5%90%88%E5%B9%B6%E9%9B%86%E5%90%88/</id>
    <published>2022-09-18T06:51:54.000Z</published>
    <updated>2023-07-04T14:06:51.134Z</updated>
    
    <content type="html"><![CDATA[<p><strong>摘要：</strong><br>并查集模板题。</p><a id="more"></a><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>一共有 $n$ 个数，编号是 $1∼n$，最开始每个数各自在一个集合中。</p><p>现在要进行 $m$ 个操作，操作共有两种：</p><ol><li><code>M a b</code>，将编号为 $a$ 和 $b$ 的两个数所在的集合合并，如果两个数已经在同一个集合中，则忽略这个操作；</li><li><code>Q a b</code>，询问编号为 $a$ 和 $b$ 的两个数是否在同一个集合中；</li></ol><p><strong>输入格式</strong><br>第一行输入整数 $n$ 和 $m$。</p><p>接下来 $m$ 行，每行包含一个操作指令，指令为 <code>M a b</code> 或 <code>Q a b</code> 中的一种。</p><p><strong>输出格式</strong><br>对于每个询问指令 <code>Q a b</code>，都要输出一个结果，如果 $a$ 和 $b$ 在同一集合内，则输出 <code>Yes</code>，否则输出 <code>No</code>。</p><p>每个结果占一行。</p><p><strong>数据范围</strong><br>$1≤n,m≤10^5$</p><p><strong>输入样例：</strong></p><blockquote><p>4 5<br>M 1 2<br>M 3 4<br>Q 1 2<br>Q 1 3<br>Q 3 4</p></blockquote><p><strong>输出样例：</strong></p><blockquote><p>Yes<br>No<br>Yes</p></blockquote><hr><h3 id="并查集-Union-Find"><a href="#并查集-Union-Find" class="headerlink" title="并查集/Union-Find"></a>并查集/Union-Find</h3><p>并查集用于解决两个不相交集合 <strong>Disjoint Set</strong> 的合并 <strong>Union</strong>，以及查询两个数是否在同一集合中 <strong>Find</strong> 的问题。<br>并查集可以以 $O(1)$ 的时间复杂度合并两个不相交集合，以及近乎 $O(1)$ 的时间复杂度查询两个数是否在同一集合中。</p><p>核心思想：</p><ol><li>维护一个森林 <strong>Forest</strong>，森林中每个节点保存该节点的父节点值。每棵树表示一个集合。</li><li>合并两个集合 <strong>Union</strong>：找到两个集合所对应的树根节点，将其中一棵树的根节点作为另一棵树根节点的子节点。本质上是合并两颗多叉树。</li><li>查找两个数是否在同一集合 <strong>Find</strong>：分别查找两个数对应森林节点的树根节点，判断根节点是否相同。</li></ol><p>路径压缩优化 <strong>Path Compression</strong>：</p><blockquote><p>在实现 <strong>Find</strong> 时，需要根据当前数在树中自底向上找到父节点直到树根。<br>可以在这个过程中压缩路径，即，找到根节点后，将路径中的每个节点的父节点指向根节点。</p></blockquote><p>实现：</p><div class="tabs" id="g_tab0"><ul class="nav-tabs"><li class="tab active"><a href="#g_tab0-1">C++</a></li></ul><div class="tab-content"><div class="tab-pane active" id="g_tab0-1"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, a, b;</span><br><span class="line"><span class="keyword">char</span> ops;</span><br><span class="line"><span class="keyword">int</span> parent[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init_forest</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) parent[i] = i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (parent[x] != x) parent[x] = <span class="built_in">find</span>(parent[x]);</span><br><span class="line">    <span class="keyword">return</span> parent[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>)-&gt;sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    init_forest();</span><br><span class="line">    <span class="keyword">for</span> (; m--, <span class="built_in">cin</span> &gt;&gt; ops &gt;&gt; a &gt;&gt; b;) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (ops == <span class="string">'M'</span>) </span><br><span class="line">        &#123;</span><br><span class="line">            parent[<span class="built_in">find</span>(a)] = <span class="built_in">find</span>(b);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">find</span>(a) == <span class="built_in">find</span>(b)) <span class="built_in">cout</span> &lt;&lt; <span class="string">"Yes"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; <span class="string">"No"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div></div><ol><li>我们令 <code>parent[x] = x</code> 定义 <code>x</code> 为根节点。</li><li>注意在实现 <code>find</code> 函数找根节点时，我们的做法是自底向上递归处理，在递归过程中如果发现当前节点不为根节点的话，就将当前节点的父节点通过递归的方式指向根节点。</li></ol><div class="note primary">            <p><strong>原题链接：</strong> <a href="https://www.acwing.com/problem/content/838/" target="_blank" rel="noopener">AcWing 836. 合并集合</a></p>          </div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;摘要：&lt;/strong&gt;&lt;br&gt;并查集模板题。&lt;/p&gt;
    
    </summary>
    
    
      <category term="指尖飞舞" scheme="https://ntifs.com/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/"/>
    
      <category term="算法" scheme="https://ntifs.com/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/%E7%AE%97%E6%B3%95/"/>
    
      <category term="AcWing" scheme="https://ntifs.com/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/%E7%AE%97%E6%B3%95/AcWing/"/>
    
      <category term="算法基础课" scheme="https://ntifs.com/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/%E7%AE%97%E6%B3%95/AcWing/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BE/"/>
    
      <category term="第二讲数据结构" scheme="https://ntifs.com/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/%E7%AE%97%E6%B3%95/AcWing/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BE/%E7%AC%AC%E4%BA%8C%E8%AE%B2%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="算法" scheme="https://ntifs.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="树" scheme="https://ntifs.com/tags/%E6%A0%91/"/>
    
      <category term="AcWing" scheme="https://ntifs.com/tags/AcWing/"/>
    
      <category term="并查集" scheme="https://ntifs.com/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    
      <category term="Union-Find" scheme="https://ntifs.com/tags/Union-Find/"/>
    
      <category term="路径压缩" scheme="https://ntifs.com/tags/%E8%B7%AF%E5%BE%84%E5%8E%8B%E7%BC%A9/"/>
    
  </entry>
  
  <entry>
    <title>语言的魅力</title>
    <link href="https://ntifs.com/2022/09/17/%E8%AE%B0%E5%BD%95%E4%B8%80%E4%BA%9B%E5%A5%BD%E7%8E%A9%E7%9A%84%E8%AF%9D/"/>
    <id>https://ntifs.com/2022/09/17/%E8%AE%B0%E5%BD%95%E4%B8%80%E4%BA%9B%E5%A5%BD%E7%8E%A9%E7%9A%84%E8%AF%9D/</id>
    <published>2022-09-17T15:01:25.000Z</published>
    <updated>2023-07-04T14:06:51.120Z</updated>
    
    <content type="html"><![CDATA[<p><strong>摘要：</strong></p><a id="more"></a><ol><li>不知道为啥我觉得他不帅，但真要挑毛病也挑不出来</li><li><h3 id><a href="#" class="headerlink" title></a></h3></li></ol><div class="tabs" id="g_tab0"><ul class="nav-tabs"><li class="tab active"><a href="#g_tab0-1">C++</a></li><li class="tab"><a href="#g_tab0-2">Java</a></li></ul><div class="tab-content"><div class="tab-pane active" id="g_tab0-1"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="g_tab0-2"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></div></div></div><div class="note primary">            <p><strong>原题链接：</strong> <a href></a></p>          </div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;摘要：&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>LeetCode 184. 部门工资最高的员工</title>
    <link href="https://ntifs.com/2022/09/17/LeetCode-184-%E9%83%A8%E9%97%A8%E5%B7%A5%E8%B5%84%E6%9C%80%E9%AB%98%E7%9A%84%E5%91%98%E5%B7%A5/"/>
    <id>https://ntifs.com/2022/09/17/LeetCode-184-%E9%83%A8%E9%97%A8%E5%B7%A5%E8%B5%84%E6%9C%80%E9%AB%98%E7%9A%84%E5%91%98%E5%B7%A5/</id>
    <published>2022-09-17T03:32:22.000Z</published>
    <updated>2023-07-04T14:06:51.120Z</updated>
    
    <content type="html"><![CDATA[<p><strong>摘要：</strong><br>考察GROUP BY、多表联查、多字段 IN 查询。</p><a id="more"></a><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p><a href="https://leetcode.cn/problems/department-highest-salary/" target="_blank" rel="noopener">LeetCode 184. 部门工资最高的员工</a></p><h3 id="GROUP-BY-临时表-多表联查"><a href="#GROUP-BY-临时表-多表联查" class="headerlink" title="GROUP BY + 临时表 + 多表联查"></a>GROUP BY + 临时表 + 多表联查</h3><div class="tabs" id="g_tab0"><ul class="nav-tabs"><li class="tab active"><a href="#g_tab0-1">MySQL</a></li></ul><div class="tab-content"><div class="tab-pane active" id="g_tab0-1"><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">select d.name as Department, e.name as Employee, e.salary as Salary</span><br><span class="line">from </span><br><span class="line">(</span><br><span class="line">select e.departmentId, max(e.salary) as salary</span><br><span class="line">from Employee as e</span><br><span class="line">group by e.departmentId</span><br><span class="line">) as temp</span><br><span class="line">left join Employee as e </span><br><span class="line">on e.departmentId &#x3D; temp.departmentId</span><br><span class="line">and e.salary &#x3D; temp.salary</span><br><span class="line">left join Department as d </span><br><span class="line">on e.departmentId &#x3D; d.id;</span><br></pre></td></tr></table></figure></div></div></div><p>对 <code>Employee</code> 表 <code>departmentId</code> 字段分组查询最高薪资作为临时表。<br>使用该临时表关联 <code>Employee</code> 查到每个 <code>departmentId</code> 和 最高薪资对应员工信息。<br>同时关联 <code>Department</code> 表查询部门信息。</p><p>左连接的使用：临时表来自于 <code>Employee</code> 表，所以左连接查询右表一定存在值。<br>临时表左连接 <code>Department</code> 表查询部门信息时，右表可能存在空值，我们可以允许。</p><h3 id="GROUP-BY-IN-临时表"><a href="#GROUP-BY-IN-临时表" class="headerlink" title="GROUP BY + IN + 临时表"></a>GROUP BY + IN + 临时表</h3><div class="tabs" id="g_tab0"><ul class="nav-tabs"><li class="tab active"><a href="#g_tab0-1">MySQL</a></li></ul><div class="tab-content"><div class="tab-pane active" id="g_tab0-1"><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">select d.name as Department, e.name as Employee, e.salary as Salary</span><br><span class="line">from Employee as e</span><br><span class="line">left join Department as d </span><br><span class="line">on e.departmentId &#x3D; d.id</span><br><span class="line">where (e.departmentId, e.salary) in</span><br><span class="line">(</span><br><span class="line">    select departmentId, max(salary) as salary</span><br><span class="line">    from Employee </span><br><span class="line">    group by departmentId</span><br><span class="line">);</span><br></pre></td></tr></table></figure></div></div></div><p>先关联 <code>Employee</code> 和 <code>Department</code> 两张表组合成一张大表，再使用 <code>IN</code> 条件限定范围。<br>使用 <code>GROUP BY</code> 对 <code>Employee</code> 表按照 <code>DepartmentId</code> 分组求最大薪资划定限定范围。</p><p>有趣的是多字段 <code>IN</code> 的使用。</p><div class="note primary">            <p><strong>原题链接：</strong> <a href="https://leetcode.cn/problems/department-highest-salary/" target="_blank" rel="noopener">LeetCode 184. 部门工资最高的员工</a></p>          </div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;摘要：&lt;/strong&gt;&lt;br&gt;考察GROUP BY、多表联查、多字段 IN 查询。&lt;/p&gt;
    
    </summary>
    
    
      <category term="指尖飞舞" scheme="https://ntifs.com/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/"/>
    
      <category term="数据库" scheme="https://ntifs.com/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="MySQL" scheme="https://ntifs.com/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/"/>
    
    
      <category term="LeetCode" scheme="https://ntifs.com/tags/LeetCode/"/>
    
      <category term="MySQL" scheme="https://ntifs.com/tags/MySQL/"/>
    
      <category term="数据库" scheme="https://ntifs.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>【AcWing算法基础】第二讲-数据结构-Trie AcWing 143. 最大异或对</title>
    <link href="https://ntifs.com/2022/09/16/%E3%80%90AcWing%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E3%80%91%E7%AC%AC%E4%BA%8C%E8%AE%B2-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-Trie-AcWing-143-%E6%9C%80%E5%A4%A7%E5%BC%82%E6%88%96%E5%AF%B9/"/>
    <id>https://ntifs.com/2022/09/16/%E3%80%90AcWing%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E3%80%91%E7%AC%AC%E4%BA%8C%E8%AE%B2-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-Trie-AcWing-143-%E6%9C%80%E5%A4%A7%E5%BC%82%E6%88%96%E5%AF%B9/</id>
    <published>2022-09-16T13:50:45.000Z</published>
    <updated>2023-07-04T14:06:51.119Z</updated>
    
    <content type="html"><![CDATA[<p><strong>摘要：</strong><br>Trie字典树不仅可以存储字符串，也可以存储二进制数，所以理论上Trie可以存储任意信息。</p><a id="more"></a><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>在给定的 $N$ 个整数 $A_1，A_2……A_N$ 中选出两个进行 $xor$（异或）运算，得到的结果最大是多少？</p><p><strong>输入格式</strong><br>第一行输入一个整数 $N$。</p><p>第二行输入 $N$ 个整数 $A_1～A_N$。</p><p><strong>输出格式</strong><br>输出一个整数表示答案。</p><p><strong>数据范围</strong><br>$1≤N≤10^5$,</p><p>$0≤A_i&lt;2^{31}$</p><p><strong>输入样例：</strong></p><blockquote><p>3<br>1 2 3</p></blockquote><p><strong>输出样例：</strong></p><blockquote><p>3</p></blockquote><hr><h3 id="Trie"><a href="#Trie" class="headerlink" title="Trie"></a>Trie</h3><p>暴力做法是遍历数组，对每个数，在剩余数中遍历找到和它异或最大的值。</p><p>可以对遍历找到最大异或值的步骤进行优化。</p><p>如果不考虑最大异或值的取值范围，某个数最大异或值，一定是其二进制每一位都不同的数。然而在这里取值范围是所有其他的数。</p><p>对该数二进制从左到右，我们在剩余数中找到一个数，使得其对应位的二进制值不同，如果没有则取相同。</p><p>可以使用 <code>Trie</code> 实现。构建 <code>Trie</code> 时，将每个数的二进制位从根节点开始插入。<br>查询某个数的最大异或值时，从根节点查找，如果存在二进制值相反的节点则选择该节点，不存在则选择二进制值相同的节点。</p><div class="tabs" id="g_tab0"><ul class="nav-tabs"><li class="tab active"><a href="#g_tab0-1">C++</a></li></ul><div class="tab-content"><div class="tab-pane active" id="g_tab0-1"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">using</span> ll = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100009</span>;</span><br><span class="line"><span class="keyword">int</span> n, numbers[N];</span><br><span class="line"><span class="keyword">int</span> trie[<span class="number">31</span> * N][<span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> idx;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build_trie</span><span class="params">(<span class="keyword">int</span> &amp;num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> p = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">30</span>; ~i; --i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> u = num &gt;&gt; i &amp; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (!trie[p][u]) trie[p][u] = ++idx;</span><br><span class="line">        p = trie[p][u];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">query</span><span class="params">(<span class="keyword">int</span> &amp;num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> p = <span class="number">0</span>;</span><br><span class="line">    ll target = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">30</span>; ~i; --i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> u = num &gt;&gt; i &amp; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (trie[p][!u]) </span><br><span class="line">        &#123;</span><br><span class="line">            target = (target &lt;&lt; <span class="number">1</span>) + !u;</span><br><span class="line">            p = trie[p][!u];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">        &#123;</span><br><span class="line">            target = (target &lt;&lt; <span class="number">1</span>) + u;</span><br><span class="line">            p = trie[p][u];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> target;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>)-&gt;sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) <span class="built_in">cin</span> &gt;&gt; numbers[i];</span><br><span class="line">    </span><br><span class="line">    ll res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> cur = numbers[i];</span><br><span class="line">        build_trie(cur);</span><br><span class="line">        res = <span class="built_in">max</span>(res, query(cur) ^ cur);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; res &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div></div><p>我们选择的是先对每个数拆分成二进制构建 <code>Trie</code>，再对每个数从 <code>Trie</code> 中查询最大异或值。<br>注意下 <code>Trie</code> 数组取值，因为最多 $10^5$ 个数，每个数最多 $31$ 位，所以数组行最多 $10^5 \times 31$，因为每个节点只存在两种值，$0$ 和 $1$，所以数组列为 $2$.</p><div class="note primary">            <p><strong>原题链接：</strong> <a href="https://www.acwing.com/problem/content/description/145/" target="_blank" rel="noopener">AcWing 143. 最大异或对</a></p>          </div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;摘要：&lt;/strong&gt;&lt;br&gt;Trie字典树不仅可以存储字符串，也可以存储二进制数，所以理论上Trie可以存储任意信息。&lt;/p&gt;
    
    </summary>
    
    
      <category term="指尖飞舞" scheme="https://ntifs.com/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/"/>
    
      <category term="算法" scheme="https://ntifs.com/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/%E7%AE%97%E6%B3%95/"/>
    
      <category term="AcWing" scheme="https://ntifs.com/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/%E7%AE%97%E6%B3%95/AcWing/"/>
    
      <category term="算法基础课" scheme="https://ntifs.com/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/%E7%AE%97%E6%B3%95/AcWing/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BE/"/>
    
      <category term="第二讲数据结构" scheme="https://ntifs.com/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/%E7%AE%97%E6%B3%95/AcWing/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BE/%E7%AC%AC%E4%BA%8C%E8%AE%B2%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="算法" scheme="https://ntifs.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="AcWing" scheme="https://ntifs.com/tags/AcWing/"/>
    
      <category term="字典树" scheme="https://ntifs.com/tags/%E5%AD%97%E5%85%B8%E6%A0%91/"/>
    
      <category term="Trie" scheme="https://ntifs.com/tags/Trie/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 183. 从不订购的客户</title>
    <link href="https://ntifs.com/2022/09/16/LeetCode-183-%E4%BB%8E%E4%B8%8D%E8%AE%A2%E8%B4%AD%E7%9A%84%E5%AE%A2%E6%88%B7/"/>
    <id>https://ntifs.com/2022/09/16/LeetCode-183-%E4%BB%8E%E4%B8%8D%E8%AE%A2%E8%B4%AD%E7%9A%84%E5%AE%A2%E6%88%B7/</id>
    <published>2022-09-16T09:20:21.000Z</published>
    <updated>2023-07-04T14:06:51.101Z</updated>
    
    <content type="html"><![CDATA[<p><strong>摘要：</strong><br>NOT IN子查询、左连接的使用。</p><a id="more"></a><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p><a href="https://leetcode.cn/problems/customers-who-never-order/" target="_blank" rel="noopener">LeetCode 183. 从不订购的客户</a></p><h3 id="NOT-IN-子查询"><a href="#NOT-IN-子查询" class="headerlink" title="NOT IN 子查询"></a>NOT IN 子查询</h3><div class="tabs" id="g_tab0"><ul class="nav-tabs"><li class="tab active"><a href="#g_tab0-1">MySQL</a></li></ul><div class="tab-content"><div class="tab-pane active" id="g_tab0-1"><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">select Name as Customers from Customers </span><br><span class="line">where Id not in </span><br><span class="line">(</span><br><span class="line">    select distinct(CustomerId) from Orders</span><br><span class="line">);</span><br></pre></td></tr></table></figure></div></div></div><p>从客户表中查询所有不在订单表中的 <code>Id</code>，可以使用 <code>NOT IN</code> 子查询。</p><h3 id="左连接"><a href="#左连接" class="headerlink" title="左连接"></a>左连接</h3><div class="tabs" id="g_tab0"><ul class="nav-tabs"><li class="tab active"><a href="#g_tab0-1">MySQL</a></li></ul><div class="tab-content"><div class="tab-pane active" id="g_tab0-1"><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">select Name as Customers from Customers as c </span><br><span class="line">left join Orders as o </span><br><span class="line">on c.Id &#x3D; o.CustomerId</span><br><span class="line">where o.CustomerId is null;</span><br></pre></td></tr></table></figure></div></div></div><p>根据左连接的特性，将两表连接，如果右表字段值不存在，则左表对应字段值保留，右表对应字段值为 <code>null</code>.</p><div class="note primary">            <p><strong>原题链接：</strong> <a href="https://leetcode.cn/problems/customers-who-never-order/" target="_blank" rel="noopener">LeetCode 183. 从不订购的客户</a></p>          </div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;摘要：&lt;/strong&gt;&lt;br&gt;NOT IN子查询、左连接的使用。&lt;/p&gt;
    
    </summary>
    
    
      <category term="指尖飞舞" scheme="https://ntifs.com/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/"/>
    
      <category term="数据库" scheme="https://ntifs.com/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="MySQL" scheme="https://ntifs.com/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/"/>
    
    
      <category term="LeetCode" scheme="https://ntifs.com/tags/LeetCode/"/>
    
      <category term="MySQL" scheme="https://ntifs.com/tags/MySQL/"/>
    
      <category term="数据库" scheme="https://ntifs.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>MySQL妙妙屋</title>
    <link href="https://ntifs.com/2022/09/16/MySQL%E5%A6%99%E5%A6%99%E5%B1%8B/"/>
    <id>https://ntifs.com/2022/09/16/MySQL%E5%A6%99%E5%A6%99%E5%B1%8B/</id>
    <published>2022-09-16T07:24:41.000Z</published>
    <updated>2023-07-04T14:06:51.101Z</updated>
    
    <content type="html"><![CDATA[<p><strong>摘要：</strong><br>记录MySQL零碎知识。</p><a id="more"></a><h4 id="1-MySQL语句执行顺序"><a href="#1-MySQL语句执行顺序" class="headerlink" title="1. MySQL语句执行顺序"></a>1. MySQL语句执行顺序</h4><p>顺口溜：</p><blockquote><p>哪里 <code>WHERE</code> 组队 <code>GROUP BY</code> 有 <code>HAVING</code> 顺序 <code>ORDER BY</code> 限制 <code>LIMIT</code></p></blockquote><p>从一个非常聪明的小伙伴那里学来，可以说是非常绝绝子了。<br>注意包括但不仅限于 <code>FROM</code> <code>ON</code> <code>JOIN</code> 这种虚表创建的基础语句当然优先级最高。</p><h4 id="2-对-GROUP-BY-的理解"><a href="#2-对-GROUP-BY-的理解" class="headerlink" title="2. 对 GROUP BY 的理解"></a>2. 对 GROUP BY 的理解</h4><h5 id="GROUP-BY-单个字段"><a href="#GROUP-BY-单个字段" class="headerlink" title="GROUP BY 单个字段"></a>GROUP BY 单个字段</h5><p>对于每条记录合并分组，确保该字段每组值唯一，构建虚表。<br>对于虚表中的每条记录，该字段对应值是唯一的，而其他所有字段值则分别构成容器（不去重）。因为其他字段可能存在重复，所以使用 SELECT 查询虚表时，只能使用聚合函数如 <code>SUM</code>, <code>AVG</code>等等对容器进行操作。<br>举例：对于数据库 <code>name_table</code></p><table><thead><tr><th align="center">id</th><th align="center">name</th></tr></thead><tbody><tr><td align="center">1</td><td align="center">a</td></tr><tr><td align="center">2</td><td align="center">b</td></tr><tr><td align="center">3</td><td align="center">b</td></tr></tbody></table><p>执行 <code>GROUP BY name</code> 后形成虚表 <code>name_table_virtual</code></p><table><thead><tr><th align="center">id</th><th align="center">name</th></tr></thead><tbody><tr><td align="center">1</td><td align="center">a</td></tr><tr><td align="center">2, 3</td><td align="center">b</td></tr></tbody></table><p>对虚表执行 <code>SELECT</code> 筛选操作：<br><code>SELECT COUNT(id) as cnt, name from name_table GROUP BY name WHERE name = &#39;b&#39;;</code></p><p>结果：</p><table><thead><tr><th align="center">cnt</th><th align="center">name</th></tr></thead><tbody><tr><td align="center">2</td><td align="center">b</td></tr></tbody></table><p>注意，这里如果执行 <code>COUNT(name)</code> 数量依旧是 <code>2</code>，因为虽然被 <code>GROUP BY</code> 的字段在虚表中值唯一，但是记录依然是两条。<br><code>COUNT</code> 计算的是记录数量而不是值数量。</p><h4 id="GROUP-BY-多个字段"><a href="#GROUP-BY-多个字段" class="headerlink" title="GROUP BY 多个字段"></a>GROUP BY 多个字段</h4><p>对于每条记录合并分组，确保该多个字段看成一个整体后每组值唯一，构建虚表。<br>对于虚表中的每条记录，改多个字段构成一个整体后，值唯一。而其他所有字段值则分别构成容器（不去重）。因为其他字段可能存在重复，所以使用 <code>SELECT</code> 查询虚表时，只能使用聚合函数如 <code>SUM</code>, <code>AVG</code>等等对容器进行操作。</p><p>举例：对于数据库 <code>info_table</code></p><table><thead><tr><th align="center">id</th><th align="center">name</th><th align="center">title</th></tr></thead><tbody><tr><td align="center">1</td><td align="center">a</td><td align="center">m</td></tr><tr><td align="center">2</td><td align="center">b</td><td align="center">n</td></tr><tr><td align="center">3</td><td align="center">a</td><td align="center">m</td></tr></tbody></table><p>执行 <code>GROUP BY name, title</code> 后形成虚表 <code>info_table_virtual</code></p><table><thead><tr><th align="center">id</th><th align="center">name</th><th align="center">title</th></tr></thead><tbody><tr><td align="center">1,3</td><td align="center">a</td><td align="center">m</td></tr><tr><td align="center">2</td><td align="center">b</td><td align="center">n</td></tr></tbody></table><p>对虚表执行 <code>SELECT</code> 筛选操作：<br><code>SELECT COUNT(id) as cnt, name, title from info_table GROUP BY name, title;</code></p><p>结果：</p><table><thead><tr><th align="center">cnt</th><th align="center">name</th><th>title</th></tr></thead><tbody><tr><td align="center">2</td><td align="center">a</td><td>m</td></tr><tr><td align="center">1</td><td align="center">b</td><td>n</td></tr></tbody></table><h4 id="3-TODO"><a href="#3-TODO" class="headerlink" title="3. TODO"></a>3. TODO</h4>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;摘要：&lt;/strong&gt;&lt;br&gt;记录MySQL零碎知识。&lt;/p&gt;
    
    </summary>
    
    
      <category term="指尖飞舞" scheme="https://ntifs.com/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/"/>
    
      <category term="数据库" scheme="https://ntifs.com/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="MySQL" scheme="https://ntifs.com/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/"/>
    
    
      <category term="MySQL" scheme="https://ntifs.com/tags/MySQL/"/>
    
      <category term="数据库" scheme="https://ntifs.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 182. 查找重复的电子邮箱</title>
    <link href="https://ntifs.com/2022/09/16/LeetCode-182-%E6%9F%A5%E6%89%BE%E9%87%8D%E5%A4%8D%E7%9A%84%E7%94%B5%E5%AD%90%E9%82%AE%E7%AE%B1/"/>
    <id>https://ntifs.com/2022/09/16/LeetCode-182-%E6%9F%A5%E6%89%BE%E9%87%8D%E5%A4%8D%E7%9A%84%E7%94%B5%E5%AD%90%E9%82%AE%E7%AE%B1/</id>
    <published>2022-09-16T02:38:09.000Z</published>
    <updated>2023-07-04T14:06:51.101Z</updated>
    
    <content type="html"><![CDATA[<p><strong>摘要：</strong><br>考查自连接、GROUP BY、临时表、HAVING子句的使用。</p><a id="more"></a><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p><a href="https://leetcode.cn/problems/duplicate-emails/" target="_blank" rel="noopener">LeetCode 182. 查找重复的电子邮箱</a></p><h3 id="自连接"><a href="#自连接" class="headerlink" title="自连接"></a>自连接</h3><div class="tabs" id="g_tab0"><ul class="nav-tabs"><li class="tab active"><a href="#g_tab0-1">MySQL</a></li></ul><div class="tab-content"><div class="tab-pane active" id="g_tab0-1"><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># Write your MySQL query statement below</span><br><span class="line"></span><br><span class="line">select distinct(a.Email) from Person a inner join Person b </span><br><span class="line">on a.Email &#x3D; b.Email </span><br><span class="line">and a.id !&#x3D; b.id</span><br></pre></td></tr></table></figure></div></div></div><p>使用自连接，因为要找到重复 <code>Email</code>，故可以把 <code>Email</code> 作为连接条件。另外要确保 <code>Id</code> 不同。</p><h3 id="GROUP-BY-临时表"><a href="#GROUP-BY-临时表" class="headerlink" title="GROUP BY + 临时表"></a>GROUP BY + 临时表</h3><div class="tabs" id="g_tab0"><ul class="nav-tabs"><li class="tab active"><a href="#g_tab0-1">MySQL</a></li></ul><div class="tab-content"><div class="tab-pane active" id="g_tab0-1"><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">select temp.email as Email from</span><br><span class="line">(</span><br><span class="line">select Email as email, count(Email) as count from Person </span><br><span class="line">group by Email</span><br><span class="line">) as temp </span><br><span class="line">where temp.count &gt; 1;</span><br></pre></td></tr></table></figure></div></div></div><p>我们的目的是查找重复邮箱，很显然可以想到使用 <code>GROUP BY</code> 对 <code>Email</code> 字段进行合并分组。<code>GROUP BY</code> 后相同 <code>Email</code> 会合并为一组，每组包括所有不同 <code>Id</code>。我们给 <code>Id</code> 计数可得每组数量。<br>将上述操作作为一个子查询生成一张临时表，从该表中选择查询即可得到我们想要的结果。</p><h3 id="GROUP-BY-HAVING-子句"><a href="#GROUP-BY-HAVING-子句" class="headerlink" title="GROUP BY + HAVING 子句"></a>GROUP BY + HAVING 子句</h3><p>我们分组之后可以不借助临时表而是直接使用 <code>HAVING</code> 子句对分组后的状态进行筛选查询:</p><div class="tabs" id="g_tab0"><ul class="nav-tabs"><li class="tab active"><a href="#g_tab0-1">MySQL</a></li></ul><div class="tab-content"><div class="tab-pane active" id="g_tab0-1"><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">select p.Email</span><br><span class="line">from Person as p</span><br><span class="line">group by p.Email </span><br><span class="line">having count(p.id) &gt; 1;</span><br></pre></td></tr></table></figure></div></div></div><div class="note primary">            <p><strong>原题链接：</strong> <a href="https://leetcode.cn/problems/duplicate-emails/" target="_blank" rel="noopener">LeetCode 182. 查找重复的电子邮箱</a></p>          </div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;摘要：&lt;/strong&gt;&lt;br&gt;考查自连接、GROUP BY、临时表、HAVING子句的使用。&lt;/p&gt;
    
    </summary>
    
    
      <category term="指尖飞舞" scheme="https://ntifs.com/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/"/>
    
      <category term="数据库" scheme="https://ntifs.com/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="MySQL" scheme="https://ntifs.com/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/"/>
    
    
      <category term="LeetCode" scheme="https://ntifs.com/tags/LeetCode/"/>
    
      <category term="MySQL" scheme="https://ntifs.com/tags/MySQL/"/>
    
      <category term="数据库" scheme="https://ntifs.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 181. 超过经理收入的员工</title>
    <link href="https://ntifs.com/2022/09/15/LeetCode-181-%E8%B6%85%E8%BF%87%E7%BB%8F%E7%90%86%E6%94%B6%E5%85%A5%E7%9A%84%E5%91%98%E5%B7%A5/"/>
    <id>https://ntifs.com/2022/09/15/LeetCode-181-%E8%B6%85%E8%BF%87%E7%BB%8F%E7%90%86%E6%94%B6%E5%85%A5%E7%9A%84%E5%91%98%E5%B7%A5/</id>
    <published>2022-09-15T15:54:44.000Z</published>
    <updated>2023-07-04T14:06:51.101Z</updated>
    
    <content type="html"><![CDATA[<p><strong>摘要：</strong><br>依然是自连接查询题。</p><a id="more"></a><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p><a href="https://leetcode.cn/problems/employees-earning-more-than-their-managers/" target="_blank" rel="noopener">LeetCode 181. 超过经理收入的员工</a></p><h3 id="自连接"><a href="#自连接" class="headerlink" title="自连接"></a>自连接</h3><div class="tabs" id="g_tab0"><ul class="nav-tabs"><li class="tab active"><a href="#g_tab0-1">MySQL</a></li></ul><div class="tab-content"><div class="tab-pane active" id="g_tab0-1"><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">select </span><br><span class="line">a.name as Employee</span><br><span class="line">from Employee a</span><br><span class="line">inner join Employee b</span><br><span class="line">where a.managerId &#x3D; b.id</span><br><span class="line">and a.salary &gt; b.salary;</span><br></pre></td></tr></table></figure></div></div></div><p>因为要用每一项的managerId查询对应薪水，不难想到使用自连接查询，将连接条件设置为id和managerId。使得同一张表的每条记录的id和managerId形成映射关系。</p><div class="note primary">            <p><strong>原题链接：</strong> <a href="https://leetcode.cn/problems/employees-earning-more-than-their-managers/" target="_blank" rel="noopener">LeetCode 181. 超过经理收入的员工</a></p>          </div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;摘要：&lt;/strong&gt;&lt;br&gt;依然是自连接查询题。&lt;/p&gt;
    
    </summary>
    
    
      <category term="指尖飞舞" scheme="https://ntifs.com/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/"/>
    
      <category term="数据库" scheme="https://ntifs.com/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="MySQL" scheme="https://ntifs.com/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/"/>
    
    
      <category term="LeetCode" scheme="https://ntifs.com/tags/LeetCode/"/>
    
      <category term="MySQL" scheme="https://ntifs.com/tags/MySQL/"/>
    
      <category term="数据库" scheme="https://ntifs.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
</feed>
